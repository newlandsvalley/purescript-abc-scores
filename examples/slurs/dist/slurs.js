// Generated by purs bundle 0.13.3
var PS = {};
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Alt"] = $PS["Control.Alt"] || {};
  var exports = $PS["Control.Alt"];                          
  var Alt = function (Functor0, alt) {
      this.Functor0 = Functor0;
      this.alt = alt;
  };                                                       
  var alt = function (dict) {
      return dict.alt;
  };
  exports["Alt"] = Alt;
  exports["alt"] = alt;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Alternative"] = $PS["Control.Alternative"] || {};
  var exports = $PS["Control.Alternative"];              
  var Alternative = function (Applicative0, Plus1) {
      this.Applicative0 = Applicative0;
      this.Plus1 = Plus1;
  };
  exports["Alternative"] = Alternative;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Semigroupoid"] = $PS["Control.Semigroupoid"] || {};
  var exports = $PS["Control.Semigroupoid"];
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });
  var compose = function (dict) {
      return dict.compose;
  };
  exports["compose"] = compose;
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Category"] = $PS["Control.Category"] || {};
  var exports = $PS["Control.Category"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];                
  var Category = function (Semigroupoid0, identity) {
      this.Semigroupoid0 = Semigroupoid0;
      this.identity = identity;
  };
  var identity = function (dict) {
      return dict.identity;
  };
  var categoryFn = new Category(function () {
      return Control_Semigroupoid.semigroupoidFn;
  }, function (x) {
      return x;
  });
  exports["identity"] = identity;
  exports["categoryFn"] = categoryFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Function"] = $PS["Data.Function"] || {};
  var exports = $PS["Data.Function"];
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };
  exports["flip"] = flip;
  exports["const"] = $$const;
})(PS);
(function(exports) {
  "use strict";

  exports.arrayMap = function (f) {
    return function (arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function(exports) {
  "use strict";

  exports.unit = {};
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Unit"] = $PS["Data.Unit"] || {};
  var exports = $PS["Data.Unit"];
  var $foreign = $PS["Data.Unit"];
  exports["unit"] = $foreign.unit;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Functor"] = $PS["Data.Functor"] || {};
  var exports = $PS["Data.Functor"];
  var $foreign = $PS["Data.Functor"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];
  var Data_Function = $PS["Data.Function"];
  var Data_Unit = $PS["Data.Unit"];                
  var Functor = function (map) {
      this.map = map;
  };
  var map = function (dict) {
      return dict.map;
  };
  var mapFlipped = function (dictFunctor) {
      return function (fa) {
          return function (f) {
              return map(dictFunctor)(f)(fa);
          };
      };
  };
  var $$void = function (dictFunctor) {
      return map(dictFunctor)(Data_Function["const"](Data_Unit.unit));
  };
  var voidRight = function (dictFunctor) {
      return function (x) {
          return map(dictFunctor)(Data_Function["const"](x));
      };
  };
  var functorFn = new Functor(Control_Semigroupoid.compose(Control_Semigroupoid.semigroupoidFn));
  var functorArray = new Functor($foreign.arrayMap);
  exports["Functor"] = Functor;
  exports["map"] = map;
  exports["mapFlipped"] = mapFlipped;
  exports["void"] = $$void;
  exports["voidRight"] = voidRight;
  exports["functorFn"] = functorFn;
  exports["functorArray"] = functorArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Apply"] = $PS["Control.Apply"] || {};
  var exports = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];                
  var Apply = function (Functor0, apply) {
      this.Functor0 = Functor0;
      this.apply = apply;
  };                      
  var apply = function (dict) {
      return dict.apply;
  };
  var applyFirst = function (dictApply) {
      return function (a) {
          return function (b) {
              return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Data_Function["const"])(a))(b);
          };
      };
  };
  var applySecond = function (dictApply) {
      return function (a) {
          return function (b) {
              return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Data_Function["const"](Control_Category.identity(Control_Category.categoryFn)))(a))(b);
          };
      };
  };
  var lift2 = function (dictApply) {
      return function (f) {
          return function (a) {
              return function (b) {
                  return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(f)(a))(b);
              };
          };
      };
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
  exports["applyFirst"] = applyFirst;
  exports["applySecond"] = applySecond;
  exports["lift2"] = lift2;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Applicative"] = $PS["Control.Applicative"] || {};
  var exports = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];        
  var Applicative = function (Apply0, pure) {
      this.Apply0 = Apply0;
      this.pure = pure;
  };
  var pure = function (dict) {
      return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);
          };
      };
  };
  exports["Applicative"] = Applicative;
  exports["pure"] = pure;
  exports["liftA1"] = liftA1;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Bind"] = $PS["Control.Bind"] || {};
  var exports = $PS["Control.Bind"];
  var Control_Category = $PS["Control.Category"];
  var Bind = function (Apply0, bind) {
      this.Apply0 = Apply0;
      this.bind = bind;
  };                     
  var bind = function (dict) {
      return dict.bind;
  };
  var join = function (dictBind) {
      return function (m) {
          return bind(dictBind)(m)(Control_Category.identity(Control_Category.categoryFn));
      };
  };
  exports["Bind"] = Bind;
  exports["bind"] = bind;
  exports["join"] = join;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Monad"] = $PS["Control.Monad"] || {};
  var exports = $PS["Control.Monad"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];                
  var Monad = function (Applicative0, Bind1) {
      this.Applicative0 = Applicative0;
      this.Bind1 = Bind1;
  };
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad.Bind1())(f)(function (v) {
                  return Control_Bind.bind(dictMonad.Bind1())(a)(function (v1) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(v(v1));
                  });
              });
          };
      };
  };
  exports["Monad"] = Monad;
  exports["ap"] = ap;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Monad.Error.Class"] = $PS["Control.Monad.Error.Class"] || {};
  var exports = $PS["Control.Monad.Error.Class"];                
  var MonadThrow = function (Monad0, throwError) {
      this.Monad0 = Monad0;
      this.throwError = throwError;
  };
  var throwError = function (dict) {
      return dict.throwError;
  };
  exports["throwError"] = throwError;
  exports["MonadThrow"] = MonadThrow;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Tuple"] = $PS["Data.Tuple"] || {};
  var exports = $PS["Data.Tuple"];
  var Data_Functor = $PS["Data.Functor"];                  
  var Tuple = (function () {
      function Tuple(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Tuple.create = function (value0) {
          return function (value1) {
              return new Tuple(value0, value1);
          };
      };
      return Tuple;
  })();
  var uncurry = function (f) {
      return function (v) {
          return f(v.value0)(v.value1);
      };
  };
  var snd = function (v) {
      return v.value1;
  };
  var functorTuple = new Data_Functor.Functor(function (f) {
      return function (m) {
          return new Tuple(m.value0, f(m.value1));
      };
  });                                                                                                   
  var fst = function (v) {
      return v.value0;
  };
  exports["Tuple"] = Tuple;
  exports["fst"] = fst;
  exports["snd"] = snd;
  exports["uncurry"] = uncurry;
  exports["functorTuple"] = functorTuple;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Monad.State.Class"] = $PS["Control.Monad.State.Class"] || {};
  var exports = $PS["Control.Monad.State.Class"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unit = $PS["Data.Unit"];                
  var MonadState = function (Monad0, state) {
      this.Monad0 = Monad0;
      this.state = state;
  };
  var state = function (dict) {
      return dict.state;
  };
  var put = function (dictMonadState) {
      return function (s) {
          return state(dictMonadState)(function (v) {
              return new Data_Tuple.Tuple(Data_Unit.unit, s);
          });
      };
  };
  var get = function (dictMonadState) {
      return state(dictMonadState)(function (s) {
          return new Data_Tuple.Tuple(s, s);
      });
  };
  exports["state"] = state;
  exports["MonadState"] = MonadState;
  exports["get"] = get;
  exports["put"] = put;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Monad.Trans.Class"] = $PS["Control.Monad.Trans.Class"] || {};
  var exports = $PS["Control.Monad.Trans.Class"];
  var MonadTrans = function (lift) {
      this.lift = lift;
  };
  var lift = function (dict) {
      return dict.lift;
  };
  exports["lift"] = lift;
  exports["MonadTrans"] = MonadTrans;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Bifunctor"] = $PS["Data.Bifunctor"] || {};
  var exports = $PS["Data.Bifunctor"];
  var Control_Category = $PS["Control.Category"];                
  var Bifunctor = function (bimap) {
      this.bimap = bimap;
  };
  var bimap = function (dict) {
      return dict.bimap;
  };
  var lmap = function (dictBifunctor) {
      return function (f) {
          return bimap(dictBifunctor)(f)(Control_Category.identity(Control_Category.categoryFn));
      };
  };
  exports["bimap"] = bimap;
  exports["Bifunctor"] = Bifunctor;
  exports["lmap"] = lmap;
})(PS);
(function(exports) {
  "use strict";

  var refEq = function (r1) {
    return function (r2) {
      return r1 === r2;
    };
  };

  exports.eqBooleanImpl = refEq;
  exports.eqIntImpl = refEq;   
  exports.eqCharImpl = refEq;
  exports.eqStringImpl = refEq;
})(PS["Data.Eq"] = PS["Data.Eq"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Symbol"] = $PS["Data.Symbol"] || {};
  var exports = $PS["Data.Symbol"];      
  var SProxy = (function () {
      function SProxy() {

      };
      SProxy.value = new SProxy();
      return SProxy;
  })();
  var IsSymbol = function (reflectSymbol) {
      this.reflectSymbol = reflectSymbol;
  };
  var reflectSymbol = function (dict) {
      return dict.reflectSymbol;
  };
  exports["IsSymbol"] = IsSymbol;
  exports["reflectSymbol"] = reflectSymbol;
  exports["SProxy"] = SProxy;
})(PS);
(function(exports) {
  "use strict";

  exports.unsafeGet = function (label) {
    return function (rec) {
      return rec[label];
    };
  };

  exports.unsafeSet = function (label) {
    return function (value) {
      return function (rec) {
        var copy = {};
        for (var key in rec) {
          if ({}.hasOwnProperty.call(rec, key)) {
            copy[key] = rec[key];
          }
        }
        copy[label] = value;
        return copy;
      };
    };
  };
})(PS["Record.Unsafe"] = PS["Record.Unsafe"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Record.Unsafe"] = $PS["Record.Unsafe"] || {};
  var exports = $PS["Record.Unsafe"];
  var $foreign = $PS["Record.Unsafe"];
  exports["unsafeGet"] = $foreign.unsafeGet;
  exports["unsafeSet"] = $foreign.unsafeSet;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Type.Data.RowList"] = $PS["Type.Data.RowList"] || {};
  var exports = $PS["Type.Data.RowList"];
  var RLProxy = (function () {
      function RLProxy() {

      };
      RLProxy.value = new RLProxy();
      return RLProxy;
  })();
  exports["RLProxy"] = RLProxy;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Eq"] = $PS["Data.Eq"] || {};
  var exports = $PS["Data.Eq"];
  var $foreign = $PS["Data.Eq"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Record_Unsafe = $PS["Record.Unsafe"];
  var Type_Data_RowList = $PS["Type.Data.RowList"];                
  var EqRecord = function (eqRecord) {
      this.eqRecord = eqRecord;
  };
  var Eq = function (eq) {
      this.eq = eq;
  }; 
  var eqString = new Eq($foreign.eqStringImpl);
  var eqRowNil = new EqRecord(function (v) {
      return function (v1) {
          return function (v2) {
              return true;
          };
      };
  });
  var eqRecord = function (dict) {
      return dict.eqRecord;
  };
  var eqRec = function (dictRowToList) {
      return function (dictEqRecord) {
          return new Eq(eqRecord(dictEqRecord)(Type_Data_RowList.RLProxy.value));
      };
  };                                           
  var eqInt = new Eq($foreign.eqIntImpl);
  var eqChar = new Eq($foreign.eqCharImpl);
  var eqBoolean = new Eq($foreign.eqBooleanImpl);
  var eq = function (dict) {
      return dict.eq;
  }; 
  var eqRowCons = function (dictEqRecord) {
      return function (dictCons) {
          return function (dictIsSymbol) {
              return function (dictEq) {
                  return new EqRecord(function (v) {
                      return function (ra) {
                          return function (rb) {
                              var tail = eqRecord(dictEqRecord)(Type_Data_RowList.RLProxy.value)(ra)(rb);
                              var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Data_Symbol.SProxy.value);
                              var get = Record_Unsafe.unsafeGet(key);
                              return eq(dictEq)(get(ra))(get(rb)) && tail;
                          };
                      };
                  });
              };
          };
      };
  };
  var notEq = function (dictEq) {
      return function (x) {
          return function (y) {
              return eq(eqBoolean)(eq(dictEq)(x)(y))(false);
          };
      };
  };
  exports["Eq"] = Eq;
  exports["eq"] = eq;
  exports["notEq"] = notEq;
  exports["eqInt"] = eqInt;
  exports["eqChar"] = eqChar;
  exports["eqString"] = eqString;
  exports["eqRec"] = eqRec;
  exports["eqRowNil"] = eqRowNil;
  exports["eqRowCons"] = eqRowCons;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Maybe"] = $PS["Data.Maybe"] || {};
  var exports = $PS["Data.Maybe"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Category = $PS["Control.Category"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];          
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var maybe = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Nothing) {
                  return v;
              };
              if (v2 instanceof Just) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe (line 217, column 1 - line 217, column 51): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  var isNothing = maybe(true)(Data_Function["const"](false));
  var isJust = maybe(false)(Data_Function["const"](true));
  var functorMaybe = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Just) {
              return new Just(v(v1.value0));
          };
          return Nothing.value;
      };
  });
  var fromMaybe = function (a) {
      return maybe(a)(Control_Category.identity(Control_Category.categoryFn));
  };
  var fromJust = function (dictPartial) {
      return function (v) {
          if (v instanceof Just) {
              return v.value0;
          };
          throw new Error("Failed pattern match at Data.Maybe (line 268, column 1 - line 268, column 46): " + [ v.constructor.name ]);
      };
  }; 
  var eqMaybe = function (dictEq) {
      return new Data_Eq.Eq(function (x) {
          return function (y) {
              if (x instanceof Nothing && y instanceof Nothing) {
                  return true;
              };
              if (x instanceof Just && y instanceof Just) {
                  return Data_Eq.eq(dictEq)(x.value0)(y.value0);
              };
              return false;
          };
      });
  };
  var applyMaybe = new Control_Apply.Apply(function () {
      return functorMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Just) {
              return Data_Functor.map(functorMaybe)(v.value0)(v1);
          };
          if (v instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var bindMaybe = new Control_Bind.Bind(function () {
      return applyMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Just) {
              return v1(v.value0);
          };
          if (v instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["maybe"] = maybe;
  exports["fromMaybe"] = fromMaybe;
  exports["isJust"] = isJust;
  exports["isNothing"] = isNothing;
  exports["fromJust"] = fromJust;
  exports["functorMaybe"] = functorMaybe;
  exports["bindMaybe"] = bindMaybe;
  exports["eqMaybe"] = eqMaybe;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Either"] = $PS["Data.Either"] || {};
  var exports = $PS["Data.Either"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Bifunctor = $PS["Data.Bifunctor"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];              
  var Left = (function () {
      function Left(value0) {
          this.value0 = value0;
      };
      Left.create = function (value0) {
          return new Left(value0);
      };
      return Left;
  })();
  var Right = (function () {
      function Right(value0) {
          this.value0 = value0;
      };
      Right.create = function (value0) {
          return new Right(value0);
      };
      return Right;
  })();
  var functorEither = new Data_Functor.Functor(function (f) {
      return function (m) {
          if (m instanceof Left) {
              return new Left(m.value0);
          };
          if (m instanceof Right) {
              return new Right(f(m.value0));
          };
          throw new Error("Failed pattern match at Data.Either (line 38, column 1 - line 38, column 52): " + [ m.constructor.name ]);
      };
  });
  var either = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Left) {
                  return v(v2.value0);
              };
              if (v2 instanceof Right) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Either (line 238, column 1 - line 238, column 64): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  var hush = either(Data_Function["const"](Data_Maybe.Nothing.value))(Data_Maybe.Just.create);
  var bifunctorEither = new Data_Bifunctor.Bifunctor(function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Left) {
                  return new Left(v(v2.value0));
              };
              if (v2 instanceof Right) {
                  return new Right(v1(v2.value0));
              };
              throw new Error("Failed pattern match at Data.Either (line 46, column 1 - line 48, column 36): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  });
  var applyEither = new Control_Apply.Apply(function () {
      return functorEither;
  }, function (v) {
      return function (v1) {
          if (v instanceof Left) {
              return new Left(v.value0);
          };
          if (v instanceof Right) {
              return Data_Functor.map(functorEither)(v.value0)(v1);
          };
          throw new Error("Failed pattern match at Data.Either (line 82, column 1 - line 84, column 30): " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var bindEither = new Control_Bind.Bind(function () {
      return applyEither;
  }, either(function (e) {
      return function (v) {
          return new Left(e);
      };
  })(function (a) {
      return function (f) {
          return f(a);
      };
  }));
  var applicativeEither = new Control_Applicative.Applicative(function () {
      return applyEither;
  }, Right.create);
  var monadEither = new Control_Monad.Monad(function () {
      return applicativeEither;
  }, function () {
      return bindEither;
  });
  exports["Left"] = Left;
  exports["Right"] = Right;
  exports["either"] = either;
  exports["hush"] = hush;
  exports["functorEither"] = functorEither;
  exports["bifunctorEither"] = bifunctorEither;
  exports["applicativeEither"] = applicativeEither;
  exports["bindEither"] = bindEither;
  exports["monadEither"] = monadEither;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Monad.Except.Trans"] = $PS["Control.Monad.Except.Trans"] || {};
  var exports = $PS["Control.Monad.Except.Trans"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Control_Monad_Error_Class = $PS["Control.Monad.Error.Class"];
  var Control_Monad_State_Class = $PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = $PS["Control.Monad.Trans.Class"];
  var Data_Either = $PS["Data.Either"];
  var Data_Functor = $PS["Data.Functor"];                
  var ExceptT = function (x) {
      return x;
  };
  var withExceptT = function (dictFunctor) {
      return function (f) {
          return function (v) {
              var mapLeft = function (v1) {
                  return function (v2) {
                      if (v2 instanceof Data_Either.Right) {
                          return new Data_Either.Right(v2.value0);
                      };
                      if (v2 instanceof Data_Either.Left) {
                          return new Data_Either.Left(v1(v2.value0));
                      };
                      throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 42, column 3 - line 42, column 32): " + [ v1.constructor.name, v2.constructor.name ]);
                  };
              };
              return ExceptT(Data_Functor.map(dictFunctor)(mapLeft(f))(v));
          };
      };
  };
  var runExceptT = function (v) {
      return v;
  };          
  var monadTransExceptT = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return function (m) {
          return Control_Bind.bind(dictMonad.Bind1())(m)(function (v) {
              return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Either.Right(v));
          });
      };
  });
  var mapExceptT = function (f) {
      return function (v) {
          return f(v);
      };
  };
  var functorExceptT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return mapExceptT(Data_Functor.map(dictFunctor)(Data_Functor.map(Data_Either.functorEither)(f)));
      });
  };
  var monadExceptT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeExceptT(dictMonad);
      }, function () {
          return bindExceptT(dictMonad);
      });
  };
  var bindExceptT = function (dictMonad) {
      return new Control_Bind.Bind(function () {
          return applyExceptT(dictMonad);
      }, function (v) {
          return function (k) {
              return Control_Bind.bind(dictMonad.Bind1())(v)(Data_Either.either((function () {
                  var $98 = Control_Applicative.pure(dictMonad.Applicative0());
                  return function ($99) {
                      return $98(Data_Either.Left.create($99));
                  };
              })())(function (a) {
                  var v1 = k(a);
                  return v1;
              }));
          };
      });
  };
  var applyExceptT = function (dictMonad) {
      return new Control_Apply.Apply(function () {
          return functorExceptT(((dictMonad.Bind1()).Apply0()).Functor0());
      }, Control_Monad.ap(monadExceptT(dictMonad)));
  };
  var applicativeExceptT = function (dictMonad) {
      return new Control_Applicative.Applicative(function () {
          return applyExceptT(dictMonad);
      }, (function () {
          var $100 = Control_Applicative.pure(dictMonad.Applicative0());
          return function ($101) {
              return ExceptT($100(Data_Either.Right.create($101)));
          };
      })());
  };
  var monadStateExceptT = function (dictMonadState) {
      return new Control_Monad_State_Class.MonadState(function () {
          return monadExceptT(dictMonadState.Monad0());
      }, function (f) {
          return Control_Monad_Trans_Class.lift(monadTransExceptT)(dictMonadState.Monad0())(Control_Monad_State_Class.state(dictMonadState)(f));
      });
  };
  var monadThrowExceptT = function (dictMonad) {
      return new Control_Monad_Error_Class.MonadThrow(function () {
          return monadExceptT(dictMonad);
      }, (function () {
          var $110 = Control_Applicative.pure(dictMonad.Applicative0());
          return function ($111) {
              return ExceptT($110(Data_Either.Left.create($111)));
          };
      })());
  };
  exports["runExceptT"] = runExceptT;
  exports["withExceptT"] = withExceptT;
  exports["applicativeExceptT"] = applicativeExceptT;
  exports["bindExceptT"] = bindExceptT;
  exports["monadExceptT"] = monadExceptT;
  exports["monadThrowExceptT"] = monadThrowExceptT;
  exports["monadStateExceptT"] = monadStateExceptT;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Monad.Rec.Class"] = $PS["Control.Monad.Rec.Class"] || {};
  var exports = $PS["Control.Monad.Rec.Class"];
  var Data_Bifunctor = $PS["Data.Bifunctor"];
  var Data_Either = $PS["Data.Either"];              
  var Loop = (function () {
      function Loop(value0) {
          this.value0 = value0;
      };
      Loop.create = function (value0) {
          return new Loop(value0);
      };
      return Loop;
  })();
  var Done = (function () {
      function Done(value0) {
          this.value0 = value0;
      };
      Done.create = function (value0) {
          return new Done(value0);
      };
      return Done;
  })();
  var MonadRec = function (Monad0, tailRecM) {
      this.Monad0 = Monad0;
      this.tailRecM = tailRecM;
  };
  var tailRecM = function (dict) {
      return dict.tailRecM;
  };
  var tailRec = function (f) {
      var go = function ($copy_v) {
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(v) {
              if (v instanceof Loop) {
                  $copy_v = f(v.value0);
                  return;
              };
              if (v instanceof Done) {
                  $tco_done = true;
                  return v.value0;
              };
              throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 93, column 3 - line 93, column 25): " + [ v.constructor.name ]);
          };
          while (!$tco_done) {
              $tco_result = $tco_loop($copy_v);
          };
          return $tco_result;
      };
      return function ($63) {
          return go(f($63));
      };
  }; 
  var monadRecEither = new MonadRec(function () {
      return Data_Either.monadEither;
  }, function (f) {
      return function (a0) {
          var g = function (v) {
              if (v instanceof Data_Either.Left) {
                  return new Done(new Data_Either.Left(v.value0));
              };
              if (v instanceof Data_Either.Right && v.value0 instanceof Loop) {
                  return new Loop(f(v.value0.value0));
              };
              if (v instanceof Data_Either.Right && v.value0 instanceof Done) {
                  return new Done(new Data_Either.Right(v.value0.value0));
              };
              throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 121, column 7 - line 121, column 33): " + [ v.constructor.name ]);
          };
          return tailRec(g)(f(a0));
      };
  });
  var bifunctorStep = new Data_Bifunctor.Bifunctor(function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Loop) {
                  return new Loop(v(v2.value0));
              };
              if (v2 instanceof Done) {
                  return new Done(v1(v2.value0));
              };
              throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 29, column 1 - line 31, column 34): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  });
  exports["Loop"] = Loop;
  exports["Done"] = Done;
  exports["MonadRec"] = MonadRec;
  exports["tailRecM"] = tailRecM;
  exports["bifunctorStep"] = bifunctorStep;
  exports["monadRecEither"] = monadRecEither;
})(PS);
(function(exports) {
  "use strict";

  exports.map_ = function (f) {
    return function (a) {
      return function () {
        return f(a());
      };
    };
  };

  exports.pure_ = function (a) {
    return function () {
      return a;
    };
  };

  exports.bind_ = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };

  exports.new = function (val) {
    return function () {
      return { value: val };
    };
  };

  exports.read = function (ref) {
    return function () {
      return ref.value;
    };
  };

  exports["modify'"] = function (f) {
    return function (ref) {
      return function () {
        var t = f(ref.value);
        ref.value = t.state;
        return t.value;
      };
    };
  };

  exports.write = function (a) {
    return function (ref) {
      return function () {
        return ref.value = a; // eslint-disable-line no-return-assign
      };
    };
  };
})(PS["Control.Monad.ST.Internal"] = PS["Control.Monad.ST.Internal"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Monad.ST.Internal"] = $PS["Control.Monad.ST.Internal"] || {};
  var exports = $PS["Control.Monad.ST.Internal"];
  var $foreign = $PS["Control.Monad.ST.Internal"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Functor = $PS["Data.Functor"];          
  var modify = function (f) {
      return $foreign["modify'"](function (s) {
          var s$prime = f(s);
          return {
              state: s$prime,
              value: s$prime
          };
      });
  };
  var functorST = new Data_Functor.Functor($foreign.map_);
  var monadST = new Control_Monad.Monad(function () {
      return applicativeST;
  }, function () {
      return bindST;
  });
  var bindST = new Control_Bind.Bind(function () {
      return applyST;
  }, $foreign.bind_);
  var applyST = new Control_Apply.Apply(function () {
      return functorST;
  }, Control_Monad.ap(monadST));
  var applicativeST = new Control_Applicative.Applicative(function () {
      return applyST;
  }, $foreign.pure_);
  exports["modify"] = modify;
  exports["functorST"] = functorST;
  exports["applicativeST"] = applicativeST;
  exports["new"] = $foreign["new"];
  exports["read"] = $foreign.read;
  exports["write"] = $foreign.write;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Monad.State"] = $PS["Control.Monad.State"] || {};
  var exports = $PS["Control.Monad.State"];
  var evalState = function (v) {
      return function (s) {
          var v1 = v(s);
          return v1.value0;
      };
  };
  exports["evalState"] = evalState;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Monad.State.Trans"] = $PS["Control.Monad.State.Trans"] || {};
  var exports = $PS["Control.Monad.State.Trans"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Control_Monad_State_Class = $PS["Control.Monad.State.Class"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Tuple = $PS["Data.Tuple"];                    
  var StateT = function (x) {
      return x;
  }; 
  var functorStateT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return function (s) {
                  return Data_Functor.map(dictFunctor)(function (v1) {
                      return new Data_Tuple.Tuple(f(v1.value0), v1.value1);
                  })(v(s));
              };
          };
      });
  };
  var evalStateT = function (dictFunctor) {
      return function (v) {
          return function (s) {
              return Data_Functor.map(dictFunctor)(Data_Tuple.fst)(v(s));
          };
      };
  };
  var monadStateT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeStateT(dictMonad);
      }, function () {
          return bindStateT(dictMonad);
      });
  };
  var bindStateT = function (dictMonad) {
      return new Control_Bind.Bind(function () {
          return applyStateT(dictMonad);
      }, function (v) {
          return function (f) {
              return function (s) {
                  return Control_Bind.bind(dictMonad.Bind1())(v(s))(function (v1) {
                      var v3 = f(v1.value0);
                      return v3(v1.value1);
                  });
              };
          };
      });
  };
  var applyStateT = function (dictMonad) {
      return new Control_Apply.Apply(function () {
          return functorStateT(((dictMonad.Bind1()).Apply0()).Functor0());
      }, Control_Monad.ap(monadStateT(dictMonad)));
  };
  var applicativeStateT = function (dictMonad) {
      return new Control_Applicative.Applicative(function () {
          return applyStateT(dictMonad);
      }, function (a) {
          return function (s) {
              return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(a, s));
          };
      });
  };
  var monadStateStateT = function (dictMonad) {
      return new Control_Monad_State_Class.MonadState(function () {
          return monadStateT(dictMonad);
      }, function (f) {
          return StateT((function () {
              var $114 = Control_Applicative.pure(dictMonad.Applicative0());
              return function ($115) {
                  return $114(f($115));
              };
          })());
      });
  };
  exports["evalStateT"] = evalStateT;
  exports["functorStateT"] = functorStateT;
  exports["applicativeStateT"] = applicativeStateT;
  exports["bindStateT"] = bindStateT;
  exports["monadStateT"] = monadStateT;
  exports["monadStateStateT"] = monadStateStateT;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Control.Plus"] = $PS["Control.Plus"] || {};
  var exports = $PS["Control.Plus"];                   
  var Plus = function (Alt0, empty) {
      this.Alt0 = Alt0;
      this.empty = empty;
  };       
  var empty = function (dict) {
      return dict.empty;
  };
  exports["Plus"] = Plus;
  exports["empty"] = empty;
})(PS);
(function(exports) {
  "use strict";

  exports.toCharCode = function (c) {
    return c.charCodeAt(0);
  };

  exports.fromCharCode = function (c) {
    return String.fromCharCode(c);
  };
})(PS["Data.Enum"] = PS["Data.Enum"] || {});
(function(exports) {
  "use strict";

  exports.topInt = 2147483647;
  exports.bottomInt = -2147483648;

  exports.topChar = String.fromCharCode(65535);
  exports.bottomChar = String.fromCharCode(0);
})(PS["Data.Bounded"] = PS["Data.Bounded"] || {});
(function(exports) {
  "use strict";

  var unsafeCompareImpl = function (lt) {
    return function (eq) {
      return function (gt) {
        return function (x) {
          return function (y) {
            return x < y ? lt : x === y ? eq : gt;
          };
        };
      };
    };
  };                                         
  exports.ordIntImpl = unsafeCompareImpl;   
  exports.ordStringImpl = unsafeCompareImpl;
  exports.ordCharImpl = unsafeCompareImpl;
})(PS["Data.Ord"] = PS["Data.Ord"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Ordering"] = $PS["Data.Ordering"] || {};
  var exports = $PS["Data.Ordering"];              
  var LT = (function () {
      function LT() {

      };
      LT.value = new LT();
      return LT;
  })();
  var GT = (function () {
      function GT() {

      };
      GT.value = new GT();
      return GT;
  })();
  var EQ = (function () {
      function EQ() {

      };
      EQ.value = new EQ();
      return EQ;
  })();
  exports["LT"] = LT;
  exports["GT"] = GT;
  exports["EQ"] = EQ;
})(PS);
(function(exports) {
  "use strict";

  exports.intSub = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x - y | 0;
    };
  };
})(PS["Data.Ring"] = PS["Data.Ring"] || {});
(function(exports) {
  "use strict";

  exports.intAdd = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x + y | 0;
    };
  };

  exports.intMul = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x * y | 0;
    };
  };
})(PS["Data.Semiring"] = PS["Data.Semiring"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Semiring"] = $PS["Data.Semiring"] || {};
  var exports = $PS["Data.Semiring"];
  var $foreign = $PS["Data.Semiring"];
  var Semiring = function (add, mul, one, zero) {
      this.add = add;
      this.mul = mul;
      this.one = one;
      this.zero = zero;
  };
  var zero = function (dict) {
      return dict.zero;
  };                                                                            
  var semiringInt = new Semiring($foreign.intAdd, $foreign.intMul, 1, 0);
  var one = function (dict) {
      return dict.one;
  };
  var mul = function (dict) {
      return dict.mul;
  };
  var add = function (dict) {
      return dict.add;
  };
  exports["Semiring"] = Semiring;
  exports["add"] = add;
  exports["zero"] = zero;
  exports["mul"] = mul;
  exports["one"] = one;
  exports["semiringInt"] = semiringInt;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Ring"] = $PS["Data.Ring"] || {};
  var exports = $PS["Data.Ring"];
  var $foreign = $PS["Data.Ring"];
  var Data_Semiring = $PS["Data.Semiring"];
  var Ring = function (Semiring0, sub) {
      this.Semiring0 = Semiring0;
      this.sub = sub;
  };
  var sub = function (dict) {
      return dict.sub;
  };                  
  var ringInt = new Ring(function () {
      return Data_Semiring.semiringInt;
  }, $foreign.intSub);
  var negate = function (dictRing) {
      return function (a) {
          return sub(dictRing)(Data_Semiring.zero(dictRing.Semiring0()))(a);
      };
  };
  exports["Ring"] = Ring;
  exports["sub"] = sub;
  exports["negate"] = negate;
  exports["ringInt"] = ringInt;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Ord"] = $PS["Data.Ord"] || {};
  var exports = $PS["Data.Ord"];
  var $foreign = $PS["Data.Ord"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Data_Ring = $PS["Data.Ring"];
  var Data_Semiring = $PS["Data.Semiring"];
  var Ord = function (Eq0, compare) {
      this.Eq0 = Eq0;
      this.compare = compare;
  }; 
  var ordString = new Ord(function () {
      return Data_Eq.eqString;
  }, $foreign.ordStringImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value));
  var ordInt = new Ord(function () {
      return Data_Eq.eqInt;
  }, $foreign.ordIntImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value));
  var ordChar = new Ord(function () {
      return Data_Eq.eqChar;
  }, $foreign.ordCharImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value));
  var compare = function (dict) {
      return dict.compare;
  };
  var greaterThanOrEq = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var v = compare(dictOrd)(a1)(a2);
              if (v instanceof Data_Ordering.LT) {
                  return false;
              };
              return true;
          };
      };
  };
  var signum = function (dictOrd) {
      return function (dictRing) {
          return function (x) {
              var $43 = greaterThanOrEq(dictOrd)(x)(Data_Semiring.zero(dictRing.Semiring0()));
              if ($43) {
                  return Data_Semiring.one(dictRing.Semiring0());
              };
              return Data_Ring.negate(dictRing)(Data_Semiring.one(dictRing.Semiring0()));
          };
      };
  };
  var abs = function (dictOrd) {
      return function (dictRing) {
          return function (x) {
              var $53 = greaterThanOrEq(dictOrd)(x)(Data_Semiring.zero(dictRing.Semiring0()));
              if ($53) {
                  return x;
              };
              return Data_Ring.negate(dictRing)(x);
          };
      };
  };
  exports["Ord"] = Ord;
  exports["compare"] = compare;
  exports["abs"] = abs;
  exports["signum"] = signum;
  exports["ordInt"] = ordInt;
  exports["ordString"] = ordString;
  exports["ordChar"] = ordChar;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Bounded"] = $PS["Data.Bounded"] || {};
  var exports = $PS["Data.Bounded"];
  var $foreign = $PS["Data.Bounded"];
  var Data_Ord = $PS["Data.Ord"];                  
  var Bounded = function (Ord0, bottom, top) {
      this.Ord0 = Ord0;
      this.bottom = bottom;
      this.top = top;
  };
  var top = function (dict) {
      return dict.top;
  };                                            
  var boundedInt = new Bounded(function () {
      return Data_Ord.ordInt;
  }, $foreign.bottomInt, $foreign.topInt);
  var boundedChar = new Bounded(function () {
      return Data_Ord.ordChar;
  }, $foreign.bottomChar, $foreign.topChar);
  var bottom = function (dict) {
      return dict.bottom;
  };
  exports["bottom"] = bottom;
  exports["top"] = top;
  exports["boundedInt"] = boundedInt;
  exports["boundedChar"] = boundedChar;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Enum"] = $PS["Data.Enum"] || {};
  var exports = $PS["Data.Enum"];
  var $foreign = $PS["Data.Enum"];
  var Data_Bounded = $PS["Data.Bounded"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Enum = function (Ord0, pred, succ) {
      this.Ord0 = Ord0;
      this.pred = pred;
      this.succ = succ;
  };
  var BoundedEnum = function (Bounded0, Enum1, cardinality, fromEnum, toEnum) {
      this.Bounded0 = Bounded0;
      this.Enum1 = Enum1;
      this.cardinality = cardinality;
      this.fromEnum = fromEnum;
      this.toEnum = toEnum;
  };
  var toEnum = function (dict) {
      return dict.toEnum;
  };
  var succ = function (dict) {
      return dict.succ;
  }; 
  var pred = function (dict) {
      return dict.pred;
  };              
  var fromEnum = function (dict) {
      return dict.fromEnum;
  };
  var toEnumWithDefaults = function (dictBoundedEnum) {
      return function (low) {
          return function (high) {
              return function (x) {
                  var v = toEnum(dictBoundedEnum)(x);
                  if (v instanceof Data_Maybe.Just) {
                      return v.value0;
                  };
                  if (v instanceof Data_Maybe.Nothing) {
                      var $54 = x < fromEnum(dictBoundedEnum)(Data_Bounded.bottom(dictBoundedEnum.Bounded0()));
                      if ($54) {
                          return low;
                      };
                      return high;
                  };
                  throw new Error("Failed pattern match at Data.Enum (line 158, column 33 - line 160, column 62): " + [ v.constructor.name ]);
              };
          };
      };
  };
  var defaultSucc = function (toEnum$prime) {
      return function (fromEnum$prime) {
          return function (a) {
              return toEnum$prime(fromEnum$prime(a) + 1 | 0);
          };
      };
  };
  var defaultPred = function (toEnum$prime) {
      return function (fromEnum$prime) {
          return function (a) {
              return toEnum$prime(fromEnum$prime(a) - 1 | 0);
          };
      };
  };
  var charToEnum = function (v) {
      if (v >= Data_Bounded.bottom(Data_Bounded.boundedInt) && v <= Data_Bounded.top(Data_Bounded.boundedInt)) {
          return new Data_Maybe.Just($foreign.fromCharCode(v));
      };
      return Data_Maybe.Nothing.value;
  };
  var enumChar = new Enum(function () {
      return Data_Ord.ordChar;
  }, defaultPred(charToEnum)($foreign.toCharCode), defaultSucc(charToEnum)($foreign.toCharCode));
  var boundedEnumChar = new BoundedEnum(function () {
      return Data_Bounded.boundedChar;
  }, function () {
      return enumChar;
  }, $foreign.toCharCode(Data_Bounded.top(Data_Bounded.boundedChar)) - $foreign.toCharCode(Data_Bounded.bottom(Data_Bounded.boundedChar)) | 0, $foreign.toCharCode, charToEnum);
  exports["Enum"] = Enum;
  exports["succ"] = succ;
  exports["pred"] = pred;
  exports["fromEnum"] = fromEnum;
  exports["toEnumWithDefaults"] = toEnumWithDefaults;
  exports["boundedEnumChar"] = boundedEnumChar;
})(PS);
(function(exports) {
  "use strict";

  exports.showIntImpl = function (n) {
    return n.toString();
  };

  exports.showCharImpl = function (c) {
    var code = c.charCodeAt(0);
    if (code < 0x20 || code === 0x7F) {
      switch (c) {
        case "\x07": return "'\\a'";
        case "\b": return "'\\b'";
        case "\f": return "'\\f'";
        case "\n": return "'\\n'";
        case "\r": return "'\\r'";
        case "\t": return "'\\t'";
        case "\v": return "'\\v'";
      }
      return "'\\" + code.toString(10) + "'";
    }
    return c === "'" || c === "\\" ? "'\\" + c + "'" : "'" + c + "'";
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Show"] = $PS["Data.Show"] || {};
  var exports = $PS["Data.Show"];
  var $foreign = $PS["Data.Show"];
  var Show = function (show) {
      this.show = show;
  };                                                 
  var showInt = new Show($foreign.showIntImpl);
  var showChar = new Show($foreign.showCharImpl);
  var show = function (dict) {
      return dict.show;
  };
  exports["Show"] = Show;
  exports["show"] = show;
  exports["showInt"] = showInt;
  exports["showChar"] = showChar;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Abc"] = $PS["Data.Abc"] || {};
  var exports = $PS["Data.Abc"];
  var Data_Enum = $PS["Data.Enum"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Data_Show = $PS["Data.Show"];                    
  var Thin = (function () {
      function Thin() {

      };
      Thin.value = new Thin();
      return Thin;
  })();
  var ThinThin = (function () {
      function ThinThin() {

      };
      ThinThin.value = new ThinThin();
      return ThinThin;
  })();
  var ThinThick = (function () {
      function ThinThick() {

      };
      ThinThick.value = new ThinThick();
      return ThinThick;
  })();
  var ThickThin = (function () {
      function ThickThin() {

      };
      ThickThin.value = new ThickThin();
      return ThickThin;
  })();
  var Invisible = (function () {
      function Invisible() {

      };
      Invisible.value = new Invisible();
      return Invisible;
  })();
  var Begin = (function () {
      function Begin() {

      };
      Begin.value = new Begin();
      return Begin;
  })();
  var End = (function () {
      function End() {

      };
      End.value = new End();
      return End;
  })();
  var BeginAndEnd = (function () {
      function BeginAndEnd() {

      };
      BeginAndEnd.value = new BeginAndEnd();
      return BeginAndEnd;
  })();
  var A = (function () {
      function A() {

      };
      A.value = new A();
      return A;
  })();
  var B = (function () {
      function B() {

      };
      B.value = new B();
      return B;
  })();
  var C = (function () {
      function C() {

      };
      C.value = new C();
      return C;
  })();
  var D = (function () {
      function D() {

      };
      D.value = new D();
      return D;
  })();
  var E = (function () {
      function E() {

      };
      E.value = new E();
      return E;
  })();
  var F = (function () {
      function F() {

      };
      F.value = new F();
      return F;
  })();
  var G = (function () {
      function G() {

      };
      G.value = new G();
      return G;
  })();
  var Major = (function () {
      function Major() {

      };
      Major.value = new Major();
      return Major;
  })();
  var Minor = (function () {
      function Minor() {

      };
      Minor.value = new Minor();
      return Minor;
  })();
  var Ionian = (function () {
      function Ionian() {

      };
      Ionian.value = new Ionian();
      return Ionian;
  })();
  var Dorian = (function () {
      function Dorian() {

      };
      Dorian.value = new Dorian();
      return Dorian;
  })();
  var Phrygian = (function () {
      function Phrygian() {

      };
      Phrygian.value = new Phrygian();
      return Phrygian;
  })();
  var Lydian = (function () {
      function Lydian() {

      };
      Lydian.value = new Lydian();
      return Lydian;
  })();
  var Mixolydian = (function () {
      function Mixolydian() {

      };
      Mixolydian.value = new Mixolydian();
      return Mixolydian;
  })();
  var Aeolian = (function () {
      function Aeolian() {

      };
      Aeolian.value = new Aeolian();
      return Aeolian;
  })();
  var Locrian = (function () {
      function Locrian() {

      };
      Locrian.value = new Locrian();
      return Locrian;
  })();
  var LeftArrow = (function () {
      function LeftArrow(value0) {
          this.value0 = value0;
      };
      LeftArrow.create = function (value0) {
          return new LeftArrow(value0);
      };
      return LeftArrow;
  })();
  var RightArrow = (function () {
      function RightArrow(value0) {
          this.value0 = value0;
      };
      RightArrow.create = function (value0) {
          return new RightArrow(value0);
      };
      return RightArrow;
  })();
  var AboveNextSymbol = (function () {
      function AboveNextSymbol() {

      };
      AboveNextSymbol.value = new AboveNextSymbol();
      return AboveNextSymbol;
  })();
  var BelowNextSymbol = (function () {
      function BelowNextSymbol() {

      };
      BelowNextSymbol.value = new BelowNextSymbol();
      return BelowNextSymbol;
  })();
  var LeftOfNextSymbol = (function () {
      function LeftOfNextSymbol() {

      };
      LeftOfNextSymbol.value = new LeftOfNextSymbol();
      return LeftOfNextSymbol;
  })();
  var RightOfNextSymbol = (function () {
      function RightOfNextSymbol() {

      };
      RightOfNextSymbol.value = new RightOfNextSymbol();
      return RightOfNextSymbol;
  })();
  var Discretional = (function () {
      function Discretional() {

      };
      Discretional.value = new Discretional();
      return Discretional;
  })();
  var Sharp = (function () {
      function Sharp() {

      };
      Sharp.value = new Sharp();
      return Sharp;
  })();
  var Flat = (function () {
      function Flat() {

      };
      Flat.value = new Flat();
      return Flat;
  })();
  var DoubleSharp = (function () {
      function DoubleSharp() {

      };
      DoubleSharp.value = new DoubleSharp();
      return DoubleSharp;
  })();
  var DoubleFlat = (function () {
      function DoubleFlat() {

      };
      DoubleFlat.value = new DoubleFlat();
      return DoubleFlat;
  })();
  var Natural = (function () {
      function Natural() {

      };
      Natural.value = new Natural();
      return Natural;
  })();
  var Implicit = (function () {
      function Implicit() {

      };
      Implicit.value = new Implicit();
      return Implicit;
  })();
  var Pitch = (function () {
      function Pitch(value0) {
          this.value0 = value0;
      };
      Pitch.create = function (value0) {
          return new Pitch(value0);
      };
      return Pitch;
  })();
  var Area = (function () {
      function Area(value0) {
          this.value0 = value0;
      };
      Area.create = function (value0) {
          return new Area(value0);
      };
      return Area;
  })();
  var Book = (function () {
      function Book(value0) {
          this.value0 = value0;
      };
      Book.create = function (value0) {
          return new Book(value0);
      };
      return Book;
  })();
  var Composer = (function () {
      function Composer(value0) {
          this.value0 = value0;
      };
      Composer.create = function (value0) {
          return new Composer(value0);
      };
      return Composer;
  })();
  var Discography = (function () {
      function Discography(value0) {
          this.value0 = value0;
      };
      Discography.create = function (value0) {
          return new Discography(value0);
      };
      return Discography;
  })();
  var FileUrl = (function () {
      function FileUrl(value0) {
          this.value0 = value0;
      };
      FileUrl.create = function (value0) {
          return new FileUrl(value0);
      };
      return FileUrl;
  })();
  var Group = (function () {
      function Group(value0) {
          this.value0 = value0;
      };
      Group.create = function (value0) {
          return new Group(value0);
      };
      return Group;
  })();
  var History = (function () {
      function History(value0) {
          this.value0 = value0;
      };
      History.create = function (value0) {
          return new History(value0);
      };
      return History;
  })();
  var Instruction = (function () {
      function Instruction(value0) {
          this.value0 = value0;
      };
      Instruction.create = function (value0) {
          return new Instruction(value0);
      };
      return Instruction;
  })();
  var Key = (function () {
      function Key(value0) {
          this.value0 = value0;
      };
      Key.create = function (value0) {
          return new Key(value0);
      };
      return Key;
  })();
  var UnitNoteLength = (function () {
      function UnitNoteLength(value0) {
          this.value0 = value0;
      };
      UnitNoteLength.create = function (value0) {
          return new UnitNoteLength(value0);
      };
      return UnitNoteLength;
  })();
  var Meter = (function () {
      function Meter(value0) {
          this.value0 = value0;
      };
      Meter.create = function (value0) {
          return new Meter(value0);
      };
      return Meter;
  })();
  var Macro = (function () {
      function Macro(value0) {
          this.value0 = value0;
      };
      Macro.create = function (value0) {
          return new Macro(value0);
      };
      return Macro;
  })();
  var Notes = (function () {
      function Notes(value0) {
          this.value0 = value0;
      };
      Notes.create = function (value0) {
          return new Notes(value0);
      };
      return Notes;
  })();
  var Origin = (function () {
      function Origin(value0) {
          this.value0 = value0;
      };
      Origin.create = function (value0) {
          return new Origin(value0);
      };
      return Origin;
  })();
  var Parts = (function () {
      function Parts(value0) {
          this.value0 = value0;
      };
      Parts.create = function (value0) {
          return new Parts(value0);
      };
      return Parts;
  })();
  var Tempo = (function () {
      function Tempo(value0) {
          this.value0 = value0;
      };
      Tempo.create = function (value0) {
          return new Tempo(value0);
      };
      return Tempo;
  })();
  var Rhythm = (function () {
      function Rhythm(value0) {
          this.value0 = value0;
      };
      Rhythm.create = function (value0) {
          return new Rhythm(value0);
      };
      return Rhythm;
  })();
  var Remark = (function () {
      function Remark(value0) {
          this.value0 = value0;
      };
      Remark.create = function (value0) {
          return new Remark(value0);
      };
      return Remark;
  })();
  var Source = (function () {
      function Source(value0) {
          this.value0 = value0;
      };
      Source.create = function (value0) {
          return new Source(value0);
      };
      return Source;
  })();
  var SymbolLine = (function () {
      function SymbolLine(value0) {
          this.value0 = value0;
      };
      SymbolLine.create = function (value0) {
          return new SymbolLine(value0);
      };
      return SymbolLine;
  })();
  var Title = (function () {
      function Title(value0) {
          this.value0 = value0;
      };
      Title.create = function (value0) {
          return new Title(value0);
      };
      return Title;
  })();
  var UserDefined = (function () {
      function UserDefined(value0) {
          this.value0 = value0;
      };
      UserDefined.create = function (value0) {
          return new UserDefined(value0);
      };
      return UserDefined;
  })();
  var Voice = (function () {
      function Voice(value0) {
          this.value0 = value0;
      };
      Voice.create = function (value0) {
          return new Voice(value0);
      };
      return Voice;
  })();
  var WordsAfter = (function () {
      function WordsAfter(value0) {
          this.value0 = value0;
      };
      WordsAfter.create = function (value0) {
          return new WordsAfter(value0);
      };
      return WordsAfter;
  })();
  var WordsAligned = (function () {
      function WordsAligned(value0) {
          this.value0 = value0;
      };
      WordsAligned.create = function (value0) {
          return new WordsAligned(value0);
      };
      return WordsAligned;
  })();
  var ReferenceNumber = (function () {
      function ReferenceNumber(value0) {
          this.value0 = value0;
      };
      ReferenceNumber.create = function (value0) {
          return new ReferenceNumber(value0);
      };
      return ReferenceNumber;
  })();
  var Transcription = (function () {
      function Transcription(value0) {
          this.value0 = value0;
      };
      Transcription.create = function (value0) {
          return new Transcription(value0);
      };
      return Transcription;
  })();
  var FieldContinuation = (function () {
      function FieldContinuation(value0) {
          this.value0 = value0;
      };
      FieldContinuation.create = function (value0) {
          return new FieldContinuation(value0);
      };
      return FieldContinuation;
  })();
  var Comment = (function () {
      function Comment(value0) {
          this.value0 = value0;
      };
      Comment.create = function (value0) {
          return new Comment(value0);
      };
      return Comment;
  })();
  var UnsupportedHeader = (function () {
      function UnsupportedHeader() {

      };
      UnsupportedHeader.value = new UnsupportedHeader();
      return UnsupportedHeader;
  })();
  var Note = (function () {
      function Note(value0) {
          this.value0 = value0;
      };
      Note.create = function (value0) {
          return new Note(value0);
      };
      return Note;
  })();
  var BrokenRhythmPair = (function () {
      function BrokenRhythmPair(value0, value1, value2) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
      };
      BrokenRhythmPair.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return new BrokenRhythmPair(value0, value1, value2);
              };
          };
      };
      return BrokenRhythmPair;
  })();
  var Rest = (function () {
      function Rest(value0) {
          this.value0 = value0;
      };
      Rest.create = function (value0) {
          return new Rest(value0);
      };
      return Rest;
  })();
  var Tuplet = (function () {
      function Tuplet(value0, value1, value2) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
      };
      Tuplet.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return new Tuplet(value0, value1, value2);
              };
          };
      };
      return Tuplet;
  })();
  var DecoratedSpace = (function () {
      function DecoratedSpace(value0) {
          this.value0 = value0;
      };
      DecoratedSpace.create = function (value0) {
          return new DecoratedSpace(value0);
      };
      return DecoratedSpace;
  })();
  var Annotation = (function () {
      function Annotation(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Annotation.create = function (value0) {
          return function (value1) {
              return new Annotation(value0, value1);
          };
      };
      return Annotation;
  })();
  var ChordSymbol = (function () {
      function ChordSymbol(value0) {
          this.value0 = value0;
      };
      ChordSymbol.create = function (value0) {
          return new ChordSymbol(value0);
      };
      return ChordSymbol;
  })();
  var Chord = (function () {
      function Chord(value0) {
          this.value0 = value0;
      };
      Chord.create = function (value0) {
          return new Chord(value0);
      };
      return Chord;
  })();
  var Inline = (function () {
      function Inline(value0) {
          this.value0 = value0;
      };
      Inline.create = function (value0) {
          return new Inline(value0);
      };
      return Inline;
  })();
  var Spacer = (function () {
      function Spacer(value0) {
          this.value0 = value0;
      };
      Spacer.create = function (value0) {
          return new Spacer(value0);
      };
      return Spacer;
  })();
  var Ignore = (function () {
      function Ignore() {

      };
      Ignore.value = new Ignore();
      return Ignore;
  })();
  var Continuation = (function () {
      function Continuation(value0) {
          this.value0 = value0;
      };
      Continuation.create = function (value0) {
          return new Continuation(value0);
      };
      return Continuation;
  })();
  var Score = (function () {
      function Score(value0) {
          this.value0 = value0;
      };
      Score.create = function (value0) {
          return new Score(value0);
      };
      return Score;
  })();
  var BodyInfo = (function () {
      function BodyInfo(value0) {
          this.value0 = value0;
      };
      BodyInfo.create = function (value0) {
          return new BodyInfo(value0);
      };
      return BodyInfo;
  })();
  var showPitchClass = new Data_Show.Show(function (v) {
      if (v instanceof A) {
          return "A";
      };
      if (v instanceof B) {
          return "B";
      };
      if (v instanceof C) {
          return "C";
      };
      if (v instanceof D) {
          return "D";
      };
      if (v instanceof E) {
          return "E";
      };
      if (v instanceof F) {
          return "F";
      };
      if (v instanceof G) {
          return "G";
      };
      throw new Error("Failed pattern match at Data.Abc (line 250, column 1 - line 257, column 15): " + [ v.constructor.name ]);
  });
  var middlecOctave = 5;
  var eqThickness = new Data_Eq.Eq(function (x) {
      return function (y) {
          if (x instanceof Thin && y instanceof Thin) {
              return true;
          };
          if (x instanceof ThinThin && y instanceof ThinThin) {
              return true;
          };
          if (x instanceof ThinThick && y instanceof ThinThick) {
              return true;
          };
          if (x instanceof ThickThin && y instanceof ThickThin) {
              return true;
          };
          if (x instanceof Invisible && y instanceof Invisible) {
              return true;
          };
          return false;
      };
  });
  var eqRepeat = new Data_Eq.Eq(function (x) {
      return function (y) {
          if (x instanceof Begin && y instanceof Begin) {
              return true;
          };
          if (x instanceof End && y instanceof End) {
              return true;
          };
          if (x instanceof BeginAndEnd && y instanceof BeginAndEnd) {
              return true;
          };
          return false;
      };
  });
  var eqPitchCLass = new Data_Eq.Eq(function (x) {
      return function (y) {
          if (x instanceof A && y instanceof A) {
              return true;
          };
          if (x instanceof B && y instanceof B) {
              return true;
          };
          if (x instanceof C && y instanceof C) {
              return true;
          };
          if (x instanceof D && y instanceof D) {
              return true;
          };
          if (x instanceof E && y instanceof E) {
              return true;
          };
          if (x instanceof F && y instanceof F) {
              return true;
          };
          if (x instanceof G && y instanceof G) {
              return true;
          };
          return false;
      };
  });
  var ordPitchCLass = new Data_Ord.Ord(function () {
      return eqPitchCLass;
  }, function (x) {
      return function (y) {
          if (x instanceof A && y instanceof A) {
              return Data_Ordering.EQ.value;
          };
          if (x instanceof A) {
              return Data_Ordering.LT.value;
          };
          if (y instanceof A) {
              return Data_Ordering.GT.value;
          };
          if (x instanceof B && y instanceof B) {
              return Data_Ordering.EQ.value;
          };
          if (x instanceof B) {
              return Data_Ordering.LT.value;
          };
          if (y instanceof B) {
              return Data_Ordering.GT.value;
          };
          if (x instanceof C && y instanceof C) {
              return Data_Ordering.EQ.value;
          };
          if (x instanceof C) {
              return Data_Ordering.LT.value;
          };
          if (y instanceof C) {
              return Data_Ordering.GT.value;
          };
          if (x instanceof D && y instanceof D) {
              return Data_Ordering.EQ.value;
          };
          if (x instanceof D) {
              return Data_Ordering.LT.value;
          };
          if (y instanceof D) {
              return Data_Ordering.GT.value;
          };
          if (x instanceof E && y instanceof E) {
              return Data_Ordering.EQ.value;
          };
          if (x instanceof E) {
              return Data_Ordering.LT.value;
          };
          if (y instanceof E) {
              return Data_Ordering.GT.value;
          };
          if (x instanceof F && y instanceof F) {
              return Data_Ordering.EQ.value;
          };
          if (x instanceof F) {
              return Data_Ordering.LT.value;
          };
          if (y instanceof F) {
              return Data_Ordering.GT.value;
          };
          if (x instanceof G && y instanceof G) {
              return Data_Ordering.EQ.value;
          };
          throw new Error("Failed pattern match at Data.Abc (line 260, column 1 - line 260, column 48): " + [ x.constructor.name, y.constructor.name ]);
      };
  });
  var eqMode = new Data_Eq.Eq(function (x) {
      return function (y) {
          if (x instanceof Major && y instanceof Major) {
              return true;
          };
          if (x instanceof Minor && y instanceof Minor) {
              return true;
          };
          if (x instanceof Ionian && y instanceof Ionian) {
              return true;
          };
          if (x instanceof Dorian && y instanceof Dorian) {
              return true;
          };
          if (x instanceof Phrygian && y instanceof Phrygian) {
              return true;
          };
          if (x instanceof Lydian && y instanceof Lydian) {
              return true;
          };
          if (x instanceof Mixolydian && y instanceof Mixolydian) {
              return true;
          };
          if (x instanceof Aeolian && y instanceof Aeolian) {
              return true;
          };
          if (x instanceof Locrian && y instanceof Locrian) {
              return true;
          };
          return false;
      };
  });
  var eqAccidental = new Data_Eq.Eq(function (x) {
      return function (y) {
          if (x instanceof Sharp && y instanceof Sharp) {
              return true;
          };
          if (x instanceof Flat && y instanceof Flat) {
              return true;
          };
          if (x instanceof DoubleSharp && y instanceof DoubleSharp) {
              return true;
          };
          if (x instanceof DoubleFlat && y instanceof DoubleFlat) {
              return true;
          };
          if (x instanceof Natural && y instanceof Natural) {
              return true;
          };
          if (x instanceof Implicit && y instanceof Implicit) {
              return true;
          };
          return false;
      };
  });
  var enumPitchClass = new Data_Enum.Enum(function () {
      return ordPitchCLass;
  }, function (v) {
      if (v instanceof C) {
          return new Data_Maybe.Just(B.value);
      };
      if (v instanceof D) {
          return new Data_Maybe.Just(C.value);
      };
      if (v instanceof E) {
          return new Data_Maybe.Just(D.value);
      };
      if (v instanceof F) {
          return new Data_Maybe.Just(E.value);
      };
      if (v instanceof G) {
          return new Data_Maybe.Just(F.value);
      };
      if (v instanceof A) {
          return new Data_Maybe.Just(G.value);
      };
      if (v instanceof B) {
          return new Data_Maybe.Just(A.value);
      };
      throw new Error("Failed pattern match at Data.Abc (line 262, column 1 - line 278, column 18): " + [ v.constructor.name ]);
  }, function (v) {
      if (v instanceof C) {
          return new Data_Maybe.Just(D.value);
      };
      if (v instanceof D) {
          return new Data_Maybe.Just(E.value);
      };
      if (v instanceof E) {
          return new Data_Maybe.Just(F.value);
      };
      if (v instanceof F) {
          return new Data_Maybe.Just(G.value);
      };
      if (v instanceof G) {
          return new Data_Maybe.Just(A.value);
      };
      if (v instanceof A) {
          return new Data_Maybe.Just(B.value);
      };
      if (v instanceof B) {
          return new Data_Maybe.Just(C.value);
      };
      throw new Error("Failed pattern match at Data.Abc (line 262, column 1 - line 278, column 18): " + [ v.constructor.name ]);
  });
  exports["Score"] = Score;
  exports["BodyInfo"] = BodyInfo;
  exports["Area"] = Area;
  exports["Book"] = Book;
  exports["Composer"] = Composer;
  exports["Discography"] = Discography;
  exports["FileUrl"] = FileUrl;
  exports["Group"] = Group;
  exports["History"] = History;
  exports["Instruction"] = Instruction;
  exports["Key"] = Key;
  exports["UnitNoteLength"] = UnitNoteLength;
  exports["Meter"] = Meter;
  exports["Macro"] = Macro;
  exports["Notes"] = Notes;
  exports["Origin"] = Origin;
  exports["Parts"] = Parts;
  exports["Tempo"] = Tempo;
  exports["Rhythm"] = Rhythm;
  exports["Remark"] = Remark;
  exports["Source"] = Source;
  exports["SymbolLine"] = SymbolLine;
  exports["Title"] = Title;
  exports["UserDefined"] = UserDefined;
  exports["Voice"] = Voice;
  exports["WordsAfter"] = WordsAfter;
  exports["WordsAligned"] = WordsAligned;
  exports["ReferenceNumber"] = ReferenceNumber;
  exports["Transcription"] = Transcription;
  exports["FieldContinuation"] = FieldContinuation;
  exports["Comment"] = Comment;
  exports["UnsupportedHeader"] = UnsupportedHeader;
  exports["Note"] = Note;
  exports["BrokenRhythmPair"] = BrokenRhythmPair;
  exports["Rest"] = Rest;
  exports["Tuplet"] = Tuplet;
  exports["DecoratedSpace"] = DecoratedSpace;
  exports["Annotation"] = Annotation;
  exports["ChordSymbol"] = ChordSymbol;
  exports["Chord"] = Chord;
  exports["Inline"] = Inline;
  exports["Spacer"] = Spacer;
  exports["Ignore"] = Ignore;
  exports["Continuation"] = Continuation;
  exports["Thin"] = Thin;
  exports["ThinThin"] = ThinThin;
  exports["ThinThick"] = ThinThick;
  exports["ThickThin"] = ThickThin;
  exports["Invisible"] = Invisible;
  exports["Begin"] = Begin;
  exports["End"] = End;
  exports["BeginAndEnd"] = BeginAndEnd;
  exports["Pitch"] = Pitch;
  exports["AboveNextSymbol"] = AboveNextSymbol;
  exports["BelowNextSymbol"] = BelowNextSymbol;
  exports["LeftOfNextSymbol"] = LeftOfNextSymbol;
  exports["RightOfNextSymbol"] = RightOfNextSymbol;
  exports["Discretional"] = Discretional;
  exports["Major"] = Major;
  exports["Minor"] = Minor;
  exports["Ionian"] = Ionian;
  exports["Dorian"] = Dorian;
  exports["Phrygian"] = Phrygian;
  exports["Lydian"] = Lydian;
  exports["Mixolydian"] = Mixolydian;
  exports["Aeolian"] = Aeolian;
  exports["Locrian"] = Locrian;
  exports["Sharp"] = Sharp;
  exports["Flat"] = Flat;
  exports["DoubleSharp"] = DoubleSharp;
  exports["DoubleFlat"] = DoubleFlat;
  exports["Natural"] = Natural;
  exports["Implicit"] = Implicit;
  exports["A"] = A;
  exports["B"] = B;
  exports["C"] = C;
  exports["D"] = D;
  exports["E"] = E;
  exports["F"] = F;
  exports["G"] = G;
  exports["LeftArrow"] = LeftArrow;
  exports["RightArrow"] = RightArrow;
  exports["middlecOctave"] = middlecOctave;
  exports["eqThickness"] = eqThickness;
  exports["eqRepeat"] = eqRepeat;
  exports["eqMode"] = eqMode;
  exports["eqAccidental"] = eqAccidental;
  exports["showPitchClass"] = showPitchClass;
  exports["eqPitchCLass"] = eqPitchCLass;
  exports["enumPitchClass"] = enumPitchClass;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Abc.Canonical"] = $PS["Data.Abc.Canonical"] || {};
  var exports = $PS["Data.Abc.Canonical"];
  var Data_Abc = $PS["Data.Abc"];
  var keySignatureAccidental = function (a) {
      if (a instanceof Data_Abc.Sharp) {
          return "#";
      };
      if (a instanceof Data_Abc.Flat) {
          return "b";
      };
      return "";
  };
  exports["keySignatureAccidental"] = keySignatureAccidental;
})(PS);
(function(exports) {
  "use strict";

  //------------------------------------------------------------------------------
  // Array creation --------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.range = function (start) {
    return function (end) {
      var step = start > end ? -1 : 1;
      var result = new Array(step * (end - start) + 1);
      var i = start, n = 0;
      while (i !== end) {
        result[n++] = i;
        i += step;
      }
      result[n] = i;
      return result;
    };
  };

  var replicateFill = function (count) {
    return function (value) {
      if (count < 1) {
        return [];
      }
      var result = new Array(count);
      return result.fill(value);
    };
  };

  var replicatePolyfill = function (count) {
    return function (value) {
      var result = [];
      var n = 0;
      for (var i = 0; i < count; i++) {
        result[n++] = value;
      }
      return result;
    };
  };

  // In browsers that have Array.prototype.fill we use it, as it's faster.
  exports.replicate = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;

  exports.fromFoldableImpl = (function () {
    function Cons(head, tail) {
      this.head = head;
      this.tail = tail;
    }
    var emptyList = {};

    function curryCons(head) {
      return function (tail) {
        return new Cons(head, tail);
      };
    }

    function listToArray(list) {
      var result = [];
      var count = 0;
      var xs = list;
      while (xs !== emptyList) {
        result[count++] = xs.head;
        xs = xs.tail;
      }
      return result;
    }

    return function (foldr) {
      return function (xs) {
        return listToArray(foldr(curryCons)(emptyList)(xs));
      };
    };
  })();

  //------------------------------------------------------------------------------
  // Array size ------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.length = function (xs) {
    return xs.length;
  };

  //------------------------------------------------------------------------------
  // Extending arrays ------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.cons = function (e) {
    return function (l) {
      return [e].concat(l);
    };
  };

  exports.snoc = function (l) {
    return function (e) {
      var l1 = l.slice();
      l1.push(e);
      return l1;
    };
  };

  //------------------------------------------------------------------------------
  // Indexed operations ----------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.indexImpl = function (just) {
    return function (nothing) {
      return function (xs) {
        return function (i) {
          return i < 0 || i >= xs.length ? nothing :  just(xs[i]);
        };
      };
    };
  };

  exports.findIndexImpl = function (just) {
    return function (nothing) {
      return function (f) {
        return function (xs) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (f(xs[i])) return just(i);
          }
          return nothing;
        };
      };
    };
  };

  //------------------------------------------------------------------------------
  // Transformations -------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.reverse = function (l) {
    return l.slice().reverse();
  };

  exports.filter = function (f) {
    return function (xs) {
      return xs.filter(f);
    };
  };

  //------------------------------------------------------------------------------
  // Subarrays -------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.slice = function (s) {
    return function (e) {
      return function (l) {
        return l.slice(s, e);
      };
    };
  };

  exports.take = function (n) {
    return function (l) {
      return n < 1 ? [] : l.slice(0, n);
    };
  };

  exports.drop = function (n) {
    return function (l) {
      return n < 1 ? l : l.slice(n);
    };
  };

  //------------------------------------------------------------------------------
  // Zipping ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.zipWith = function (f) {
    return function (xs) {
      return function (ys) {
        var l = xs.length < ys.length ? xs.length : ys.length;
        var result = new Array(l);
        for (var i = 0; i < l; i++) {
          result[i] = f(xs[i])(ys[i]);
        }
        return result;
      };
    };
  };

  //------------------------------------------------------------------------------
  // Partial ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.unsafeIndexImpl = function (xs) {
    return function (n) {
      return xs[n];
    };
  };
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
  "use strict";

  exports.empty = function () {
    return [];
  };

  exports.pushAll = function (as) {
    return function (xs) {
      return function () {
        return xs.push.apply(xs, as);
      };
    };
  };
})(PS["Data.Array.ST"] = PS["Data.Array.ST"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Array.ST"] = $PS["Data.Array.ST"] || {};
  var exports = $PS["Data.Array.ST"];
  var $foreign = $PS["Data.Array.ST"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Monad_ST_Internal = $PS["Control.Monad.ST.Internal"];
  var unsafeFreeze = (function () {
      var $13 = Control_Applicative.pure(Control_Monad_ST_Internal.applicativeST);
      return function ($14) {
          return $13($14);
      };
  })();
  var push = function (a) {
      return $foreign.pushAll([ a ]);
  };
  exports["push"] = push;
  exports["unsafeFreeze"] = unsafeFreeze;
  exports["empty"] = $foreign.empty;
})(PS);
(function(exports) {
  "use strict";

  exports.boolConj = function (b1) {
    return function (b2) {
      return b1 && b2;
    };
  };

  exports.boolDisj = function (b1) {
    return function (b2) {
      return b1 || b2;
    };
  };

  exports.boolNot = function (b) {
    return !b;
  };
})(PS["Data.HeytingAlgebra"] = PS["Data.HeytingAlgebra"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.HeytingAlgebra"] = $PS["Data.HeytingAlgebra"] || {};
  var exports = $PS["Data.HeytingAlgebra"];
  var $foreign = $PS["Data.HeytingAlgebra"];
  var HeytingAlgebra = function (conj, disj, ff, implies, not, tt) {
      this.conj = conj;
      this.disj = disj;
      this.ff = ff;
      this.implies = implies;
      this.not = not;
      this.tt = tt;
  };
  var tt = function (dict) {
      return dict.tt;
  };
  var not = function (dict) {
      return dict.not;
  };
  var ff = function (dict) {
      return dict.ff;
  };
  var disj = function (dict) {
      return dict.disj;
  };
  var heytingAlgebraBoolean = new HeytingAlgebra($foreign.boolConj, $foreign.boolDisj, false, function (a) {
      return function (b) {
          return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);
      };
  }, $foreign.boolNot, true);
  var conj = function (dict) {
      return dict.conj;
  };
  exports["tt"] = tt;
  exports["ff"] = ff;
  exports["conj"] = conj;
  exports["disj"] = disj;
  exports["not"] = not;
  exports["heytingAlgebraBoolean"] = heytingAlgebraBoolean;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Array.ST.Iterator"] = $PS["Data.Array.ST.Iterator"] || {};
  var exports = $PS["Data.Array.ST.Iterator"];
  var Control_Monad_ST_Internal = $PS["Control.Monad.ST.Internal"];
  var Data_Array_ST = $PS["Data.Array.ST"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_HeytingAlgebra = $PS["Data.HeytingAlgebra"];
  var Data_Maybe = $PS["Data.Maybe"];                
  var Iterator = (function () {
      function Iterator(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Iterator.create = function (value0) {
          return function (value1) {
              return new Iterator(value0, value1);
          };
      };
      return Iterator;
  })();
  var peek = function (v) {
      return function __do() {
          var v1 = Control_Monad_ST_Internal.read(v.value1)();
          return v.value0(v1);
      };
  };
  var next = function (v) {
      return function __do() {
          var v1 = Control_Monad_ST_Internal.read(v.value1)();
          var v2 = Control_Monad_ST_Internal.modify(function (v2) {
              return v2 + 1 | 0;
          })(v.value1)();
          return v.value0(v1);
      };
  };
  var pushWhile = function (p) {
      return function (iter) {
          return function (array) {
              return function __do() {
                  var v = Control_Monad_ST_Internal["new"](false)();
                  while (Data_Functor.map(Control_Monad_ST_Internal.functorST)(Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean))(Control_Monad_ST_Internal.read(v))()) {
                      (function __do() {
                          var v1 = peek(iter)();
                          if (v1 instanceof Data_Maybe.Just && p(v1.value0)) {
                              var v2 = Data_Array_ST.push(v1.value0)(array)();
                              return Data_Functor["void"](Control_Monad_ST_Internal.functorST)(next(iter))();
                          };
                          return Data_Functor["void"](Control_Monad_ST_Internal.functorST)(Control_Monad_ST_Internal.write(true)(v))();
                      })();
                  };
                  return {};
              };
          };
      };
  };                                                    
  var iterator = function (f) {
      return Data_Functor.map(Control_Monad_ST_Internal.functorST)(Iterator.create(f))(Control_Monad_ST_Internal["new"](0));
  };
  var iterate = function (iter) {
      return function (f) {
          return function __do() {
              var v = Control_Monad_ST_Internal["new"](false)();
              while (Data_Functor.map(Control_Monad_ST_Internal.functorST)(Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean))(Control_Monad_ST_Internal.read(v))()) {
                  (function __do() {
                      var v1 = next(iter)();
                      if (v1 instanceof Data_Maybe.Just) {
                          return f(v1.value0)();
                      };
                      if (v1 instanceof Data_Maybe.Nothing) {
                          return Data_Functor["void"](Control_Monad_ST_Internal.functorST)(Control_Monad_ST_Internal.write(true)(v))();
                      };
                      throw new Error("Failed pattern match at Data.Array.ST.Iterator (line 42, column 5 - line 44, column 47): " + [ v1.constructor.name ]);
                  })();
              };
              return {};
          };
      };
  };
  exports["iterator"] = iterator;
  exports["iterate"] = iterate;
  exports["pushWhile"] = pushWhile;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Boolean"] = $PS["Data.Boolean"] || {};
  var exports = $PS["Data.Boolean"];
  var otherwise = true;
  exports["otherwise"] = otherwise;
})(PS);
(function(exports) {
  "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
  "use strict";

  exports.concatString = function (s1) {
    return function (s2) {
      return s1 + s2;
    };
  };

  exports.concatArray = function (xs) {
    return function (ys) {
      if (xs.length === 0) return ys;
      if (ys.length === 0) return xs;
      return xs.concat(ys);
    };
  };
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Semigroup"] = $PS["Data.Semigroup"] || {};
  var exports = $PS["Data.Semigroup"];
  var $foreign = $PS["Data.Semigroup"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Record_Unsafe = $PS["Record.Unsafe"];
  var Type_Data_RowList = $PS["Type.Data.RowList"];                
  var SemigroupRecord = function (appendRecord) {
      this.appendRecord = appendRecord;
  };
  var Semigroup = function (append) {
      this.append = append;
  }; 
  var semigroupString = new Semigroup($foreign.concatString);
  var semigroupRecordNil = new SemigroupRecord(function (v) {
      return function (v1) {
          return function (v2) {
              return {};
          };
      };
  });
  var semigroupArray = new Semigroup($foreign.concatArray);
  var appendRecord = function (dict) {
      return dict.appendRecord;
  };
  var semigroupRecord = function (dictRowToList) {
      return function (dictSemigroupRecord) {
          return new Semigroup(appendRecord(dictSemigroupRecord)(Type_Data_RowList.RLProxy.value));
      };
  };
  var append = function (dict) {
      return dict.append;
  };
  var semigroupRecordCons = function (dictIsSymbol) {
      return function (dictCons) {
          return function (dictSemigroupRecord) {
              return function (dictSemigroup) {
                  return new SemigroupRecord(function (v) {
                      return function (ra) {
                          return function (rb) {
                              var tail = appendRecord(dictSemigroupRecord)(Type_Data_RowList.RLProxy.value)(ra)(rb);
                              var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Data_Symbol.SProxy.value);
                              var insert = Record_Unsafe.unsafeSet(key);
                              var get = Record_Unsafe.unsafeGet(key);
                              return insert(append(dictSemigroup)(get(ra))(get(rb)))(tail);
                          };
                      };
                  });
              };
          };
      };
  };
  exports["Semigroup"] = Semigroup;
  exports["append"] = append;
  exports["semigroupString"] = semigroupString;
  exports["semigroupArray"] = semigroupArray;
  exports["semigroupRecord"] = semigroupRecord;
  exports["semigroupRecordNil"] = semigroupRecordNil;
  exports["semigroupRecordCons"] = semigroupRecordCons;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Monoid"] = $PS["Data.Monoid"] || {};
  var exports = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Monoid = function (Semigroup0, mempty) {
      this.Semigroup0 = Semigroup0;
      this.mempty = mempty;
  };                 
  var monoidString = new Monoid(function () {
      return Data_Semigroup.semigroupString;
  }, "");                    
  var monoidArray = new Monoid(function () {
      return Data_Semigroup.semigroupArray;
  }, [  ]);
  var mempty = function (dict) {
      return dict.mempty;
  };
  exports["Monoid"] = Monoid;
  exports["mempty"] = mempty;
  exports["monoidString"] = monoidString;
  exports["monoidArray"] = monoidArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Monoid.Conj"] = $PS["Data.Monoid.Conj"] || {};
  var exports = $PS["Data.Monoid.Conj"];
  var Data_HeytingAlgebra = $PS["Data.HeytingAlgebra"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];      
  var Conj = function (x) {
      return x;
  };
  var semigroupConj = function (dictHeytingAlgebra) {
      return new Data_Semigroup.Semigroup(function (v) {
          return function (v1) {
              return Data_HeytingAlgebra.conj(dictHeytingAlgebra)(v)(v1);
          };
      });
  };
  var monoidConj = function (dictHeytingAlgebra) {
      return new Data_Monoid.Monoid(function () {
          return semigroupConj(dictHeytingAlgebra);
      }, Data_HeytingAlgebra.tt(dictHeytingAlgebra));
  };
  exports["Conj"] = Conj;
  exports["monoidConj"] = monoidConj;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Monoid.Disj"] = $PS["Data.Monoid.Disj"] || {};
  var exports = $PS["Data.Monoid.Disj"];
  var Data_HeytingAlgebra = $PS["Data.HeytingAlgebra"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];      
  var Disj = function (x) {
      return x;
  };
  var semigroupDisj = function (dictHeytingAlgebra) {
      return new Data_Semigroup.Semigroup(function (v) {
          return function (v1) {
              return Data_HeytingAlgebra.disj(dictHeytingAlgebra)(v)(v1);
          };
      });
  };
  var monoidDisj = function (dictHeytingAlgebra) {
      return new Data_Monoid.Monoid(function () {
          return semigroupDisj(dictHeytingAlgebra);
      }, Data_HeytingAlgebra.ff(dictHeytingAlgebra));
  };
  exports["Disj"] = Disj;
  exports["monoidDisj"] = monoidDisj;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Newtype"] = $PS["Data.Newtype"] || {};
  var exports = $PS["Data.Newtype"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Monoid_Conj = $PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = $PS["Data.Monoid.Disj"];                      
  var Newtype = function (unwrap, wrap) {
      this.unwrap = unwrap;
      this.wrap = wrap;
  };
  var wrap = function (dict) {
      return dict.wrap;
  };
  var unwrap = function (dict) {
      return dict.unwrap;
  };                        
  var newtypeDisj = new Newtype(function (v) {
      return v;
  }, Data_Monoid_Disj.Disj);
  var newtypeConj = new Newtype(function (v) {
      return v;
  }, Data_Monoid_Conj.Conj);
  var alaF = function (dictFunctor) {
      return function (dictFunctor1) {
          return function (dictNewtype) {
              return function (dictNewtype1) {
                  return function (v) {
                      return function (f) {
                          var $96 = Data_Functor.map(dictFunctor1)(unwrap(dictNewtype1));
                          var $97 = Data_Functor.map(dictFunctor)(wrap(dictNewtype));
                          return function ($98) {
                              return $96(f($97($98)));
                          };
                      };
                  };
              };
          };
      };
  };
  exports["unwrap"] = unwrap;
  exports["Newtype"] = Newtype;
  exports["alaF"] = alaF;
  exports["newtypeConj"] = newtypeConj;
  exports["newtypeDisj"] = newtypeDisj;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Foldable"] = $PS["Data.Foldable"] || {};
  var exports = $PS["Data.Foldable"];
  var $foreign = $PS["Data.Foldable"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_HeytingAlgebra = $PS["Data.HeytingAlgebra"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Monoid_Conj = $PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = $PS["Data.Monoid.Disj"];
  var Data_Newtype = $PS["Data.Newtype"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Unit = $PS["Data.Unit"];                
  var Foldable = function (foldMap, foldl, foldr) {
      this.foldMap = foldMap;
      this.foldl = foldl;
      this.foldr = foldr;
  };
  var foldr = function (dict) {
      return dict.foldr;
  };
  var traverse_ = function (dictApplicative) {
      return function (dictFoldable) {
          return function (f) {
              return foldr(dictFoldable)((function () {
                  var $197 = Control_Apply.applySecond(dictApplicative.Apply0());
                  return function ($198) {
                      return $197(f($198));
                  };
              })())(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
          };
      };
  };
  var foldl = function (dict) {
      return dict.foldl;
  }; 
  var foldMapDefaultR = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return foldr(dictFoldable)(function (x) {
                  return function (acc) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      };
  };
  var foldableArray = new Foldable(function (dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
  }, $foreign.foldlArray, $foreign.foldrArray);
  var foldMap = function (dict) {
      return dict.foldMap;
  };
  var foldM = function (dictFoldable) {
      return function (dictMonad) {
          return function (f) {
              return function (a0) {
                  return foldl(dictFoldable)(function (ma) {
                      return function (b) {
                          return Control_Bind.bind(dictMonad.Bind1())(ma)(Data_Function.flip(f)(b));
                      };
                  })(Control_Applicative.pure(dictMonad.Applicative0())(a0));
              };
          };
      };
  };
  var any = function (dictFoldable) {
      return function (dictHeytingAlgebra) {
          return Data_Newtype.alaF(Data_Functor.functorFn)(Data_Functor.functorFn)(Data_Newtype.newtypeDisj)(Data_Newtype.newtypeDisj)(Data_Monoid_Disj.Disj)(foldMap(dictFoldable)(Data_Monoid_Disj.monoidDisj(dictHeytingAlgebra)));
      };
  };
  var elem = function (dictFoldable) {
      return function (dictEq) {
          var $204 = any(dictFoldable)(Data_HeytingAlgebra.heytingAlgebraBoolean);
          var $205 = Data_Eq.eq(dictEq);
          return function ($206) {
              return $204($205($206));
          };
      };
  };
  var all = function (dictFoldable) {
      return function (dictHeytingAlgebra) {
          return Data_Newtype.alaF(Data_Functor.functorFn)(Data_Functor.functorFn)(Data_Newtype.newtypeConj)(Data_Newtype.newtypeConj)(Data_Monoid_Conj.Conj)(foldMap(dictFoldable)(Data_Monoid_Conj.monoidConj(dictHeytingAlgebra)));
      };
  };
  exports["Foldable"] = Foldable;
  exports["foldr"] = foldr;
  exports["foldl"] = foldl;
  exports["foldMap"] = foldMap;
  exports["foldM"] = foldM;
  exports["traverse_"] = traverse_;
  exports["all"] = all;
  exports["any"] = any;
  exports["elem"] = elem;
  exports["foldableArray"] = foldableArray;
})(PS);
(function(exports) {
  "use strict";

  exports.unfoldrArrayImpl = function (isNothing) {
    return function (fromJust) {
      return function (fst) {
        return function (snd) {
          return function (f) {
            return function (b) {
              var result = [];
              var value = b;
              while (true) { // eslint-disable-line no-constant-condition
                var maybe = f(value);
                if (isNothing(maybe)) return result;
                var tuple = fromJust(maybe);
                result.push(fst(tuple));
                value = snd(tuple);
              }
            };
          };
        };
      };
    };
  };
})(PS["Data.Unfoldable"] = PS["Data.Unfoldable"] || {});
(function(exports) {
  "use strict";

  exports.unfoldr1ArrayImpl = function (isNothing) {
    return function (fromJust) {
      return function (fst) {
        return function (snd) {
          return function (f) {
            return function (b) {
              var result = [];
              var value = b;
              while (true) { // eslint-disable-line no-constant-condition
                var tuple = f(value);
                result.push(fst(tuple));
                var maybe = snd(tuple);
                if (isNothing(maybe)) return result;
                value = fromJust(maybe);
              }
            };
          };
        };
      };
    };
  };
})(PS["Data.Unfoldable1"] = PS["Data.Unfoldable1"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Semigroup.Traversable"] = $PS["Data.Semigroup.Traversable"] || {};
  var exports = $PS["Data.Semigroup.Traversable"];               
  var Traversable1 = function (Foldable10, Traversable1, sequence1, traverse1) {
      this.Foldable10 = Foldable10;
      this.Traversable1 = Traversable1;
      this.sequence1 = sequence1;
      this.traverse1 = traverse1;
  };
  var traverse1 = function (dict) {
      return dict.traverse1;
  }; 
  var sequence1 = function (dict) {
      return dict.sequence1;
  };
  exports["sequence1"] = sequence1;
  exports["traverse1"] = traverse1;
  exports["Traversable1"] = Traversable1;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Unfoldable1"] = $PS["Data.Unfoldable1"] || {};
  var exports = $PS["Data.Unfoldable1"];
  var $foreign = $PS["Data.Unfoldable1"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Semigroup_Traversable = $PS["Data.Semigroup.Traversable"];
  var Data_Tuple = $PS["Data.Tuple"];                
  var Unfoldable1 = function (unfoldr1) {
      this.unfoldr1 = unfoldr1;
  };
  var unfoldr1 = function (dict) {
      return dict.unfoldr1;
  };
  var unfoldable1Array = new Unfoldable1($foreign.unfoldr1ArrayImpl(Data_Maybe.isNothing)(Data_Maybe.fromJust())(Data_Tuple.fst)(Data_Tuple.snd));
  var replicate1 = function (dictUnfoldable1) {
      return function (n) {
          return function (v) {
              var step = function (i) {
                  if (i <= 0) {
                      return new Data_Tuple.Tuple(v, Data_Maybe.Nothing.value);
                  };
                  if (Data_Boolean.otherwise) {
                      return new Data_Tuple.Tuple(v, new Data_Maybe.Just(i - 1 | 0));
                  };
                  throw new Error("Failed pattern match at Data.Unfoldable1 (line 64, column 5 - line 64, column 39): " + [ i.constructor.name ]);
              };
              return unfoldr1(dictUnfoldable1)(step)(n - 1 | 0);
          };
      };
  };
  var replicate1A = function (dictApply) {
      return function (dictUnfoldable1) {
          return function (dictTraversable1) {
              return function (n) {
                  return function (m) {
                      return Data_Semigroup_Traversable.sequence1(dictTraversable1)(dictApply)(replicate1(dictUnfoldable1)(n)(m));
                  };
              };
          };
      };
  };
  exports["Unfoldable1"] = Unfoldable1;
  exports["replicate1A"] = replicate1A;
  exports["unfoldable1Array"] = unfoldable1Array;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Unfoldable"] = $PS["Data.Unfoldable"] || {};
  var exports = $PS["Data.Unfoldable"];
  var $foreign = $PS["Data.Unfoldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable1 = $PS["Data.Unfoldable1"];  
  var Unfoldable = function (Unfoldable10, unfoldr) {
      this.Unfoldable10 = Unfoldable10;
      this.unfoldr = unfoldr;
  };
  var unfoldr = function (dict) {
      return dict.unfoldr;
  };
  var unfoldableArray = new Unfoldable(function () {
      return Data_Unfoldable1.unfoldable1Array;
  }, $foreign.unfoldrArrayImpl(Data_Maybe.isNothing)(Data_Maybe.fromJust())(Data_Tuple.fst)(Data_Tuple.snd));
  var replicate = function (dictUnfoldable) {
      return function (n) {
          return function (v) {
              var step = function (i) {
                  var $7 = i <= 0;
                  if ($7) {
                      return Data_Maybe.Nothing.value;
                  };
                  return new Data_Maybe.Just(new Data_Tuple.Tuple(v, i - 1 | 0));
              };
              return unfoldr(dictUnfoldable)(step)(n);
          };
      };
  };
  var fromMaybe = function (dictUnfoldable) {
      return unfoldr(dictUnfoldable)(function (b) {
          return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Function.flip(Data_Tuple.Tuple.create)(Data_Maybe.Nothing.value))(b);
      });
  };
  exports["Unfoldable"] = Unfoldable;
  exports["unfoldr"] = unfoldr;
  exports["replicate"] = replicate;
  exports["fromMaybe"] = fromMaybe;
  exports["unfoldableArray"] = unfoldableArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Array"] = $PS["Data.Array"] || {};
  var exports = $PS["Data.Array"];
  var $foreign = $PS["Data.Array"];
  var Control_Monad_ST_Internal = $PS["Control.Monad.ST.Internal"];
  var Data_Array_ST = $PS["Data.Array.ST"];
  var Data_Array_ST_Iterator = $PS["Data.Array.ST.Iterator"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];
  var zip = $foreign.zipWith(Data_Tuple.Tuple.create);                                   
  var unsafeIndex = function (dictPartial) {
      return $foreign.unsafeIndexImpl;
  }; 
  var toUnfoldable = function (dictUnfoldable) {
      return function (xs) {
          var len = $foreign.length(xs);
          var f = function (i) {
              if (i < len) {
                  return new Data_Maybe.Just(new Data_Tuple.Tuple(unsafeIndex()(xs)(i), i + 1 | 0));
              };
              if (Data_Boolean.otherwise) {
                  return Data_Maybe.Nothing.value;
              };
              throw new Error("Failed pattern match at Data.Array (line 143, column 3 - line 145, column 26): " + [ i.constructor.name ]);
          };
          return Data_Unfoldable.unfoldr(dictUnfoldable)(f)(0);
      };
  };
  var $$null = function (xs) {
      return $foreign.length(xs) === 0;
  };
  var mapWithIndex = function (f) {
      return function (xs) {
          return $foreign.zipWith(f)($foreign.range(0)($foreign.length(xs) - 1 | 0))(xs);
      };
  };
  var index = $foreign.indexImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var last = function (xs) {
      return index(xs)($foreign.length(xs) - 1 | 0);
  };
  var head = function (xs) {
      return index(xs)(0);
  };
  var groupBy = function (op) {
      return function (xs) {
          return (function __do() {
              var v = Data_Array_ST.empty();
              var v1 = Data_Array_ST_Iterator.iterator(function (v1) {
                  return index(xs)(v1);
              })();
              Data_Array_ST_Iterator.iterate(v1)(function (x) {
                  return Data_Functor["void"](Control_Monad_ST_Internal.functorST)(function __do() {
                      var v2 = Data_Array_ST.empty();
                      var v3 = Data_Array_ST.push(x)(v2)();
                      Data_Array_ST_Iterator.pushWhile(op(x))(v1)(v2)();
                      var v4 = Data_Array_ST.unsafeFreeze(v2)();
                      return Data_Array_ST.push(v4)(v)();
                  });
              })();
              return Data_Array_ST.unsafeFreeze(v)();
          })();
      };
  };
  var fromFoldable = function (dictFoldable) {
      return $foreign.fromFoldableImpl(Data_Foldable.foldr(dictFoldable));
  };
  var findIndex = $foreign.findIndexImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var elemIndex = function (dictEq) {
      return function (x) {
          return findIndex(function (v) {
              return Data_Eq.eq(dictEq)(v)(x);
          });
      };
  };
  exports["fromFoldable"] = fromFoldable;
  exports["toUnfoldable"] = toUnfoldable;
  exports["null"] = $$null;
  exports["head"] = head;
  exports["last"] = last;
  exports["index"] = index;
  exports["elemIndex"] = elemIndex;
  exports["mapWithIndex"] = mapWithIndex;
  exports["groupBy"] = groupBy;
  exports["zip"] = zip;
  exports["range"] = $foreign.range;
  exports["replicate"] = $foreign.replicate;
  exports["length"] = $foreign.length;
  exports["cons"] = $foreign.cons;
  exports["snoc"] = $foreign.snoc;
  exports["reverse"] = $foreign.reverse;
  exports["filter"] = $foreign.filter;
  exports["slice"] = $foreign.slice;
  exports["take"] = $foreign.take;
  exports["drop"] = $foreign.drop;
})(PS);
(function(exports) {
  "use strict";

  exports.intDegree = function (x) {
    return Math.min(Math.abs(x), 2147483647);
  };

  // See the Euclidean definition in
  // https://en.m.wikipedia.org/wiki/Modulo_operation.
  exports.intDiv = function (x) {
    return function (y) {
      if (y === 0) return 0;
      return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);
    };
  };

  exports.intMod = function (x) {
    return function (y) {
      if (y === 0) return 0;
      var yy = Math.abs(y);
      return ((x % yy) + yy) % yy;
    };
  };
})(PS["Data.EuclideanRing"] = PS["Data.EuclideanRing"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.CommutativeRing"] = $PS["Data.CommutativeRing"] || {};
  var exports = $PS["Data.CommutativeRing"];
  var Data_Ring = $PS["Data.Ring"];
  var CommutativeRing = function (Ring0) {
      this.Ring0 = Ring0;
  }; 
  var commutativeRingInt = new CommutativeRing(function () {
      return Data_Ring.ringInt;
  });
  exports["CommutativeRing"] = CommutativeRing;
  exports["commutativeRingInt"] = commutativeRingInt;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.EuclideanRing"] = $PS["Data.EuclideanRing"] || {};
  var exports = $PS["Data.EuclideanRing"];
  var $foreign = $PS["Data.EuclideanRing"];
  var Data_CommutativeRing = $PS["Data.CommutativeRing"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Semiring = $PS["Data.Semiring"];                
  var EuclideanRing = function (CommutativeRing0, degree, div, mod) {
      this.CommutativeRing0 = CommutativeRing0;
      this.degree = degree;
      this.div = div;
      this.mod = mod;
  };
  var mod = function (dict) {
      return dict.mod;
  };
  var gcd = function ($copy_dictEq) {
      return function ($copy_dictEuclideanRing) {
          return function ($copy_a) {
              return function ($copy_b) {
                  var $tco_var_dictEq = $copy_dictEq;
                  var $tco_var_dictEuclideanRing = $copy_dictEuclideanRing;
                  var $tco_var_a = $copy_a;
                  var $tco_done = false;
                  var $tco_result;
                  function $tco_loop(dictEq, dictEuclideanRing, a, b) {
                      var $7 = Data_Eq.eq(dictEq)(b)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()));
                      if ($7) {
                          $tco_done = true;
                          return a;
                      };
                      $tco_var_dictEq = dictEq;
                      $tco_var_dictEuclideanRing = dictEuclideanRing;
                      $tco_var_a = b;
                      $copy_b = mod(dictEuclideanRing)(a)(b);
                      return;
                  };
                  while (!$tco_done) {
                      $tco_result = $tco_loop($tco_var_dictEq, $tco_var_dictEuclideanRing, $tco_var_a, $copy_b);
                  };
                  return $tco_result;
              };
          };
      };
  }; 
  var euclideanRingInt = new EuclideanRing(function () {
      return Data_CommutativeRing.commutativeRingInt;
  }, $foreign.intDegree, $foreign.intDiv, $foreign.intMod);
  var div = function (dict) {
      return dict.div;
  };
  exports["EuclideanRing"] = EuclideanRing;
  exports["div"] = div;
  exports["mod"] = mod;
  exports["gcd"] = gcd;
  exports["euclideanRingInt"] = euclideanRingInt;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Semigroup.Foldable"] = $PS["Data.Semigroup.Foldable"] || {};
  var exports = $PS["Data.Semigroup.Foldable"];
  var Foldable1 = function (Foldable0, fold1, foldMap1) {
      this.Foldable0 = Foldable0;
      this.fold1 = fold1;
      this.foldMap1 = foldMap1;
  };
  var foldMap1 = function (dict) {
      return dict.foldMap1;
  };
  exports["Foldable1"] = Foldable1;
  exports["foldMap1"] = foldMap1;
})(PS);
(function(exports) {
  "use strict";

  // jshint maxparams: 3

  exports.traverseArrayImpl = function () {
    function array1(a) {
      return [a];
    }

    function array2(a) {
      return function (b) {
        return [a, b];
      };
    }

    function array3(a) {
      return function (b) {
        return function (c) {
          return [a, b, c];
        };
      };
    }

    function concat2(xs) {
      return function (ys) {
        return xs.concat(ys);
      };
    }

    return function (apply) {
      return function (map) {
        return function (pure) {
          return function (f) {
            return function (array) {
              function go(bot, top) {
                switch (top - bot) {
                case 0: return pure([]);
                case 1: return map(array1)(f(array[bot]));
                case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));
                case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));
                default:
                  // This slightly tricky pivot selection aims to produce two
                  // even-length partitions where possible.
                  var pivot = bot + Math.floor((top - bot) / 4) * 2;
                  return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));
                }
              }
              return go(0, array.length);
            };
          };
        };
      };
    };
  }();
})(PS["Data.Traversable"] = PS["Data.Traversable"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Traversable"] = $PS["Data.Traversable"] || {};
  var exports = $PS["Data.Traversable"];
  var $foreign = $PS["Data.Traversable"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];                                                      
  var Traversable = function (Foldable1, Functor0, sequence, traverse) {
      this.Foldable1 = Foldable1;
      this.Functor0 = Functor0;
      this.sequence = sequence;
      this.traverse = traverse;
  };
  var traverse = function (dict) {
      return dict.traverse;
  }; 
  var sequenceDefault = function (dictTraversable) {
      return function (dictApplicative) {
          return traverse(dictTraversable)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));
      };
  };
  var traversableArray = new Traversable(function () {
      return Data_Foldable.foldableArray;
  }, function () {
      return Data_Functor.functorArray;
  }, function (dictApplicative) {
      return sequenceDefault(traversableArray)(dictApplicative);
  }, function (dictApplicative) {
      return $foreign.traverseArrayImpl(Control_Apply.apply(dictApplicative.Apply0()))(Data_Functor.map((dictApplicative.Apply0()).Functor0()))(Control_Applicative.pure(dictApplicative));
  });
  var sequence = function (dict) {
      return dict.sequence;
  };
  exports["Traversable"] = Traversable;
  exports["traverse"] = traverse;
  exports["sequence"] = sequence;
  exports["traversableArray"] = traversableArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.NonEmpty"] = $PS["Data.NonEmpty"] || {};
  var exports = $PS["Data.NonEmpty"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Control_Plus = $PS["Control.Plus"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Semigroup_Foldable = $PS["Data.Semigroup.Foldable"];
  var Data_Traversable = $PS["Data.Traversable"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];
  var Data_Unfoldable1 = $PS["Data.Unfoldable1"];                
  var NonEmpty = (function () {
      function NonEmpty(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      NonEmpty.create = function (value0) {
          return function (value1) {
              return new NonEmpty(value0, value1);
          };
      };
      return NonEmpty;
  })();
  var unfoldable1NonEmpty = function (dictUnfoldable) {
      return new Data_Unfoldable1.Unfoldable1(function (f) {
          return function (b) {
              return Data_Tuple.uncurry(NonEmpty.create)(Data_Functor.map(Data_Tuple.functorTuple)(Data_Unfoldable.unfoldr(dictUnfoldable)(Data_Functor.map(Data_Maybe.functorMaybe)(f)))(f(b)));
          };
      });
  };
  var singleton = function (dictPlus) {
      return function (a) {
          return new NonEmpty(a, Control_Plus.empty(dictPlus));
      };
  };
  var functorNonEmpty = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (m) {
              return new NonEmpty(f(m.value0), Data_Functor.map(dictFunctor)(f)(m.value1));
          };
      });
  };
  var foldableNonEmpty = function (dictFoldable) {
      return new Data_Foldable.Foldable(function (dictMonoid) {
          return function (f) {
              return function (v) {
                  return Data_Semigroup.append(dictMonoid.Semigroup0())(f(v.value0))(Data_Foldable.foldMap(dictFoldable)(dictMonoid)(f)(v.value1));
              };
          };
      }, function (f) {
          return function (b) {
              return function (v) {
                  return Data_Foldable.foldl(dictFoldable)(f)(f(b)(v.value0))(v.value1);
              };
          };
      }, function (f) {
          return function (b) {
              return function (v) {
                  return f(v.value0)(Data_Foldable.foldr(dictFoldable)(f)(b)(v.value1));
              };
          };
      });
  };
  var traversableNonEmpty = function (dictTraversable) {
      return new Data_Traversable.Traversable(function () {
          return foldableNonEmpty(dictTraversable.Foldable1());
      }, function () {
          return functorNonEmpty(dictTraversable.Functor0());
      }, function (dictApplicative) {
          return function (v) {
              return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(NonEmpty.create)(v.value0))(Data_Traversable.sequence(dictTraversable)(dictApplicative)(v.value1));
          };
      }, function (dictApplicative) {
          return function (f) {
              return function (v) {
                  return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(NonEmpty.create)(f(v.value0)))(Data_Traversable.traverse(dictTraversable)(dictApplicative)(f)(v.value1));
              };
          };
      });
  };
  var foldable1NonEmpty = function (dictFoldable) {
      return new Data_Semigroup_Foldable.Foldable1(function () {
          return foldableNonEmpty(dictFoldable);
      }, function (dictSemigroup) {
          return Data_Semigroup_Foldable.foldMap1(foldable1NonEmpty(dictFoldable))(dictSemigroup)(Control_Category.identity(Control_Category.categoryFn));
      }, function (dictSemigroup) {
          return function (f) {
              return function (v) {
                  return Data_Foldable.foldl(dictFoldable)(function (s) {
                      return function (a1) {
                          return Data_Semigroup.append(dictSemigroup)(s)(f(a1));
                      };
                  })(f(v.value0))(v.value1);
              };
          };
      });
  };
  exports["NonEmpty"] = NonEmpty;
  exports["singleton"] = singleton;
  exports["functorNonEmpty"] = functorNonEmpty;
  exports["foldableNonEmpty"] = foldableNonEmpty;
  exports["traversableNonEmpty"] = traversableNonEmpty;
  exports["foldable1NonEmpty"] = foldable1NonEmpty;
  exports["unfoldable1NonEmpty"] = unfoldable1NonEmpty;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.List.Types"] = $PS["Data.List.Types"] || {};
  var exports = $PS["Data.List.Types"];
  var Control_Alt = $PS["Control.Alt"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Control_Plus = $PS["Control.Plus"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_NonEmpty = $PS["Data.NonEmpty"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Semigroup_Traversable = $PS["Data.Semigroup.Traversable"];
  var Data_Traversable = $PS["Data.Traversable"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];
  var Data_Unfoldable1 = $PS["Data.Unfoldable1"];                
  var Nil = (function () {
      function Nil() {

      };
      Nil.value = new Nil();
      return Nil;
  })();
  var Cons = (function () {
      function Cons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cons.create = function (value0) {
          return function (value1) {
              return new Cons(value0, value1);
          };
      };
      return Cons;
  })();
  var NonEmptyList = function (x) {
      return x;
  };               
  var nelCons = function (a) {
      return function (v) {
          return new Data_NonEmpty.NonEmpty(a, new Cons(v.value0, v.value1));
      };
  };
  var listMap = function (f) {
      var chunkedRevMap = function ($copy_chunksAcc) {
          return function ($copy_v) {
              var $tco_var_chunksAcc = $copy_chunksAcc;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(chunksAcc, v) {
                  if (v instanceof Cons && (v.value1 instanceof Cons && v.value1.value1 instanceof Cons)) {
                      $tco_var_chunksAcc = new Cons(v, chunksAcc);
                      $copy_v = v.value1.value1.value1;
                      return;
                  };
                  var unrolledMap = function (v1) {
                      if (v1 instanceof Cons && (v1.value1 instanceof Cons && v1.value1.value1 instanceof Nil)) {
                          return new Cons(f(v1.value0), new Cons(f(v1.value1.value0), Nil.value));
                      };
                      if (v1 instanceof Cons && v1.value1 instanceof Nil) {
                          return new Cons(f(v1.value0), Nil.value);
                      };
                      return Nil.value;
                  };
                  var reverseUnrolledMap = function ($copy_v1) {
                      return function ($copy_acc) {
                          var $tco_var_v1 = $copy_v1;
                          var $tco_done = false;
                          var $tco_result;
                          function $tco_loop(v1, acc) {
                              if (v1 instanceof Cons && (v1.value0 instanceof Cons && (v1.value0.value1 instanceof Cons && v1.value0.value1.value1 instanceof Cons))) {
                                  $tco_var_v1 = v1.value1;
                                  $copy_acc = new Cons(f(v1.value0.value0), new Cons(f(v1.value0.value1.value0), new Cons(f(v1.value0.value1.value1.value0), acc)));
                                  return;
                              };
                              $tco_done = true;
                              return acc;
                          };
                          while (!$tco_done) {
                              $tco_result = $tco_loop($tco_var_v1, $copy_acc);
                          };
                          return $tco_result;
                      };
                  };
                  $tco_done = true;
                  return reverseUnrolledMap(chunksAcc)(unrolledMap(v));
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_chunksAcc, $copy_v);
              };
              return $tco_result;
          };
      };
      return chunkedRevMap(Nil.value);
  };
  var functorList = new Data_Functor.Functor(listMap);
  var functorNonEmptyList = Data_NonEmpty.functorNonEmpty(functorList);
  var foldableList = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return Data_Foldable.foldl(foldableList)(function (acc) {
              var $202 = Data_Semigroup.append(dictMonoid.Semigroup0())(acc);
              return function ($203) {
                  return $202(f($203));
              };
          })(Data_Monoid.mempty(dictMonoid));
      };
  }, function (f) {
      var go = function ($copy_b) {
          return function ($copy_v) {
              var $tco_var_b = $copy_b;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(b, v) {
                  if (v instanceof Nil) {
                      $tco_done = true;
                      return b;
                  };
                  if (v instanceof Cons) {
                      $tco_var_b = f(b)(v.value0);
                      $copy_v = v.value1;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.List.Types (line 109, column 12 - line 111, column 30): " + [ v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_b, $copy_v);
              };
              return $tco_result;
          };
      };
      return go;
  }, function (f) {
      return function (b) {
          var rev = Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value);
          var $204 = Data_Foldable.foldl(foldableList)(Data_Function.flip(f))(b);
          return function ($205) {
              return $204(rev($205));
          };
      };
  });
  var foldableNonEmptyList = Data_NonEmpty.foldableNonEmpty(foldableList);
  var semigroupList = new Data_Semigroup.Semigroup(function (xs) {
      return function (ys) {
          return Data_Foldable.foldr(foldableList)(Cons.create)(ys)(xs);
      };
  });
  var traversableList = new Data_Traversable.Traversable(function () {
      return foldableList;
  }, function () {
      return functorList;
  }, function (dictApplicative) {
      return Data_Traversable.traverse(traversableList)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));
  }, function (dictApplicative) {
      return function (f) {
          var $219 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value));
          var $220 = Data_Foldable.foldl(foldableList)(function (acc) {
              var $222 = Control_Apply.lift2(dictApplicative.Apply0())(Data_Function.flip(Cons.create))(acc);
              return function ($223) {
                  return $222(f($223));
              };
          })(Control_Applicative.pure(dictApplicative)(Nil.value));
          return function ($221) {
              return $219($220($221));
          };
      };
  });
  var traversableNonEmptyList = Data_NonEmpty.traversableNonEmpty(traversableList);
  var unfoldable1List = new Data_Unfoldable1.Unfoldable1(function (f) {
      return function (b) {
          var go = function ($copy_source) {
              return function ($copy_memo) {
                  var $tco_var_source = $copy_source;
                  var $tco_done = false;
                  var $tco_result;
                  function $tco_loop(source, memo) {
                      var v = f(source);
                      if (v.value1 instanceof Data_Maybe.Just) {
                          $tco_var_source = v.value1.value0;
                          $copy_memo = new Cons(v.value0, memo);
                          return;
                      };
                      if (v.value1 instanceof Data_Maybe.Nothing) {
                          $tco_done = true;
                          return Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value)(new Cons(v.value0, memo));
                      };
                      throw new Error("Failed pattern match at Data.List.Types (line 133, column 22 - line 135, column 61): " + [ v.constructor.name ]);
                  };
                  while (!$tco_done) {
                      $tco_result = $tco_loop($tco_var_source, $copy_memo);
                  };
                  return $tco_result;
              };
          };
          return go(b)(Nil.value);
      };
  });
  var unfoldableList = new Data_Unfoldable.Unfoldable(function () {
      return unfoldable1List;
  }, function (f) {
      return function (b) {
          var go = function ($copy_source) {
              return function ($copy_memo) {
                  var $tco_var_source = $copy_source;
                  var $tco_done = false;
                  var $tco_result;
                  function $tco_loop(source, memo) {
                      var v = f(source);
                      if (v instanceof Data_Maybe.Nothing) {
                          $tco_done = true;
                          return Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value)(memo);
                      };
                      if (v instanceof Data_Maybe.Just) {
                          $tco_var_source = v.value0.value1;
                          $copy_memo = new Cons(v.value0.value0, memo);
                          return;
                      };
                      throw new Error("Failed pattern match at Data.List.Types (line 140, column 22 - line 142, column 52): " + [ v.constructor.name ]);
                  };
                  while (!$tco_done) {
                      $tco_result = $tco_loop($tco_var_source, $copy_memo);
                  };
                  return $tco_result;
              };
          };
          return go(b)(Nil.value);
      };
  });
  var unfoldable1NonEmptyList = Data_NonEmpty.unfoldable1NonEmpty(unfoldableList);
  var foldable1NonEmptyList = Data_NonEmpty.foldable1NonEmpty(foldableList);
  var applyList = new Control_Apply.Apply(function () {
      return functorList;
  }, function (v) {
      return function (v1) {
          if (v instanceof Nil) {
              return Nil.value;
          };
          if (v instanceof Cons) {
              return Data_Semigroup.append(semigroupList)(Data_Functor.map(functorList)(v.value0)(v1))(Control_Apply.apply(applyList)(v.value1)(v1));
          };
          throw new Error("Failed pattern match at Data.List.Types (line 155, column 1 - line 157, column 48): " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var applyNonEmptyList = new Control_Apply.Apply(function () {
      return functorNonEmptyList;
  }, function (v) {
      return function (v1) {
          return new Data_NonEmpty.NonEmpty(v.value0(v1.value0), Data_Semigroup.append(semigroupList)(Control_Apply.apply(applyList)(v.value1)(new Cons(v1.value0, Nil.value)))(Control_Apply.apply(applyList)(new Cons(v.value0, v.value1))(v1.value1)));
      };
  });                                              
  var altList = new Control_Alt.Alt(function () {
      return functorList;
  }, Data_Semigroup.append(semigroupList));
  var plusList = new Control_Plus.Plus(function () {
      return altList;
  }, Nil.value);
  var applicativeNonEmptyList = new Control_Applicative.Applicative(function () {
      return applyNonEmptyList;
  }, (function () {
      var $233 = Data_NonEmpty.singleton(plusList);
      return function ($234) {
          return NonEmptyList($233($234));
      };
  })());
  var traversable1NonEmptyList = new Data_Semigroup_Traversable.Traversable1(function () {
      return foldable1NonEmptyList;
  }, function () {
      return traversableNonEmptyList;
  }, function (dictApply) {
      return Data_Semigroup_Traversable.traverse1(traversable1NonEmptyList)(dictApply)(Control_Category.identity(Control_Category.categoryFn));
  }, function (dictApply) {
      return function (f) {
          return function (v) {
              return Data_Functor.mapFlipped(dictApply.Functor0())(Data_Foldable.foldl(foldableList)(function (acc) {
                  var $235 = Control_Apply.lift2(dictApply)(Data_Function.flip(nelCons))(acc);
                  return function ($236) {
                      return $235(f($236));
                  };
              })(Data_Functor.map(dictApply.Functor0())(Control_Applicative.pure(applicativeNonEmptyList))(f(v.value0)))(v.value1))(function (v1) {
                  return Data_Foldable.foldl(foldableList)(Data_Function.flip(nelCons))(Control_Applicative.pure(applicativeNonEmptyList)(v1.value0))(v1.value1);
              });
          };
      };
  });
  exports["Nil"] = Nil;
  exports["Cons"] = Cons;
  exports["NonEmptyList"] = NonEmptyList;
  exports["functorList"] = functorList;
  exports["foldableList"] = foldableList;
  exports["unfoldableList"] = unfoldableList;
  exports["plusList"] = plusList;
  exports["applicativeNonEmptyList"] = applicativeNonEmptyList;
  exports["foldableNonEmptyList"] = foldableNonEmptyList;
  exports["unfoldable1NonEmptyList"] = unfoldable1NonEmptyList;
  exports["traversable1NonEmptyList"] = traversable1NonEmptyList;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.List"] = $PS["Data.List"] || {};
  var exports = $PS["Data.List"];
  var Control_Alt = $PS["Control.Alt"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad_Rec_Class = $PS["Control.Monad.Rec.Class"];
  var Data_Bifunctor = $PS["Data.Bifunctor"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];
  var Data_Unit = $PS["Data.Unit"];                                              
  var uncons = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just({
              head: v.value0,
              tail: v.value1
          });
      };
      throw new Error("Failed pattern match at Data.List (line 259, column 1 - line 259, column 66): " + [ v.constructor.name ]);
  };
  var toUnfoldable = function (dictUnfoldable) {
      return Data_Unfoldable.unfoldr(dictUnfoldable)(function (xs) {
          return Data_Functor.map(Data_Maybe.functorMaybe)(function (rec) {
              return new Data_Tuple.Tuple(rec.head, rec.tail);
          })(uncons(xs));
      });
  };
  var tail = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just(v.value1);
      };
      throw new Error("Failed pattern match at Data.List (line 245, column 1 - line 245, column 43): " + [ v.constructor.name ]);
  };
  var reverse = (function () {
      var go = function ($copy_acc) {
          return function ($copy_v) {
              var $tco_var_acc = $copy_acc;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(acc, v) {
                  if (v instanceof Data_List_Types.Nil) {
                      $tco_done = true;
                      return acc;
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      $tco_var_acc = new Data_List_Types.Cons(v.value0, acc);
                      $copy_v = v.value1;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.List (line 368, column 3 - line 368, column 19): " + [ acc.constructor.name, v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_acc, $copy_v);
              };
              return $tco_result;
          };
      };
      return go(Data_List_Types.Nil.value);
  })();
  var $$null = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return true;
      };
      return false;
  };
  var manyRec = function (dictMonadRec) {
      return function (dictAlternative) {
          return function (p) {
              var go = function (acc) {
                  return Control_Bind.bind((dictMonadRec.Monad0()).Bind1())(Control_Alt.alt((dictAlternative.Plus1()).Alt0())(Data_Functor.map(((dictAlternative.Plus1()).Alt0()).Functor0())(Control_Monad_Rec_Class.Loop.create)(p))(Control_Applicative.pure(dictAlternative.Applicative0())(new Control_Monad_Rec_Class.Done(Data_Unit.unit))))(function (v) {
                      return Control_Applicative.pure(dictAlternative.Applicative0())(Data_Bifunctor.bimap(Control_Monad_Rec_Class.bifunctorStep)(function (v1) {
                          return new Data_List_Types.Cons(v1, acc);
                      })(function (v1) {
                          return reverse(acc);
                      })(v));
                  });
              };
              return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(go)(Data_List_Types.Nil.value);
          };
      };
  };
  var length = Data_Foldable.foldl(Data_List_Types.foldableList)(function (acc) {
      return function (v) {
          return acc + 1 | 0;
      };
  })(0);
  var head = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just(v.value0);
      };
      throw new Error("Failed pattern match at Data.List (line 230, column 1 - line 230, column 22): " + [ v.constructor.name ]);
  };
  var filter = function (p) {
      var go = function ($copy_acc) {
          return function ($copy_v) {
              var $tco_var_acc = $copy_acc;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(acc, v) {
                  if (v instanceof Data_List_Types.Nil) {
                      $tco_done = true;
                      return reverse(acc);
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      if (p(v.value0)) {
                          $tco_var_acc = new Data_List_Types.Cons(v.value0, acc);
                          $copy_v = v.value1;
                          return;
                      };
                      if (Data_Boolean.otherwise) {
                          $tco_var_acc = acc;
                          $copy_v = v.value1;
                          return;
                      };
                  };
                  throw new Error("Failed pattern match at Data.List (line 390, column 3 - line 390, column 27): " + [ acc.constructor.name, v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_acc, $copy_v);
              };
              return $tco_result;
          };
      };
      return go(Data_List_Types.Nil.value);
  };
  exports["toUnfoldable"] = toUnfoldable;
  exports["manyRec"] = manyRec;
  exports["null"] = $$null;
  exports["length"] = length;
  exports["uncons"] = uncons;
  exports["reverse"] = reverse;
  exports["filter"] = filter;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Abc.KeySignature"] = $PS["Data.Abc.KeySignature"] || {};
  var exports = $PS["Data.Abc.KeySignature"];
  var Data_Abc = $PS["Data.Abc"];
  var Data_Array = $PS["Data.Array"];
  var Data_Enum = $PS["Data.Enum"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_List = $PS["Data.List"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Tuple = $PS["Data.Tuple"];                
  var White = (function () {
      function White(value0) {
          this.value0 = value0;
      };
      White.create = function (value0) {
          return new White(value0);
      };
      return White;
  })();
  var Black = (function () {
      function Black(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Black.create = function (value0) {
          return function (value1) {
              return new Black(value0, value1);
          };
      };
      return Black;
  })();
  var successor = function (pc) {
      return Data_Maybe.fromJust()(Data_Enum.succ(Data_Abc.enumPitchClass)(pc));
  }; 
  var rotate = function (n) {
      return function (xs) {
          return Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Array.drop(n)(xs))(Data_Array.take(n)(xs));
      };
  };   
  var predecessor = function (pc) {
      return Data_Maybe.fromJust()(Data_Enum.pred(Data_Abc.enumPitchClass)(pc));
  };                                                                        
  var pianoOctave = [ new White(Data_Abc.C.value), new Black(Data_Abc.C.value, Data_Abc.D.value), new White(Data_Abc.D.value), new Black(Data_Abc.D.value, Data_Abc.E.value), new White(Data_Abc.E.value), new White(Data_Abc.F.value), new Black(Data_Abc.F.value, Data_Abc.G.value), new White(Data_Abc.G.value), new Black(Data_Abc.G.value, Data_Abc.A.value), new White(Data_Abc.A.value), new Black(Data_Abc.A.value, Data_Abc.B.value), new White(Data_Abc.B.value) ];
  var pianoKeyToPitch = function (isFlatCtx) {
      return function (pianoKey) {
          var convertPianoKey = function (flatCtx) {
              return function (v) {
                  if (v instanceof White) {
                      return new Data_Abc.Pitch({
                          pitchClass: v.value0,
                          accidental: Data_Abc.Natural.value
                      });
                  };
                  if (v instanceof Black) {
                      if (flatCtx) {
                          return new Data_Abc.Pitch({
                              pitchClass: v.value1,
                              accidental: Data_Abc.Flat.value
                          });
                      };
                      return new Data_Abc.Pitch({
                          pitchClass: v.value0,
                          accidental: Data_Abc.Sharp.value
                      });
                  };
                  throw new Error("Failed pattern match at Data.Abc.KeySignature (line 397, column 5 - line 397, column 52): " + [ flatCtx.constructor.name, v.constructor.name ]);
              };
          };
          return convertPianoKey(isFlatCtx)(pianoKey);
      };
  };
  var notesInChromaticScale = 12;
  var isFSharp = function (ks) {
      return Data_Eq.eq(Data_Abc.eqPitchCLass)(ks.pitchClass)(Data_Abc.F.value) && (Data_Eq.eq(Data_Abc.eqAccidental)(ks.accidental)(Data_Abc.Sharp.value) && (Data_Eq.eq(Data_Abc.eqMode)(ks.mode)(Data_Abc.Major.value) || Data_Eq.eq(Data_Abc.eqMode)(ks.mode)(Data_Abc.Ionian.value)));
  };
  var fSharpScale = new Data_List_Types.Cons(new Data_Abc.Pitch({
      pitchClass: Data_Abc.F.value,
      accidental: Data_Abc.Sharp.value
  }), new Data_List_Types.Cons(new Data_Abc.Pitch({
      pitchClass: Data_Abc.G.value,
      accidental: Data_Abc.Sharp.value
  }), new Data_List_Types.Cons(new Data_Abc.Pitch({
      pitchClass: Data_Abc.A.value,
      accidental: Data_Abc.Sharp.value
  }), new Data_List_Types.Cons(new Data_Abc.Pitch({
      pitchClass: Data_Abc.B.value,
      accidental: Data_Abc.Natural.value
  }), new Data_List_Types.Cons(new Data_Abc.Pitch({
      pitchClass: Data_Abc.C.value,
      accidental: Data_Abc.Sharp.value
  }), new Data_List_Types.Cons(new Data_Abc.Pitch({
      pitchClass: Data_Abc.D.value,
      accidental: Data_Abc.Sharp.value
  }), new Data_List_Types.Cons(new Data_Abc.Pitch({
      pitchClass: Data_Abc.E.value,
      accidental: Data_Abc.Sharp.value
  }), Data_List_Types.Nil.value)))))));
  var fSharpKeySet = Data_List.filter(function (v) {
      return Data_Eq.eq(Data_Abc.eqAccidental)(v.value0.accidental)(Data_Abc.Sharp.value);
  })(fSharpScale);
  var eqPianoKey = new Data_Eq.Eq(function (x) {
      return function (y) {
          if (x instanceof White && y instanceof White) {
              return Data_Eq.eq(Data_Abc.eqPitchCLass)(x.value0)(y.value0);
          };
          if (x instanceof Black && y instanceof Black) {
              return Data_Eq.eq(Data_Abc.eqPitchCLass)(x.value0)(y.value0) && Data_Eq.eq(Data_Abc.eqPitchCLass)(x.value1)(y.value1);
          };
          return false;
      };
  });
  var distanceFromMajor = function (mode) {
      if (mode instanceof Data_Abc.Dorian) {
          return 10;
      };
      if (mode instanceof Data_Abc.Phrygian) {
          return 8;
      };
      if (mode instanceof Data_Abc.Lydian) {
          return 7;
      };
      if (mode instanceof Data_Abc.Mixolydian) {
          return 5;
      };
      if (mode instanceof Data_Abc.Aeolian) {
          return 3;
      };
      if (mode instanceof Data_Abc.Minor) {
          return 3;
      };
      if (mode instanceof Data_Abc.Locrian) {
          return 1;
      };
      if (mode instanceof Data_Abc.Major) {
          return 0;
      };
      if (mode instanceof Data_Abc.Ionian) {
          return 0;
      };
      throw new Error("Failed pattern match at Data.Abc.KeySignature (line 377, column 3 - line 386, column 16): " + [ mode.constructor.name ]);
  };
  var distanceFromC = function (keySig) {
      return Data_Maybe.fromMaybe(0)(Data_Array.elemIndex(eqPianoKey)(keySig)(pianoOctave));
  };
  var diatonicScaleOffsets = [ 0, 2, 4, 5, 7, 9, 11 ];
  var pianoKeyScale = function (keySig) {
      return function (mode) {
          var shift = Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(distanceFromC(keySig) + distanceFromMajor(mode) | 0)(notesInChromaticScale);
          var scale = rotate(shift)(pianoOctave);
          var tonic = Data_Maybe.fromMaybe(new White(Data_Abc.C.value))(Data_Array.head(scale));
          var lookup = function (key) {
              return Data_Maybe.fromMaybe(new White(Data_Abc.C.value))(Data_Array.index(scale)(key));
          };
          var keys = Data_Functor.map(Data_Functor.functorArray)(lookup)(diatonicScaleOffsets);
          return new Data_Tuple.Tuple(tonic, keys);
      };
  };
  var buildPianoKey = function (v) {
      if (v.value0.accidental instanceof Data_Abc.Flat) {
          return new Black(predecessor(v.value0.pitchClass), v.value0.pitchClass);
      };
      if (v.value0.accidental instanceof Data_Abc.Sharp) {
          return new Black(v.value0.pitchClass, successor(v.value0.pitchClass));
      };
      return new White(v.value0.pitchClass);
  };
  var normaliseModalKey = function (ks) {
      var pianoKeySignature = buildPianoKey(new Data_Abc.Pitch({
          pitchClass: ks.pitchClass,
          accidental: ks.accidental
      }));
      var v = pianoKeyScale(pianoKeySignature)(ks.mode);
      var isFlatCtx = Data_Eq.eq(Data_Abc.eqAccidental)(ks.accidental)(Data_Abc.Flat.value);
      var v1 = pianoKeyToPitch(isFlatCtx)(v.value0);
      return {
          pitchClass: v1.value0.pitchClass,
          accidental: v1.value0.accidental,
          mode: Data_Abc.Major.value
      };
  };
  var blackKeySet = function (keySig) {
      return function (mode) {
          var v = pianoKeyScale(keySig)(mode);
          var isBlackKey = function (v1) {
              if (v1 instanceof White) {
                  return false;
              };
              if (v1 instanceof Black) {
                  return true;
              };
              throw new Error("Failed pattern match at Data.Abc.KeySignature (line 340, column 5 - line 340, column 38): " + [ v1.constructor.name ]);
          };
          return Data_Tuple.Tuple.create(v.value0)(Data_Array.filter(isBlackKey)(v.value1));
      };
  };
  var keySet = function (ks) {
      var pianoKeySignature = buildPianoKey(new Data_Abc.Pitch({
          pitchClass: ks.pitchClass,
          accidental: ks.accidental
      }));
      var v = blackKeySet(pianoKeySignature)(ks.mode);
      var isFlatCtx = (function () {
          if (v.value0 instanceof White && v.value0.value0 instanceof Data_Abc.F) {
              return true;
          };
          if (v.value0 instanceof White) {
              return false;
          };
          return true;
      })();
      var basicKeySet = Data_Array.toUnfoldable(Data_List_Types.unfoldableList)(Data_Functor.map(Data_Functor.functorArray)(pianoKeyToPitch(isFlatCtx))(v.value1));
      var $119 = isFSharp(ks);
      if ($119) {
          return fSharpKeySet;
      };
      if (v.value0 instanceof Black && (v.value0.value0 instanceof Data_Abc.F && v.value0.value1 instanceof Data_Abc.G)) {
          return new Data_List_Types.Cons(new Data_Abc.Pitch({
              pitchClass: Data_Abc.C.value,
              accidental: Data_Abc.Flat.value
          }), basicKeySet);
      };
      return basicKeySet;
  };
  exports["keySet"] = keySet;
  exports["normaliseModalKey"] = normaliseModalKey;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Map.Internal"] = $PS["Data.Map.Internal"] || {};
  var exports = $PS["Data.Map.Internal"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];                
  var Leaf = (function () {
      function Leaf() {

      };
      Leaf.value = new Leaf();
      return Leaf;
  })();
  var Two = (function () {
      function Two(value0, value1, value2, value3) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
      };
      Two.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return new Two(value0, value1, value2, value3);
                  };
              };
          };
      };
      return Two;
  })();
  var Three = (function () {
      function Three(value0, value1, value2, value3, value4, value5, value6) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
          this.value6 = value6;
      };
      Three.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return function (value6) {
                                  return new Three(value0, value1, value2, value3, value4, value5, value6);
                              };
                          };
                      };
                  };
              };
          };
      };
      return Three;
  })();
  var TwoLeft = (function () {
      function TwoLeft(value0, value1, value2) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
      };
      TwoLeft.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return new TwoLeft(value0, value1, value2);
              };
          };
      };
      return TwoLeft;
  })();
  var TwoRight = (function () {
      function TwoRight(value0, value1, value2) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
      };
      TwoRight.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return new TwoRight(value0, value1, value2);
              };
          };
      };
      return TwoRight;
  })();
  var ThreeLeft = (function () {
      function ThreeLeft(value0, value1, value2, value3, value4, value5) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
      };
      ThreeLeft.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return new ThreeLeft(value0, value1, value2, value3, value4, value5);
                          };
                      };
                  };
              };
          };
      };
      return ThreeLeft;
  })();
  var ThreeMiddle = (function () {
      function ThreeMiddle(value0, value1, value2, value3, value4, value5) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
      };
      ThreeMiddle.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return new ThreeMiddle(value0, value1, value2, value3, value4, value5);
                          };
                      };
                  };
              };
          };
      };
      return ThreeMiddle;
  })();
  var ThreeRight = (function () {
      function ThreeRight(value0, value1, value2, value3, value4, value5) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
      };
      ThreeRight.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return new ThreeRight(value0, value1, value2, value3, value4, value5);
                          };
                      };
                  };
              };
          };
      };
      return ThreeRight;
  })();
  var KickUp = (function () {
      function KickUp(value0, value1, value2, value3) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
      };
      KickUp.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return new KickUp(value0, value1, value2, value3);
                  };
              };
          };
      };
      return KickUp;
  })();
  var singleton = function (k) {
      return function (v) {
          return new Two(Leaf.value, k, v, Leaf.value);
      };
  };
  var toUnfoldable = function (dictUnfoldable) {
      return function (m) {
          var go = function ($copy_v) {
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(v) {
                  if (v instanceof Data_List_Types.Nil) {
                      $tco_done = true;
                      return Data_Maybe.Nothing.value;
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      if (v.value0 instanceof Leaf) {
                          $copy_v = v.value1;
                          return;
                      };
                      if (v.value0 instanceof Two && (v.value0.value0 instanceof Leaf && v.value0.value3 instanceof Leaf)) {
                          $tco_done = true;
                          return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value1, v.value0.value2), v.value1));
                      };
                      if (v.value0 instanceof Two && v.value0.value0 instanceof Leaf) {
                          $tco_done = true;
                          return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value1, v.value0.value2), new Data_List_Types.Cons(v.value0.value3, v.value1)));
                      };
                      if (v.value0 instanceof Two) {
                          $copy_v = new Data_List_Types.Cons(v.value0.value0, new Data_List_Types.Cons(singleton(v.value0.value1)(v.value0.value2), new Data_List_Types.Cons(v.value0.value3, v.value1)));
                          return;
                      };
                      if (v.value0 instanceof Three) {
                          $copy_v = new Data_List_Types.Cons(v.value0.value0, new Data_List_Types.Cons(singleton(v.value0.value1)(v.value0.value2), new Data_List_Types.Cons(v.value0.value3, new Data_List_Types.Cons(singleton(v.value0.value4)(v.value0.value5), new Data_List_Types.Cons(v.value0.value6, v.value1)))));
                          return;
                      };
                      throw new Error("Failed pattern match at Data.Map.Internal (line 577, column 18 - line 586, column 71): " + [ v.value0.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at Data.Map.Internal (line 576, column 3 - line 576, column 19): " + [ v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($copy_v);
              };
              return $tco_result;
          };
          return Data_Unfoldable.unfoldr(dictUnfoldable)(go)(new Data_List_Types.Cons(m, Data_List_Types.Nil.value));
      };
  };
  var lookup = function (dictOrd) {
      return function (k) {
          var comp = Data_Ord.compare(dictOrd);
          var go = function ($copy_v) {
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(v) {
                  if (v instanceof Leaf) {
                      $tco_done = true;
                      return Data_Maybe.Nothing.value;
                  };
                  if (v instanceof Two) {
                      var v2 = comp(k)(v.value1);
                      if (v2 instanceof Data_Ordering.EQ) {
                          $tco_done = true;
                          return new Data_Maybe.Just(v.value2);
                      };
                      if (v2 instanceof Data_Ordering.LT) {
                          $copy_v = v.value0;
                          return;
                      };
                      $copy_v = v.value3;
                      return;
                  };
                  if (v instanceof Three) {
                      var v3 = comp(k)(v.value1);
                      if (v3 instanceof Data_Ordering.EQ) {
                          $tco_done = true;
                          return new Data_Maybe.Just(v.value2);
                      };
                      var v4 = comp(k)(v.value4);
                      if (v4 instanceof Data_Ordering.EQ) {
                          $tco_done = true;
                          return new Data_Maybe.Just(v.value5);
                      };
                      if (v3 instanceof Data_Ordering.LT) {
                          $copy_v = v.value0;
                          return;
                      };
                      if (v4 instanceof Data_Ordering.GT) {
                          $copy_v = v.value6;
                          return;
                      };
                      $copy_v = v.value3;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.Map.Internal (line 200, column 5 - line 200, column 22): " + [ v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($copy_v);
              };
              return $tco_result;
          };
          return go;
      };
  }; 
  var fromZipper = function ($copy_dictOrd) {
      return function ($copy_v) {
          return function ($copy_tree) {
              var $tco_var_dictOrd = $copy_dictOrd;
              var $tco_var_v = $copy_v;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(dictOrd, v, tree) {
                  if (v instanceof Data_List_Types.Nil) {
                      $tco_done = true;
                      return tree;
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      if (v.value0 instanceof TwoLeft) {
                          $tco_var_dictOrd = dictOrd;
                          $tco_var_v = v.value1;
                          $copy_tree = new Two(tree, v.value0.value0, v.value0.value1, v.value0.value2);
                          return;
                      };
                      if (v.value0 instanceof TwoRight) {
                          $tco_var_dictOrd = dictOrd;
                          $tco_var_v = v.value1;
                          $copy_tree = new Two(v.value0.value0, v.value0.value1, v.value0.value2, tree);
                          return;
                      };
                      if (v.value0 instanceof ThreeLeft) {
                          $tco_var_dictOrd = dictOrd;
                          $tco_var_v = v.value1;
                          $copy_tree = new Three(tree, v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5);
                          return;
                      };
                      if (v.value0 instanceof ThreeMiddle) {
                          $tco_var_dictOrd = dictOrd;
                          $tco_var_v = v.value1;
                          $copy_tree = new Three(v.value0.value0, v.value0.value1, v.value0.value2, tree, v.value0.value3, v.value0.value4, v.value0.value5);
                          return;
                      };
                      if (v.value0 instanceof ThreeRight) {
                          $tco_var_dictOrd = dictOrd;
                          $tco_var_v = v.value1;
                          $copy_tree = new Three(v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5, tree);
                          return;
                      };
                      throw new Error("Failed pattern match at Data.Map.Internal (line 418, column 3 - line 423, column 88): " + [ v.value0.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at Data.Map.Internal (line 415, column 1 - line 415, column 80): " + [ v.constructor.name, tree.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_dictOrd, $tco_var_v, $copy_tree);
              };
              return $tco_result;
          };
      };
  };
  var insert = function (dictOrd) {
      return function (k) {
          return function (v) {
              var up = function ($copy_v1) {
                  return function ($copy_v2) {
                      var $tco_var_v1 = $copy_v1;
                      var $tco_done = false;
                      var $tco_result;
                      function $tco_loop(v1, v2) {
                          if (v1 instanceof Data_List_Types.Nil) {
                              $tco_done = true;
                              return new Two(v2.value0, v2.value1, v2.value2, v2.value3);
                          };
                          if (v1 instanceof Data_List_Types.Cons) {
                              if (v1.value0 instanceof TwoLeft) {
                                  $tco_done = true;
                                  return fromZipper(dictOrd)(v1.value1)(new Three(v2.value0, v2.value1, v2.value2, v2.value3, v1.value0.value0, v1.value0.value1, v1.value0.value2));
                              };
                              if (v1.value0 instanceof TwoRight) {
                                  $tco_done = true;
                                  return fromZipper(dictOrd)(v1.value1)(new Three(v1.value0.value0, v1.value0.value1, v1.value0.value2, v2.value0, v2.value1, v2.value2, v2.value3));
                              };
                              if (v1.value0 instanceof ThreeLeft) {
                                  $tco_var_v1 = v1.value1;
                                  $copy_v2 = new KickUp(new Two(v2.value0, v2.value1, v2.value2, v2.value3), v1.value0.value0, v1.value0.value1, new Two(v1.value0.value2, v1.value0.value3, v1.value0.value4, v1.value0.value5));
                                  return;
                              };
                              if (v1.value0 instanceof ThreeMiddle) {
                                  $tco_var_v1 = v1.value1;
                                  $copy_v2 = new KickUp(new Two(v1.value0.value0, v1.value0.value1, v1.value0.value2, v2.value0), v2.value1, v2.value2, new Two(v2.value3, v1.value0.value3, v1.value0.value4, v1.value0.value5));
                                  return;
                              };
                              if (v1.value0 instanceof ThreeRight) {
                                  $tco_var_v1 = v1.value1;
                                  $copy_v2 = new KickUp(new Two(v1.value0.value0, v1.value0.value1, v1.value0.value2, v1.value0.value3), v1.value0.value4, v1.value0.value5, new Two(v2.value0, v2.value1, v2.value2, v2.value3));
                                  return;
                              };
                              throw new Error("Failed pattern match at Data.Map.Internal (line 454, column 5 - line 459, column 108): " + [ v1.value0.constructor.name, v2.constructor.name ]);
                          };
                          throw new Error("Failed pattern match at Data.Map.Internal (line 451, column 3 - line 451, column 56): " + [ v1.constructor.name, v2.constructor.name ]);
                      };
                      while (!$tco_done) {
                          $tco_result = $tco_loop($tco_var_v1, $copy_v2);
                      };
                      return $tco_result;
                  };
              };
              var comp = Data_Ord.compare(dictOrd);
              var down = function ($copy_ctx) {
                  return function ($copy_v1) {
                      var $tco_var_ctx = $copy_ctx;
                      var $tco_done = false;
                      var $tco_result;
                      function $tco_loop(ctx, v1) {
                          if (v1 instanceof Leaf) {
                              $tco_done = true;
                              return up(ctx)(new KickUp(Leaf.value, k, v, Leaf.value));
                          };
                          if (v1 instanceof Two) {
                              var v2 = comp(k)(v1.value1);
                              if (v2 instanceof Data_Ordering.EQ) {
                                  $tco_done = true;
                                  return fromZipper(dictOrd)(ctx)(new Two(v1.value0, k, v, v1.value3));
                              };
                              if (v2 instanceof Data_Ordering.LT) {
                                  $tco_var_ctx = new Data_List_Types.Cons(new TwoLeft(v1.value1, v1.value2, v1.value3), ctx);
                                  $copy_v1 = v1.value0;
                                  return;
                              };
                              $tco_var_ctx = new Data_List_Types.Cons(new TwoRight(v1.value0, v1.value1, v1.value2), ctx);
                              $copy_v1 = v1.value3;
                              return;
                          };
                          if (v1 instanceof Three) {
                              var v3 = comp(k)(v1.value1);
                              if (v3 instanceof Data_Ordering.EQ) {
                                  $tco_done = true;
                                  return fromZipper(dictOrd)(ctx)(new Three(v1.value0, k, v, v1.value3, v1.value4, v1.value5, v1.value6));
                              };
                              var v4 = comp(k)(v1.value4);
                              if (v4 instanceof Data_Ordering.EQ) {
                                  $tco_done = true;
                                  return fromZipper(dictOrd)(ctx)(new Three(v1.value0, v1.value1, v1.value2, v1.value3, k, v, v1.value6));
                              };
                              if (v3 instanceof Data_Ordering.LT) {
                                  $tco_var_ctx = new Data_List_Types.Cons(new ThreeLeft(v1.value1, v1.value2, v1.value3, v1.value4, v1.value5, v1.value6), ctx);
                                  $copy_v1 = v1.value0;
                                  return;
                              };
                              if (v3 instanceof Data_Ordering.GT && v4 instanceof Data_Ordering.LT) {
                                  $tco_var_ctx = new Data_List_Types.Cons(new ThreeMiddle(v1.value0, v1.value1, v1.value2, v1.value4, v1.value5, v1.value6), ctx);
                                  $copy_v1 = v1.value3;
                                  return;
                              };
                              $tco_var_ctx = new Data_List_Types.Cons(new ThreeRight(v1.value0, v1.value1, v1.value2, v1.value3, v1.value4, v1.value5), ctx);
                              $copy_v1 = v1.value6;
                              return;
                          };
                          throw new Error("Failed pattern match at Data.Map.Internal (line 434, column 3 - line 434, column 55): " + [ ctx.constructor.name, v1.constructor.name ]);
                      };
                      while (!$tco_done) {
                          $tco_result = $tco_loop($tco_var_ctx, $copy_v1);
                      };
                      return $tco_result;
                  };
              };
              return down(Data_List_Types.Nil.value);
          };
      };
  };
  var empty = Leaf.value;
  var fromFoldable = function (dictOrd) {
      return function (dictFoldable) {
          return Data_Foldable.foldl(dictFoldable)(function (m) {
              return function (v) {
                  return insert(dictOrd)(v.value0)(v.value1)(m);
              };
          })(empty);
      };
  };
  exports["empty"] = empty;
  exports["insert"] = insert;
  exports["lookup"] = lookup;
  exports["fromFoldable"] = fromFoldable;
  exports["toUnfoldable"] = toUnfoldable;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Ratio"] = $PS["Data.Ratio"] || {};
  var exports = $PS["Data.Ratio"];
  var Data_CommutativeRing = $PS["Data.CommutativeRing"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ring = $PS["Data.Ring"];
  var Data_Semiring = $PS["Data.Semiring"];        
  var Ratio = (function () {
      function Ratio(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Ratio.create = function (value0) {
          return function (value1) {
              return new Ratio(value0, value1);
          };
      };
      return Ratio;
  })();
  var reduce = function (dictOrd) {
      return function (dictEuclideanRing) {
          return function (n) {
              return function (d) {
                  var g = Data_EuclideanRing.gcd(dictOrd.Eq0())(dictEuclideanRing)(n)(d);
                  var d$prime = Data_EuclideanRing.div(dictEuclideanRing)(d)(g);
                  return new Ratio(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(Data_EuclideanRing.div(dictEuclideanRing)(n)(g))(Data_Ord.signum(dictOrd)((dictEuclideanRing.CommutativeRing0()).Ring0())(d$prime)), Data_Ord.abs(dictOrd)((dictEuclideanRing.CommutativeRing0()).Ring0())(d$prime));
              };
          };
      };
  };
  var semiringRatio = function (dictOrd) {
      return function (dictEuclideanRing) {
          return new Data_Semiring.Semiring(function (v) {
              return function (v1) {
                  return reduce(dictOrd)(dictEuclideanRing)(Data_Semiring.add(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(v.value0)(v1.value1))(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(v.value1)(v1.value0)))(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(v.value1)(v1.value1));
              };
          }, function (v) {
              return function (v1) {
                  return reduce(dictOrd)(dictEuclideanRing)(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(v.value0)(v1.value0))(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(v.value1)(v1.value1));
              };
          }, new Ratio(Data_Semiring.one(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()), Data_Semiring.one(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())), new Ratio(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()), Data_Semiring.one(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())));
      };
  };
  var ringRatio = function (dictOrd) {
      return function (dictEuclideanRing) {
          return new Data_Ring.Ring(function () {
              return semiringRatio(dictOrd)(dictEuclideanRing);
          }, function (v) {
              return function (v1) {
                  return reduce(dictOrd)(dictEuclideanRing)(Data_Ring.sub((dictEuclideanRing.CommutativeRing0()).Ring0())(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(v.value0)(v1.value1))(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(v.value1)(v1.value0)))(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(v.value1)(v1.value1));
              };
          });
      };
  };
  var numerator = function (v) {
      return v.value0;
  };
  var denominator = function (v) {
      return v.value1;
  };
  var commutativeRingRatio = function (dictOrd) {
      return function (dictEuclideanRing) {
          return new Data_CommutativeRing.CommutativeRing(function () {
              return ringRatio(dictOrd)(dictEuclideanRing);
          });
      };
  };
  var euclideanRingRatio = function (dictOrd) {
      return function (dictEuclideanRing) {
          return new Data_EuclideanRing.EuclideanRing(function () {
              return commutativeRingRatio(dictOrd)(dictEuclideanRing);
          }, function (v) {
              return 1;
          }, function (v) {
              return function (v1) {
                  return reduce(dictOrd)(dictEuclideanRing)(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(v.value0)(v1.value1))(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(v.value1)(v1.value0));
              };
          }, function (v) {
              return function (v1) {
                  return Data_Semiring.zero(semiringRatio(dictOrd)(dictEuclideanRing));
              };
          });
      };
  };
  exports["reduce"] = reduce;
  exports["numerator"] = numerator;
  exports["denominator"] = denominator;
  exports["semiringRatio"] = semiringRatio;
  exports["ringRatio"] = ringRatio;
  exports["euclideanRingRatio"] = euclideanRingRatio;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Abc.Metadata"] = $PS["Data.Abc.Metadata"] || {};
  var exports = $PS["Data.Abc.Metadata"];
  var Data_Abc = $PS["Data.Abc"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_HeytingAlgebra = $PS["Data.HeytingAlgebra"];
  var Data_List = $PS["Data.List"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Map_Internal = $PS["Data.Map.Internal"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ratio = $PS["Data.Ratio"];
  var Data_Tuple = $PS["Data.Tuple"];
  var isEmptyStave = function (bars) {
      var isEmptyBar = function (bar) {
          var f = function (music$prime) {
              if (music$prime instanceof Data_Abc.Spacer) {
                  return true;
              };
              if (music$prime instanceof Data_Abc.Ignore) {
                  return true;
              };
              if (music$prime instanceof Data_Abc.Continuation) {
                  return true;
              };
              return false;
          };
          return Data_Foldable.all(Data_List_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(f)(bar.music) || Data_List["null"](bar.music);
      };
      return Data_Foldable.all(Data_List_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(isEmptyBar)(bars);
  };
  var getHeaderMap = function (t) {
      var f = function (h) {
          if (h instanceof Data_Abc.Area) {
              return new Data_Tuple.Tuple("A", h);
          };
          if (h instanceof Data_Abc.Book) {
              return new Data_Tuple.Tuple("B", h);
          };
          if (h instanceof Data_Abc.Composer) {
              return new Data_Tuple.Tuple("C", h);
          };
          if (h instanceof Data_Abc.Discography) {
              return new Data_Tuple.Tuple("D", h);
          };
          if (h instanceof Data_Abc.FileUrl) {
              return new Data_Tuple.Tuple("F", h);
          };
          if (h instanceof Data_Abc.Group) {
              return new Data_Tuple.Tuple("G", h);
          };
          if (h instanceof Data_Abc.History) {
              return new Data_Tuple.Tuple("H", h);
          };
          if (h instanceof Data_Abc.Instruction) {
              return new Data_Tuple.Tuple("I", h);
          };
          if (h instanceof Data_Abc.Key) {
              return new Data_Tuple.Tuple("K", h);
          };
          if (h instanceof Data_Abc.UnitNoteLength) {
              return new Data_Tuple.Tuple("L", h);
          };
          if (h instanceof Data_Abc.Meter) {
              return new Data_Tuple.Tuple("M", h);
          };
          if (h instanceof Data_Abc.Macro) {
              return new Data_Tuple.Tuple("m", h);
          };
          if (h instanceof Data_Abc.Notes) {
              return new Data_Tuple.Tuple("N", h);
          };
          if (h instanceof Data_Abc.Origin) {
              return new Data_Tuple.Tuple("O", h);
          };
          if (h instanceof Data_Abc.Parts) {
              return new Data_Tuple.Tuple("P", h);
          };
          if (h instanceof Data_Abc.Tempo) {
              return new Data_Tuple.Tuple("Q", h);
          };
          if (h instanceof Data_Abc.Rhythm) {
              return new Data_Tuple.Tuple("R", h);
          };
          if (h instanceof Data_Abc.Remark) {
              return new Data_Tuple.Tuple("r", h);
          };
          if (h instanceof Data_Abc.Source) {
              return new Data_Tuple.Tuple("S", h);
          };
          if (h instanceof Data_Abc.SymbolLine) {
              return new Data_Tuple.Tuple("s", h);
          };
          if (h instanceof Data_Abc.Title) {
              return new Data_Tuple.Tuple("T", h);
          };
          if (h instanceof Data_Abc.UserDefined) {
              return new Data_Tuple.Tuple("U", h);
          };
          if (h instanceof Data_Abc.Voice) {
              return new Data_Tuple.Tuple("V", h);
          };
          if (h instanceof Data_Abc.WordsAfter) {
              return new Data_Tuple.Tuple("W", h);
          };
          if (h instanceof Data_Abc.WordsAligned) {
              return new Data_Tuple.Tuple("w", h);
          };
          if (h instanceof Data_Abc.ReferenceNumber) {
              return new Data_Tuple.Tuple("X", h);
          };
          if (h instanceof Data_Abc.Transcription) {
              return new Data_Tuple.Tuple("Z", h);
          };
          if (h instanceof Data_Abc.FieldContinuation) {
              return new Data_Tuple.Tuple("+", h);
          };
          if (h instanceof Data_Abc.Comment) {
              return new Data_Tuple.Tuple("-", h);
          };
          if (h instanceof Data_Abc.UnsupportedHeader) {
              return new Data_Tuple.Tuple("u", h);
          };
          throw new Error("Failed pattern match at Data.Abc.Metadata (line 54, column 7 - line 143, column 22): " + [ h.constructor.name ]);
      };
      var annotatedHeaders = Data_Functor.map(Data_List_Types.functorList)(f)(Data_List.reverse(t.headers));
      return Data_Map_Internal.fromFoldable(Data_Ord.ordChar)(Data_List_Types.foldableList)(annotatedHeaders);
  };
  var getHeader = function (code) {
      return function (t) {
          return Data_Map_Internal.lookup(Data_Ord.ordChar)(code)(getHeaderMap(t));
      };
  };
  var getKeySig = function (tune) {
      var v = getHeader("K")(tune);
      if (v instanceof Data_Maybe.Just && v.value0 instanceof Data_Abc.Key) {
          return new Data_Maybe.Just(v.value0.value0);
      };
      return Data_Maybe.Nothing.value;
  };
  var getMeter = function (tune) {
      var v = getHeader("M")(tune);
      if (v instanceof Data_Maybe.Just && v.value0 instanceof Data_Abc.Meter) {
          return new Data_Maybe.Just(Data_Maybe.fromMaybe(new Data_Tuple.Tuple(4, 4))(v.value0.value0));
      };
      return Data_Maybe.Nothing.value;
  };
  var getTempoSig = function (tune) {
      var v = getHeader("Q")(tune);
      if (v instanceof Data_Maybe.Just && v.value0 instanceof Data_Abc.Tempo) {
          return new Data_Maybe.Just(v.value0.value0);
      };
      return Data_Maybe.Nothing.value;
  };
  var getUnitNoteLength = function (tune) {
      var v = getHeader("L")(tune);
      if (v instanceof Data_Maybe.Just && v.value0 instanceof Data_Abc.UnitNoteLength) {
          return new Data_Maybe.Just(v.value0.value0);
      };
      return Data_Maybe.Nothing.value;
  };
  var dotFactor = function (i) {
      if (i === 1) {
          return Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(1)(2);
      };
      if (i === 2) {
          return Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(3)(4);
      };
      if (i === 3) {
          return Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(7)(8);
      };
      return Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(0)(1);
  };
  exports["getKeySig"] = getKeySig;
  exports["getMeter"] = getMeter;
  exports["getTempoSig"] = getTempoSig;
  exports["getUnitNoteLength"] = getUnitNoteLength;
  exports["dotFactor"] = dotFactor;
  exports["isEmptyStave"] = isEmptyStave;
})(PS);
(function(exports) {
  "use strict";

  exports.fromNumberImpl = function (just) {
    return function (nothing) {
      return function (n) {
        /* jshint bitwise: false */
        return (n | 0) === n ? just(n) : nothing;
      };
    };
  };

  exports.toNumber = function (n) {
    return n;
  };

  exports.fromStringAsImpl = function (just) {
    return function (nothing) {
      return function (radix) {
        var digits;
        if (radix < 11) {
          digits = "[0-" + (radix - 1).toString() + "]";
        } else if (radix === 11) {
          digits = "[0-9a]";
        } else {
          digits = "[0-9a-" + String.fromCharCode(86 + radix) + "]";
        }
        var pattern = new RegExp("^[\\+\\-]?" + digits + "+$", "i");

        return function (s) {
          /* jshint bitwise: false */
          if (pattern.test(s)) {
            var i = parseInt(s, radix);
            return (i | 0) === i ? just(i) : nothing;
          } else {
            return nothing;
          }
        };
      };
    };
  };

  exports.pow = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return Math.pow(x,y) | 0;
    };
  };
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function(exports) {
  /* globals exports */
  "use strict";         

  exports.infinity = Infinity;
})(PS["Global"] = PS["Global"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Global"] = $PS["Global"] || {};
  var exports = $PS["Global"];
  var $foreign = $PS["Global"];
  exports["infinity"] = $foreign.infinity;
})(PS);
(function(exports) {
  "use strict";

  exports.round = Math.round;
})(PS["Math"] = PS["Math"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Math"] = $PS["Math"] || {};
  var exports = $PS["Math"];
  var $foreign = $PS["Math"];
  exports["round"] = $foreign.round;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Int"] = $PS["Data.Int"] || {};
  var exports = $PS["Data.Int"];
  var $foreign = $PS["Data.Int"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_Bounded = $PS["Data.Bounded"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Global = $PS["Global"];
  var $$Math = $PS["Math"];
  var fromStringAs = $foreign.fromStringAsImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var fromString = fromStringAs(10);
  var fromNumber = $foreign.fromNumberImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var unsafeClamp = function (x) {
      if (x === Global.infinity) {
          return 0;
      };
      if (x === -Global.infinity) {
          return 0;
      };
      if (x >= $foreign.toNumber(Data_Bounded.top(Data_Bounded.boundedInt))) {
          return Data_Bounded.top(Data_Bounded.boundedInt);
      };
      if (x <= $foreign.toNumber(Data_Bounded.bottom(Data_Bounded.boundedInt))) {
          return Data_Bounded.bottom(Data_Bounded.boundedInt);
      };
      if (Data_Boolean.otherwise) {
          return Data_Maybe.fromMaybe(0)(fromNumber(x));
      };
      throw new Error("Failed pattern match at Data.Int (line 66, column 1 - line 66, column 29): " + [ x.constructor.name ]);
  };
  var round = function ($23) {
      return unsafeClamp($$Math.round($23));
  };
  exports["round"] = round;
  exports["fromString"] = fromString;
  exports["toNumber"] = $foreign.toNumber;
  exports["pow"] = $foreign.pow;
})(PS);
(function(exports) {
  "use strict";

  // module Partial.Unsafe

  exports.unsafePartial = function (f) {
    return f();
  };
})(PS["Partial.Unsafe"] = PS["Partial.Unsafe"] || {});
(function(exports) {
  "use strict";

  // module Partial

  exports.crashWith = function () {
    return function (msg) {
      throw new Error(msg);
    };
  };
})(PS["Partial"] = PS["Partial"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Partial"] = $PS["Partial"] || {};
  var exports = $PS["Partial"];
  var $foreign = $PS["Partial"];
  exports["crashWith"] = $foreign.crashWith;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Partial.Unsafe"] = $PS["Partial.Unsafe"] || {};
  var exports = $PS["Partial.Unsafe"];
  var $foreign = $PS["Partial.Unsafe"];
  var Partial = $PS["Partial"];
  var unsafeCrashWith = function (msg) {
      return $foreign.unsafePartial(function (dictPartial) {
          return Partial.crashWith()(msg);
      });
  };
  exports["unsafeCrashWith"] = unsafeCrashWith;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.List.NonEmpty"] = $PS["Data.List.NonEmpty"] || {};
  var exports = $PS["Data.List.NonEmpty"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_List = $PS["Data.List"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_NonEmpty = $PS["Data.NonEmpty"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];
  var Partial_Unsafe = $PS["Partial.Unsafe"];
  var wrappedOperation = function (name) {
      return function (f) {
          return function (v) {
              var v1 = f(new Data_List_Types.Cons(v.value0, v.value1));
              if (v1 instanceof Data_List_Types.Cons) {
                  return new Data_NonEmpty.NonEmpty(v1.value0, v1.value1);
              };
              if (v1 instanceof Data_List_Types.Nil) {
                  return Partial_Unsafe.unsafeCrashWith("Impossible: empty list in NonEmptyList " + name);
              };
              throw new Error("Failed pattern match at Data.List.NonEmpty (line 91, column 3 - line 93, column 81): " + [ v1.constructor.name ]);
          };
      };
  };
  var uncons = function (v) {
      return {
          head: v.value0,
          tail: v.value1
      };
  };
  var toList = function (v) {
      return new Data_List_Types.Cons(v.value0, v.value1);
  };
  var toUnfoldable = function (dictUnfoldable) {
      var $164 = Data_Unfoldable.unfoldr(dictUnfoldable)(function (xs) {
          return Data_Functor.map(Data_Maybe.functorMaybe)(function (rec) {
              return new Data_Tuple.Tuple(rec.head, rec.tail);
          })(Data_List.uncons(xs));
      });
      return function ($165) {
          return $164(toList($165));
      };
  };
  var tail = function (v) {
      return v.value1;
  };
  var singleton = (function () {
      var $168 = Data_NonEmpty.singleton(Data_List_Types.plusList);
      return function ($169) {
          return Data_List_Types.NonEmptyList($168($169));
      };
  })();
  var reverse = wrappedOperation("reverse")(Data_List.reverse);
  var length = function (v) {
      return 1 + Data_List.length(v.value1) | 0;
  };
  var head = function (v) {
      return v.value0;
  };
  var cons = function (y) {
      return function (v) {
          return new Data_NonEmpty.NonEmpty(y, new Data_List_Types.Cons(v.value0, v.value1));
      };
  };
  exports["toUnfoldable"] = toUnfoldable;
  exports["toList"] = toList;
  exports["singleton"] = singleton;
  exports["length"] = length;
  exports["cons"] = cons;
  exports["head"] = head;
  exports["reverse"] = reverse;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Rational"] = $PS["Data.Rational"] || {};
  var exports = $PS["Data.Rational"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Int = $PS["Data.Int"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ratio = $PS["Data.Ratio"];                
  var toNumber = function (x) {
      return Data_Int.toNumber(Data_Ratio.numerator(x)) / Data_Int.toNumber(Data_Ratio.denominator(x));
  };
  var fromInt = function (i) {
      return Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(i)(1);
  };
  exports["toNumber"] = toNumber;
  exports["fromInt"] = fromInt;
})(PS);
(function(exports) {
  "use strict";
  /* global Symbol */

  var hasArrayFrom = typeof Array.from === "function";
  var hasStringIterator =
    typeof Symbol !== "undefined" &&
    Symbol != null &&
    typeof Symbol.iterator !== "undefined" &&
    typeof String.prototype[Symbol.iterator] === "function";
  var hasFromCodePoint = typeof String.prototype.fromCodePoint === "function";
  var hasCodePointAt = typeof String.prototype.codePointAt === "function";

  exports._unsafeCodePointAt0 = function (fallback) {
    return hasCodePointAt
      ? function (str) { return str.codePointAt(0); }
      : fallback;
  };

  exports._singleton = function (fallback) {
    return hasFromCodePoint ? String.fromCodePoint : fallback;
  };

  exports._take = function (fallback) {
    return function (n) {
      if (hasStringIterator) {
        return function (str) {
          var accum = "";
          var iter = str[Symbol.iterator]();
          for (var i = 0; i < n; ++i) {
            var o = iter.next();
            if (o.done) return accum;
            accum += o.value;
          }
          return accum;
        };
      }
      return fallback(n);
    };
  };

  exports._toCodePointArray = function (fallback) {
    return function (unsafeCodePointAt0) {
      if (hasArrayFrom) {
        return function (str) {
          return Array.from(str, unsafeCodePointAt0);
        };
      }
      return fallback;
    };
  };
})(PS["Data.String.CodePoints"] = PS["Data.String.CodePoints"] || {});
(function(exports) {
  "use strict";

  exports.fromCharArray = function (a) {
    return a.join("");
  };

  exports.toCharArray = function (s) {
    return s.split("");
  };

  exports.singleton = function (c) {
    return c;
  };

  exports._charAt = function (just) {
    return function (nothing) {
      return function (i) {
        return function (s) {
          return i >= 0 && i < s.length ? just(s.charAt(i)) : nothing;
        };
      };
    };
  };

  exports.length = function (s) {
    return s.length;
  };

  exports._indexOf = function (just) {
    return function (nothing) {
      return function (x) {
        return function (s) {
          var i = s.indexOf(x);
          return i === -1 ? nothing : just(i);
        };
      };
    };
  };

  exports.take = function (n) {
    return function (s) {
      return s.substr(0, n);
    };
  };

  exports.drop = function (n) {
    return function (s) {
      return s.substring(n);
    };
  };
})(PS["Data.String.CodeUnits"] = PS["Data.String.CodeUnits"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.String.CodeUnits"] = $PS["Data.String.CodeUnits"] || {};
  var exports = $PS["Data.String.CodeUnits"];
  var $foreign = $PS["Data.String.CodeUnits"];
  var Data_Maybe = $PS["Data.Maybe"];                                                         
  var indexOf = $foreign["_indexOf"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var stripPrefix = function (v) {
      return function (str) {
          var v1 = indexOf(v)(str);
          if (v1 instanceof Data_Maybe.Just && v1.value0 === 0) {
              return Data_Maybe.Just.create($foreign.drop($foreign.length(v))(str));
          };
          return Data_Maybe.Nothing.value;
      };
  };
  var charAt = $foreign["_charAt"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  exports["stripPrefix"] = stripPrefix;
  exports["charAt"] = charAt;
  exports["indexOf"] = indexOf;
  exports["singleton"] = $foreign.singleton;
  exports["fromCharArray"] = $foreign.fromCharArray;
  exports["toCharArray"] = $foreign.toCharArray;
  exports["length"] = $foreign.length;
  exports["take"] = $foreign.take;
  exports["drop"] = $foreign.drop;
})(PS);
(function(exports) {
  "use strict";

  exports.charAt = function (i) {
    return function (s) {
      if (i >= 0 && i < s.length) return s.charAt(i);
      throw new Error("Data.String.Unsafe.charAt: Invalid index.");
    };
  };
})(PS["Data.String.Unsafe"] = PS["Data.String.Unsafe"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.String.Unsafe"] = $PS["Data.String.Unsafe"] || {};
  var exports = $PS["Data.String.Unsafe"];
  var $foreign = $PS["Data.String.Unsafe"];
  exports["charAt"] = $foreign.charAt;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.String.CodePoints"] = $PS["Data.String.CodePoints"] || {};
  var exports = $PS["Data.String.CodePoints"];
  var $foreign = $PS["Data.String.CodePoints"];
  var Data_Array = $PS["Data.Array"];
  var Data_Bounded = $PS["Data.Bounded"];
  var Data_Enum = $PS["Data.Enum"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_String_CodeUnits = $PS["Data.String.CodeUnits"];
  var Data_String_Unsafe = $PS["Data.String.Unsafe"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];                
  var CodePoint = function (x) {
      return x;
  };
  var unsurrogate = function (lead) {
      return function (trail) {
          return (((lead - 55296 | 0) * 1024 | 0) + (trail - 56320 | 0) | 0) + 65536 | 0;
      };
  }; 
  var isTrail = function (cu) {
      return 56320 <= cu && cu <= 57343;
  };
  var isLead = function (cu) {
      return 55296 <= cu && cu <= 56319;
  };
  var uncons = function (s) {
      var v = Data_String_CodeUnits.length(s);
      if (v === 0) {
          return Data_Maybe.Nothing.value;
      };
      if (v === 1) {
          return new Data_Maybe.Just({
              head: Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(0)(s)),
              tail: ""
          });
      };
      var cu1 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(1)(s));
      var cu0 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(0)(s));
      var $21 = isLead(cu0) && isTrail(cu1);
      if ($21) {
          return new Data_Maybe.Just({
              head: unsurrogate(cu0)(cu1),
              tail: Data_String_CodeUnits.drop(2)(s)
          });
      };
      return new Data_Maybe.Just({
          head: cu0,
          tail: Data_String_CodeUnits.drop(1)(s)
      });
  };
  var unconsButWithTuple = function (s) {
      return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {
          return new Data_Tuple.Tuple(v.head, v.tail);
      })(uncons(s));
  };
  var toCodePointArrayFallback = function (s) {
      return Data_Unfoldable.unfoldr(Data_Unfoldable.unfoldableArray)(unconsButWithTuple)(s);
  };
  var unsafeCodePointAt0Fallback = function (s) {
      var cu0 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(0)(s));
      var $25 = isLead(cu0) && Data_String_CodeUnits.length(s) > 1;
      if ($25) {
          var cu1 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(1)(s));
          var $26 = isTrail(cu1);
          if ($26) {
              return unsurrogate(cu0)(cu1);
          };
          return cu0;
      };
      return cu0;
  };
  var unsafeCodePointAt0 = $foreign["_unsafeCodePointAt0"](unsafeCodePointAt0Fallback);
  var toCodePointArray = $foreign["_toCodePointArray"](toCodePointArrayFallback)(unsafeCodePointAt0);
  var length = function ($52) {
      return Data_Array.length(toCodePointArray($52));
  };
  var indexOf = function (p) {
      return function (s) {
          return Data_Functor.map(Data_Maybe.functorMaybe)(function (i) {
              return length(Data_String_CodeUnits.take(i)(s));
          })(Data_String_CodeUnits.indexOf(p)(s));
      };
  };
  var fromCharCode = (function () {
      var $53 = Data_Enum.toEnumWithDefaults(Data_Enum.boundedEnumChar)(Data_Bounded.bottom(Data_Bounded.boundedChar))(Data_Bounded.top(Data_Bounded.boundedChar));
      return function ($54) {
          return Data_String_CodeUnits.singleton($53($54));
      };
  })();
  var singletonFallback = function (v) {
      if (v <= 65535) {
          return fromCharCode(v);
      };
      var lead = Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt)(v - 65536 | 0)(1024) + 55296 | 0;
      var trail = Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(v - 65536 | 0)(1024) + 56320 | 0;
      return fromCharCode(lead) + fromCharCode(trail);
  };                                                                          
  var singleton = $foreign["_singleton"](singletonFallback);
  var takeFallback = function (n) {
      return function (v) {
          if (n < 1) {
              return "";
          };
          var v1 = uncons(v);
          if (v1 instanceof Data_Maybe.Just) {
              return singleton(v1.value0.head) + takeFallback(n - 1 | 0)(v1.value0.tail);
          };
          return v;
      };
  };
  var take = $foreign["_take"](takeFallback);
  var drop = function (n) {
      return function (s) {
          return Data_String_CodeUnits.drop(Data_String_CodeUnits.length(take(n)(s)))(s);
      };
  };
  var indexOf$prime = function (p) {
      return function (i) {
          return function (s) {
              var s$prime = drop(i)(s);
              return Data_Functor.map(Data_Maybe.functorMaybe)(function (k) {
                  return i + length(Data_String_CodeUnits.take(k)(s$prime)) | 0;
              })(Data_String_CodeUnits.indexOf(p)(s$prime));
          };
      };
  };
  var codePointFromChar = (function () {
      var $55 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar);
      return function ($56) {
          return CodePoint($55($56));
      };
  })();
  exports["codePointFromChar"] = codePointFromChar;
  exports["singleton"] = singleton;
  exports["length"] = length;
  exports["indexOf'"] = indexOf$prime;
  exports["drop"] = drop;
})(PS);
(function(exports) {
  "use strict";

  exports.toLower = function (s) {
    return s.toLowerCase();
  };

  exports.toUpper = function (s) {
    return s.toUpperCase();
  };
})(PS["Data.String.Common"] = PS["Data.String.Common"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.String.Common"] = $PS["Data.String.Common"] || {};
  var exports = $PS["Data.String.Common"];
  var $foreign = $PS["Data.String.Common"];
  exports["toLower"] = $foreign.toLower;
  exports["toUpper"] = $foreign.toUpper;
})(PS);
(function(exports) {
  "use strict";

  function _codePointAt (just) {
    return function (nothing) {
      return function (i) {
        return function (s) {
          var codePointArray = Array.from(s);
          var isWithinRange  = i >= 0 && i < codePointArray.length;

          return isWithinRange ? just(codePointArray[i].codePointAt(0)) : nothing;
        };
      };
    };
  }

  function _codePointAtP (just) {
    return function (nothing) {
      return function (i) {
        return function (s) {
          return i >= 0 && i < s.length ? just(s.codePointAt(i)) : nothing;
        };
      };
    };
  }

  function endsWith (searchString) {
    return function (s) {
      return s.endsWith(searchString);
    };
  }

  function endsWithP (searchString) {
    return function (position) {
      return function (s) {
        return s.endsWith(searchString, position);
      };
    };
  }

  function escapeRegex (str) {
    return str.replace(/[.*+?^${}()|[\]\-\\]/g, "\\$&");
  }

  function fromCharArray (array) {
    return array.join("");
  }

  function includes (searchString) {
    return function (str) {
      return str.includes(searchString);
    };
  }

  function includesP (needle) {
    return function (position) {
      return function (haystack) {
        // For negative `position` values, we search from the beginning of the
        // string. This is in accordance with the native
        // `String.prototype.include` function.
        var pos = Math.max(0, position);

        // Converting to arrays takes care of any surrogate code points
        var needleA    = Array.from(needle);
        var haystackA  = Array.from(haystack).slice(pos);
        var needleALen = needleA.length;

        var maxIndex = haystackA.length + 1 - needleALen;
        var found    = false;
        var i;

        // Naive implementation, at some point we should check whether Boyer-Moore
        // or Knuth-Morris-Pratt are worthwhile
        for (i = 0; i < maxIndex; i++) {
          if (needleA.every(function (e, j) { return e === haystackA[i+j]; })) {
            found = true;
            break;
          }
        }

        return found;
      };
    };
  }

  function length (str) {
    return Array.from(str).length;
  }

  function lines (str) {
    // See http://www.unicode.org/reports/tr18/#RL1.6
    return str.split(/\r\n|[\n\v\f\r\u0085\u2028\u2029]/);
  }

  function normalize (str) {
    return str.normalize();
  }

  function _normalizeP (normalizationForm) {
    return function (str) {
      return str.normalize(normalizationForm);
    };
  }

  function _repeat (just) {
    return function (nothing) {
      return function (n) {
        return function (str) {
          var result;

          try {
            result = just(str.repeat(n));
          }
          catch (error) {
            result = nothing;
          }

          return result;
        };
      };
    };
  }

  function startsWith (searchString) {
    return function (s) {
      return s.startsWith(searchString);
    };
  }

  function startsWithP (searchString) {
    return function (position) {
      return function (s) {
        return s.startsWith(searchString, position);
      };
    };
  }

  function stripChars (chars) {
    return function (s) {
      return s.replace(RegExp("[" + escapeRegex(chars) + "]", "g"), "");
    };
  }

  function stripDiacritics (str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  }

  function toCharArray (str) {
    return Array.from(str);
  }

  function unsafeCodePointAt (i) {
    return function (s) {
      var codePointArray = Array.from(s);
      var isWithinRange = i >= 0 && i < codePointArray.length;

      if (isWithinRange) {
        return codePointArray[i].codePointAt(0);
      }
      else {
        throw new Error("Data.String.Utils.unsafeCodePointAt: Invalid index");
      }
    };
  }

  function unsafeCodePointAtP (i) {
    return function (s) {
      if (i >= 0 && i < s.length) {
        return s.codePointAt(i);
      }
      else {
        throw new Error("Data.String.Utils.unsafeCodePointAt': Invalid index");
      }
    };
  }

  function unsafeRepeat (n) {
    return function (str) {
      try {
        return str.repeat(n);
      }
      catch (error) {
        throw new Error("Data.String.Utils.unsafeRepeat: Invalid count");
      }
    };
  }

  function words (s) {
    // Split at every Unicode whitespace character (25 as of Unicode 12.1)
    return s.split(/[\u000a-\u000d\u0085\u2028\u2029\u0009\u0020\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000]+/);
  }                                          
  exports.endsWith           = endsWith;     
  exports.includes           = includes;
  exports.startsWith         = startsWith;
})(PS["Data.String.Utils"] = PS["Data.String.Utils"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.String.Utils"] = $PS["Data.String.Utils"] || {};
  var exports = $PS["Data.String.Utils"];
  var $foreign = $PS["Data.String.Utils"];
  exports["endsWith"] = $foreign.endsWith;
  exports["includes"] = $foreign.includes;
  exports["startsWith"] = $foreign.startsWith;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Text.Parsing.StringParser"] = $PS["Text.Parsing.StringParser"] || {};
  var exports = $PS["Text.Parsing.StringParser"];
  var Control_Alt = $PS["Control.Alt"];
  var Control_Alternative = $PS["Control.Alternative"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Control_Monad_Rec_Class = $PS["Control.Monad.Rec.Class"];
  var Control_Plus = $PS["Control.Plus"];
  var Data_Bifunctor = $PS["Data.Bifunctor"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_Either = $PS["Data.Either"];
  var Data_Functor = $PS["Data.Functor"];          
  var ParseError = (function () {
      function ParseError(value0) {
          this.value0 = value0;
      };
      ParseError.create = function (value0) {
          return new ParseError(value0);
      };
      return ParseError;
  })();
  var unParser = function (v) {
      return v;
  };
  var $$try = function (v) {
      return function (v1) {
          return Data_Bifunctor.lmap(Data_Either.bifunctorEither)(function (v2) {
              return {
                  pos: v1.pos,
                  error: v2.error
              };
          })(v(v1));
      };
  }; 
  var functorParser = new Data_Functor.Functor(function (f) {
      return function (v) {
          var $80 = Data_Functor.map(Data_Either.functorEither)(function (v1) {
              return {
                  result: f(v1.result),
                  suffix: v1.suffix
              };
          });
          return function ($81) {
              return $80(v($81));
          };
      };
  });
  var fail = function (msg) {
      return function (v) {
          return new Data_Either.Left({
              pos: v.pos,
              error: new ParseError(msg)
          });
      };
  }; 
  var applyParser = new Control_Apply.Apply(function () {
      return functorParser;
  }, function (v) {
      return function (v1) {
          return function (s) {
              return Control_Bind.bind(Data_Either.bindEither)(v(s))(function (v2) {
                  return Control_Bind.bind(Data_Either.bindEither)(v1(v2.suffix))(function (v3) {
                      return Control_Applicative.pure(Data_Either.applicativeEither)({
                          result: v2.result(v3.result),
                          suffix: v3.suffix
                      });
                  });
              });
          };
      };
  });
  var bindParser = new Control_Bind.Bind(function () {
      return applyParser;
  }, function (v) {
      return function (f) {
          return function (s) {
              return Control_Bind.bind(Data_Either.bindEither)(v(s))(function (v1) {
                  return unParser(f(v1.result))(v1.suffix);
              });
          };
      };
  });
  var applicativeParser = new Control_Applicative.Applicative(function () {
      return applyParser;
  }, function (a) {
      return function (s) {
          return new Data_Either.Right({
              result: a,
              suffix: s
          });
      };
  });
  var monadParser = new Control_Monad.Monad(function () {
      return applicativeParser;
  }, function () {
      return bindParser;
  });
  var monadRecParser = new Control_Monad_Rec_Class.MonadRec(function () {
      return monadParser;
  }, function (f) {
      return function (a) {
          var split = function (v) {
              if (v.result instanceof Control_Monad_Rec_Class.Loop) {
                  return new Control_Monad_Rec_Class.Loop({
                      state: v.result.value0,
                      str: v.suffix
                  });
              };
              if (v.result instanceof Control_Monad_Rec_Class.Done) {
                  return new Control_Monad_Rec_Class.Done({
                      result: v.result.value0,
                      suffix: v.suffix
                  });
              };
              throw new Error("Failed pattern match at Text.Parsing.StringParser (line 88, column 7 - line 88, column 70): " + [ v.constructor.name ]);
          };
          return function (str) {
              return Control_Monad_Rec_Class.tailRecM(Control_Monad_Rec_Class.monadRecEither)(function (st) {
                  return Data_Functor.map(Data_Either.functorEither)(split)(unParser(f(st.state))(st.str));
              })({
                  state: a,
                  str: str
              });
          };
      };
  });
  var altParser = new Control_Alt.Alt(function () {
      return functorParser;
  }, function (v) {
      return function (v1) {
          return function (s) {
              var v2 = v(s);
              if (v2 instanceof Data_Either.Left) {
                  if (s.pos === v2.value0.pos) {
                      return v1(s);
                  };
                  if (Data_Boolean.otherwise) {
                      return new Data_Either.Left({
                          error: v2.value0.error,
                          pos: v2.value0.pos
                      });
                  };
              };
              return v2;
          };
      };
  });
  var plusParser = new Control_Plus.Plus(function () {
      return altParser;
  }, fail("No alternative"));
  var alternativeParser = new Control_Alternative.Alternative(function () {
      return applicativeParser;
  }, function () {
      return plusParser;
  });
  exports["ParseError"] = ParseError;
  exports["fail"] = fail;
  exports["try"] = $$try;
  exports["functorParser"] = functorParser;
  exports["applyParser"] = applyParser;
  exports["applicativeParser"] = applicativeParser;
  exports["altParser"] = altParser;
  exports["alternativeParser"] = alternativeParser;
  exports["bindParser"] = bindParser;
  exports["monadRecParser"] = monadRecParser;
})(PS);
(function(exports) {
  "use strict";

  // module Unsafe.Coerce

  exports.unsafeCoerce = function (x) {
    return x;
  };
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Unsafe.Coerce"] = $PS["Unsafe.Coerce"] || {};
  var exports = $PS["Unsafe.Coerce"];
  var $foreign = $PS["Unsafe.Coerce"];
  exports["unsafeCoerce"] = $foreign.unsafeCoerce;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Array.NonEmpty"] = $PS["Data.Array.NonEmpty"] || {};
  var exports = $PS["Data.Array.NonEmpty"];
  var Data_Array = $PS["Data.Array"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Unsafe_Coerce = $PS["Unsafe.Coerce"];        
  var toArray = Unsafe_Coerce.unsafeCoerce;
  var adaptMaybe = function (f) {
      var $64 = Data_Maybe.fromJust();
      return function ($65) {
          return $64(f(toArray($65)));
      };
  };
  var head = adaptMaybe(Data_Array.head);
  var last = adaptMaybe(Data_Array.last);    
  var adaptAny = function (f) {
      return function ($67) {
          return f(toArray($67));
      };
  };                                     
  var length = adaptAny(Data_Array.length);
  exports["length"] = length;
  exports["head"] = head;
  exports["last"] = last;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Char"] = $PS["Data.Char"] || {};
  var exports = $PS["Data.Char"];
  var Data_Enum = $PS["Data.Enum"];                
  var toCharCode = Data_Enum.fromEnum(Data_Enum.boundedEnumChar);
  exports["toCharCode"] = toCharCode;
})(PS);
(function(exports) {
  "use strict";

  exports["regex'"] = function (left) {
    return function (right) {
      return function (s1) {
        return function (s2) {
          try {
            return right(new RegExp(s1, s2));
          } catch (e) {
            return left(e.message);
          }
        };
      };
    };
  };

  exports._match = function (just) {
    return function (nothing) {
      return function (r) {
        return function (s) {
          var m = s.match(r);
          if (m == null || m.length === 0) {
            return nothing;
          } else {
            for (var i = 0; i < m.length; i++) {
              m[i] = m[i] == null ? nothing : just(m[i]);
            }
            return just(m);
          }
        };
      };
    };
  };
})(PS["Data.String.Regex"] = PS["Data.String.Regex"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.String.Regex"] = $PS["Data.String.Regex"] || {};
  var exports = $PS["Data.String.Regex"];
  var $foreign = $PS["Data.String.Regex"];
  var Data_Either = $PS["Data.Either"];
  var Data_Maybe = $PS["Data.Maybe"];                                                
  var renderFlags = function (v) {
      return (function () {
          if (v.value0.global) {
              return "g";
          };
          return "";
      })() + ((function () {
          if (v.value0.ignoreCase) {
              return "i";
          };
          return "";
      })() + ((function () {
          if (v.value0.multiline) {
              return "m";
          };
          return "";
      })() + ((function () {
          if (v.value0.sticky) {
              return "y";
          };
          return "";
      })() + (function () {
          if (v.value0.unicode) {
              return "u";
          };
          return "";
      })())));
  };
  var regex = function (s) {
      return function (f) {
          return $foreign["regex'"](Data_Either.Left.create)(Data_Either.Right.create)(s)(renderFlags(f));
      };
  };
  var match = $foreign["_match"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  exports["regex"] = regex;
  exports["match"] = match;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.String.Regex.Flags"] = $PS["Data.String.Regex.Flags"] || {};
  var exports = $PS["Data.String.Regex.Flags"];                      
  var RegexFlags = (function () {
      function RegexFlags(value0) {
          this.value0 = value0;
      };
      RegexFlags.create = function (value0) {
          return new RegexFlags(value0);
      };
      return RegexFlags;
  })();
  var noFlags = new RegexFlags({
      global: false,
      ignoreCase: false,
      multiline: false,
      sticky: false,
      unicode: false
  });
  exports["noFlags"] = noFlags;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Text.Parsing.StringParser.Combinators"] = $PS["Text.Parsing.StringParser.Combinators"] || {};
  var exports = $PS["Text.Parsing.StringParser.Combinators"];
  var Control_Alt = $PS["Control.Alt"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad_Rec_Class = $PS["Control.Monad.Rec.Class"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_List = $PS["Data.List"];
  var Data_List_NonEmpty = $PS["Data.List.NonEmpty"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_NonEmpty = $PS["Data.NonEmpty"];
  var Text_Parsing_StringParser = $PS["Text.Parsing.StringParser"];                
  var withError = function (p) {
      return function (msg) {
          return Control_Alt.alt(Text_Parsing_StringParser.altParser)(p)(Text_Parsing_StringParser.fail(msg));
      };
  };
  var option = function (a) {
      return function (p) {
          return Control_Alt.alt(Text_Parsing_StringParser.altParser)(p)(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(a));
      };
  };
  var optionMaybe = function (p) {
      return option(Data_Maybe.Nothing.value)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Maybe.Just.create)(p));
  };
  var many1Till = function (p) {
      return function (end) {
          var ending = function (acc) {
              return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(end)(function (v) {
                  return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(new Control_Monad_Rec_Class.Done(Data_List_NonEmpty.reverse(acc)));
              });
          };
          var $$continue = function (acc) {
              return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(p)(function (v) {
                  return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(new Control_Monad_Rec_Class.Loop(Data_List_NonEmpty.cons(v)(acc)));
              });
          };
          var inner = function (acc) {
              return Control_Alt.alt(Text_Parsing_StringParser.altParser)(ending(acc))($$continue(acc));
          };
          return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(p)(function (v) {
              return Control_Monad_Rec_Class.tailRecM(Text_Parsing_StringParser.monadRecParser)(inner)(Control_Applicative.pure(Data_List_Types.applicativeNonEmptyList)(v));
          });
      };
  };
  var manyTill = function (p) {
      return function (end) {
          return Control_Alt.alt(Text_Parsing_StringParser.altParser)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(end)(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(Data_List_Types.Nil.value)))(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_List_NonEmpty.toList)(many1Till(p)(end)));
      };
  };
  var many = Data_List.manyRec(Text_Parsing_StringParser.monadRecParser)(Text_Parsing_StringParser.alternativeParser);
  var cons$prime = function (h) {
      return function (t) {
          return new Data_NonEmpty.NonEmpty(h, t);
      };
  };
  var many1 = function (p) {
      return Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(cons$prime)(p))(many(p));
  };
  var sepBy1 = function (p) {
      return function (sep) {
          return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(p)(function (v) {
              return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(many(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(sep)(p)))(function (v1) {
                  return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(cons$prime(v)(v1));
              });
          });
      };
  };
  var sepBy = function (p) {
      return function (sep) {
          return Control_Alt.alt(Text_Parsing_StringParser.altParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_List_NonEmpty.toList)(sepBy1(p)(sep)))(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(Data_List_Types.Nil.value));
      };
  };
  var choice = function (dictFoldable) {
      return Data_Foldable.foldl(dictFoldable)(Control_Alt.alt(Text_Parsing_StringParser.altParser))(Text_Parsing_StringParser.fail("Nothing to parse"));
  };
  var between = function (open) {
      return function (close) {
          return function (p) {
              return Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(open)(p))(close);
          };
      };
  };
  exports["many"] = many;
  exports["many1"] = many1;
  exports["withError"] = withError;
  exports["between"] = between;
  exports["option"] = option;
  exports["optionMaybe"] = optionMaybe;
  exports["sepBy"] = sepBy;
  exports["choice"] = choice;
  exports["manyTill"] = manyTill;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Text.Parsing.StringParser.CodePoints"] = $PS["Text.Parsing.StringParser.CodePoints"] || {};
  var exports = $PS["Text.Parsing.StringParser.CodePoints"];
  var Control_Alt = $PS["Control.Alt"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Array = $PS["Data.Array"];
  var Data_Array_NonEmpty = $PS["Data.Array.NonEmpty"];
  var Data_Char = $PS["Data.Char"];
  var Data_Either = $PS["Data.Either"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Show = $PS["Data.Show"];
  var Data_String_CodePoints = $PS["Data.String.CodePoints"];
  var Data_String_CodeUnits = $PS["Data.String.CodeUnits"];
  var Data_String_Regex = $PS["Data.String.Regex"];
  var Data_String_Regex_Flags = $PS["Data.String.Regex.Flags"];
  var Data_Unit = $PS["Data.Unit"];
  var Text_Parsing_StringParser = $PS["Text.Parsing.StringParser"];
  var Text_Parsing_StringParser_Combinators = $PS["Text.Parsing.StringParser.Combinators"];                
  var string = function (nt) {
      return function (s) {
          if (Data_Eq.eq(Data_Maybe.eqMaybe(Data_Eq.eqInt))(Data_String_CodePoints["indexOf'"](nt)(s.pos)(s.str))(new Data_Maybe.Just(s.pos))) {
              return new Data_Either.Right({
                  result: nt,
                  suffix: {
                      str: s.str,
                      pos: s.pos + Data_String_CodePoints.length(nt) | 0
                  }
              });
          };
          return new Data_Either.Left({
              pos: s.pos,
              error: new Text_Parsing_StringParser.ParseError("Expected '" + (nt + "'."))
          });
      };
  };
  var regex = function (pat) {
      var pattern = (function () {
          var v = Data_String_CodeUnits.stripPrefix("^")(pat);
          if (v instanceof Data_Maybe.Nothing) {
              return "^" + pat;
          };
          return pat;
      })();
      var matchRegex = function (r) {
          return function (v) {
              var remainder = Data_String_CodePoints.drop(v.pos)(v.str);
              var v1 = Data_Functor.map(Data_Maybe.functorMaybe)(Data_Array_NonEmpty.head)(Data_String_Regex.match(r)(remainder));
              if (v1 instanceof Data_Maybe.Just && v1.value0 instanceof Data_Maybe.Just) {
                  return new Data_Either.Right({
                      result: v1.value0.value0,
                      suffix: {
                          str: v.str,
                          pos: v.pos + Data_String_CodePoints.length(v1.value0.value0) | 0
                      }
                  });
              };
              return new Data_Either.Left({
                  pos: v.pos,
                  error: new Text_Parsing_StringParser.ParseError("no match")
              });
          };
      };
      var v = Data_String_Regex.regex(pattern)(Data_String_Regex_Flags.noFlags);
      if (v instanceof Data_Either.Left) {
          return Text_Parsing_StringParser.fail("Text.Parsing.StringParser.String.regex': illegal regex " + pat);
      };
      if (v instanceof Data_Either.Right) {
          return matchRegex(v.value0);
      };
      throw new Error("Failed pattern match at Text.Parsing.StringParser.CodePoints (line 127, column 3 - line 131, column 19): " + [ v.constructor.name ]);
  };
  var eof = function (s) {
      if (s.pos < Data_String_CodePoints.length(s.str)) {
          return new Data_Either.Left({
              pos: s.pos,
              error: new Text_Parsing_StringParser.ParseError("Expected EOF")
          });
      };
      return new Data_Either.Right({
          result: Data_Unit.unit,
          suffix: s
      });
  };
  var anyChar = function (v) {
      var v1 = Data_String_CodeUnits.charAt(v.pos)(v.str);
      if (v1 instanceof Data_Maybe.Just) {
          return new Data_Either.Right({
              result: v1.value0,
              suffix: {
                  str: v.str,
                  pos: v.pos + 1 | 0
              }
          });
      };
      if (v1 instanceof Data_Maybe.Nothing) {
          return new Data_Either.Left({
              pos: v.pos,
              error: new Text_Parsing_StringParser.ParseError("Unexpected EOF")
          });
      };
      throw new Error("Failed pattern match at Text.Parsing.StringParser.CodePoints (line 51, column 3 - line 53, column 64): " + [ v1.constructor.name ]);
  };
  var anyDigit = Text_Parsing_StringParser["try"](Control_Bind.bind(Text_Parsing_StringParser.bindParser)(anyChar)(function (v) {
      var $37 = v >= "0" && v <= "9";
      if ($37) {
          return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(v);
      };
      return Text_Parsing_StringParser.fail("Character " + (Data_Show.show(Data_Show.showChar)(v) + " is not a digit"));
  }));
  var lowerCaseChar = Text_Parsing_StringParser["try"](Control_Bind.bind(Text_Parsing_StringParser.bindParser)(anyChar)(function (v) {
      var $39 = Data_Foldable.elem(Data_Foldable.foldableArray)(Data_Eq.eqInt)(Data_Char.toCharCode(v))(Data_Array.range(97)(122));
      if ($39) {
          return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(v);
      };
      return Text_Parsing_StringParser.fail("Expected a lower case character but found " + Data_Show.show(Data_Show.showChar)(v));
  }));
  var satisfy = function (f) {
      return Text_Parsing_StringParser["try"](Control_Bind.bind(Text_Parsing_StringParser.bindParser)(anyChar)(function (v) {
          var $41 = f(v);
          if ($41) {
              return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(v);
          };
          return Text_Parsing_StringParser.fail("Character " + (Data_Show.show(Data_Show.showChar)(v) + " did not satisfy predicate"));
      }));
  };
  var $$char = function (c) {
      return Text_Parsing_StringParser_Combinators.withError(satisfy(function (v) {
          return v === c;
      }))("Could not match character " + Data_Show.show(Data_Show.showChar)(c));
  };                                                                                         
  var upperCaseChar = Text_Parsing_StringParser["try"](Control_Bind.bind(Text_Parsing_StringParser.bindParser)(anyChar)(function (v) {
      var $44 = Data_Foldable.elem(Data_Foldable.foldableArray)(Data_Eq.eqInt)(Data_Char.toCharCode(v))(Data_Array.range(65)(90));
      if ($44) {
          return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(v);
      };
      return Text_Parsing_StringParser.fail("Expected an upper case character but found " + Data_Show.show(Data_Show.showChar)(v));
  }));
  var anyLetter = Text_Parsing_StringParser_Combinators.withError(Control_Alt.alt(Text_Parsing_StringParser.altParser)(lowerCaseChar)(upperCaseChar))("Expected a letter");
  var alphaNum = Text_Parsing_StringParser_Combinators.withError(Control_Alt.alt(Text_Parsing_StringParser.altParser)(anyLetter)(anyDigit))("Expected a letter or a number");
  exports["eof"] = eof;
  exports["string"] = string;
  exports["satisfy"] = satisfy;
  exports["char"] = $$char;
  exports["alphaNum"] = alphaNum;
  exports["regex"] = regex;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Abc.Parser"] = $PS["Data.Abc.Parser"] || {};
  var exports = $PS["Data.Abc.Parser"];
  var Control_Alt = $PS["Control.Alt"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Abc = $PS["Data.Abc"];
  var Data_Array = $PS["Data.Array"];
  var Data_Bifunctor = $PS["Data.Bifunctor"];
  var Data_Either = $PS["Data.Either"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Int = $PS["Data.Int"];
  var Data_List = $PS["Data.List"];
  var Data_List_NonEmpty = $PS["Data.List.NonEmpty"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Map_Internal = $PS["Data.Map.Internal"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ratio = $PS["Data.Ratio"];
  var Data_Rational = $PS["Data.Rational"];
  var Data_String_CodePoints = $PS["Data.String.CodePoints"];
  var Data_String_CodeUnits = $PS["Data.String.CodeUnits"];
  var Data_String_Common = $PS["Data.String.Common"];
  var Data_String_Utils = $PS["Data.String.Utils"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable1 = $PS["Data.Unfoldable1"];
  var Text_Parsing_StringParser = $PS["Text.Parsing.StringParser"];
  var Text_Parsing_StringParser_CodePoints = $PS["Text.Parsing.StringParser.CodePoints"];
  var Text_Parsing_StringParser_Combinators = $PS["Text.Parsing.StringParser.Combinators"];                
  var TempoDesignation = (function () {
      function TempoDesignation(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      TempoDesignation.create = function (value0) {
          return function (value1) {
              return new TempoDesignation(value0, value1);
          };
      };
      return TempoDesignation;
  })();
  var tupletLength = Text_Parsing_StringParser_CodePoints.regex("[2-9]");
  var tup = Data_Functor.map(Text_Parsing_StringParser.functorParser)(Control_Bind.join(Data_Maybe.bindMaybe))(Text_Parsing_StringParser_Combinators.optionMaybe(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(Text_Parsing_StringParser_CodePoints["char"](":"))(Text_Parsing_StringParser_Combinators.optionMaybe(tupletLength))));
  var toTupletInt = function (s) {
      return Data_Maybe.fromMaybe(3)(Data_Int.fromString(s));
  };
  var strToEol = Text_Parsing_StringParser_CodePoints.regex("[^\x0d\x0a]*");
  var space = Text_Parsing_StringParser_CodePoints["char"](" ");
  var shortDecoration = Text_Parsing_StringParser_Combinators.withError(Text_Parsing_StringParser_CodePoints.regex("[\\.~HLMOPSTuv]"))("short decoration");
  var sharpOrFlat = Data_Functor.map(Text_Parsing_StringParser.functorParser)(function (x) {
      var $13 = x === "#";
      if ($13) {
          return Data_Abc.Sharp.value;
      };
      return Data_Abc.Flat.value;
  })(Control_Alt.alt(Text_Parsing_StringParser.altParser)(Text_Parsing_StringParser_CodePoints["char"]("#"))(Text_Parsing_StringParser_CodePoints["char"]("b")));
  var scoreSpace = Control_Alt.alt(Text_Parsing_StringParser.altParser)(Text_Parsing_StringParser_CodePoints["char"]("\x09"))(space);
  var spacer = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Spacer.create)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_List_NonEmpty.length)(Text_Parsing_StringParser_Combinators.many1(scoreSpace))))("space");
  var whiteSpace = Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Foldable.foldMap(Data_List_Types.foldableList)(Data_Monoid.monoidString)(function ($54) {
      return Data_String_CodePoints.singleton(Data_String_CodePoints.codePointFromChar($54));
  }))(Text_Parsing_StringParser_Combinators.many(scoreSpace));
  var unsupportedHeaderCode = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Text_Parsing_StringParser_CodePoints.regex("[a-qt-vx-zEJ]:"))(whiteSpace);
  var unsupportedHeader = Text_Parsing_StringParser_Combinators.withError(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.UnsupportedHeader.value)(unsupportedHeaderCode))(strToEol))("unsupported header");
  var scientificPitchNotation = function (pc) {
      return function (oct) {
          var $14 = Data_String_Utils.includes(pc)("ABCDEFG");
          if ($14) {
              return Data_Abc.middlecOctave + oct | 0;
          };
          return (Data_Abc.middlecOctave + 1 | 0) + oct | 0;
      };
  };
  var runParser1 = function (v) {
      return function (s) {
          var formatErr = function (v1) {
              return {
                  pos: v1.pos,
                  error: v1.error.value0
              };
          };
          return Data_Bifunctor.bimap(Data_Either.bifunctorEither)(formatErr)(function (v1) {
              return v1.result;
          })(v({
              str: s,
              pos: 0
          }));
      };
  };
  var rightSlurBrackets = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_List.length)(Text_Parsing_StringParser_Combinators.many(Text_Parsing_StringParser_CodePoints["char"](")"))))("right slurs");
  var pitch = Text_Parsing_StringParser_CodePoints.regex("[A-Ga-g]");
  var phrygian = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.Phrygian.value)(whiteSpace))(Text_Parsing_StringParser_CodePoints.regex("[P|p][H|h][R|r][A-Za-z]*"));
  var octaveShift = function (s) {
      var up = Data_Array.length(Data_Array.filter(Data_Eq.eq(Data_Eq.eqChar)("'"))(Data_String_CodeUnits.toCharArray(s)));
      var down = Data_Array.length(Data_Array.filter(Data_Eq.eq(Data_Eq.eqChar)(","))(Data_String_CodeUnits.toCharArray(s)));
      return up - down | 0;
  };
  var nometer = Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Maybe.Nothing.value)(Text_Parsing_StringParser_CodePoints.string("none"));
  var newline = Text_Parsing_StringParser_Combinators.withError(Text_Parsing_StringParser_CodePoints.satisfy(Data_Eq.eq(Data_Eq.eqChar)("\x0a")))("expected newline");
  var moveOctave = Data_Functor.map(Text_Parsing_StringParser.functorParser)(octaveShift)(Text_Parsing_StringParser_CodePoints.regex("[',]*"));
  var mixolydian = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.Mixolydian.value)(whiteSpace))(Text_Parsing_StringParser_CodePoints.regex("[M|m][I|i][X|x][A-Za-z]*"));
  var minor = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.Minor.value)(whiteSpace))(Text_Parsing_StringParser_CodePoints.regex("[M|m][A-Za-z]*"));
  var maybeTie = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {
      return "-";
  }))(Text_Parsing_StringParser_Combinators.optionMaybe(Text_Parsing_StringParser_CodePoints.regex(" *-"))))("tie");
  var manyTill1 = Text_Parsing_StringParser_Combinators.manyTill;
  var major = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.Major.value)(whiteSpace))(Text_Parsing_StringParser_CodePoints.regex("[M|m][A|a][J|j][A-Za-z]*"));
  var lydian = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.Lydian.value)(whiteSpace))(Text_Parsing_StringParser_CodePoints.regex("[L|l][Y|y][D|d][A-Za-z]*"));
  var lookupPitch = function (p) {
      var v = Data_String_Common.toUpper(p);
      if (v === "A") {
          return Data_Abc.A.value;
      };
      if (v === "B") {
          return Data_Abc.B.value;
      };
      if (v === "C") {
          return Data_Abc.C.value;
      };
      if (v === "D") {
          return Data_Abc.D.value;
      };
      if (v === "E") {
          return Data_Abc.E.value;
      };
      if (v === "F") {
          return Data_Abc.F.value;
      };
      if (v === "G") {
          return Data_Abc.G.value;
      };
      return Data_Abc.C.value;
  };
  var longDecoration = Text_Parsing_StringParser_Combinators.withError(Text_Parsing_StringParser_Combinators.between(Text_Parsing_StringParser_CodePoints["char"]("!"))(Text_Parsing_StringParser_CodePoints["char"]("!"))(Text_Parsing_StringParser_CodePoints.regex("[^\x0d\x0a!]*")))("long decoration");
  var locrian = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.Locrian.value)(whiteSpace))(Text_Parsing_StringParser_CodePoints.regex("[L|l][O|o][C|c][A-Za-z]*"));
  var literalQuotedString = (function () {
      var quotedString = Text_Parsing_StringParser_Combinators.withError(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(Text_Parsing_StringParser_CodePoints.string("\""))(Text_Parsing_StringParser_CodePoints.regex("(\\\\\"|[^\"\x0a])*")))(Text_Parsing_StringParser_CodePoints.string("\"")))("quoted string");
      return Data_Functor.map(Text_Parsing_StringParser.functorParser)(function (s) {
          return "\"" + (s + "\"");
      })(quotedString);
  })();
  var spacedQuotedString = Text_Parsing_StringParser["try"](Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(whiteSpace)(literalQuotedString))(whiteSpace));
  var leftSlurBrackets = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_List.length)(Text_Parsing_StringParser_Combinators.many(Text_Parsing_StringParser_CodePoints["char"]("("))))("left slurs");
  var keyName = Text_Parsing_StringParser_CodePoints.regex("[A-G]");
  var ionian = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.Ionian.value)(whiteSpace))(Text_Parsing_StringParser_CodePoints.regex("[I|i][O|o][N|n][A-Za-z]*"));
  var invisibleBarType = {
      thickness: Data_Abc.Invisible.value,
      repeat: Data_Maybe.Nothing.value,
      iteration: Data_Maybe.Nothing.value
  };
  var inlineInfo = function (isInline) {
      var pattern = (function () {
          if (isInline) {
              return "[^\x0d\x0a\\[\\]]*";
          };
          return "[^\x0d\x0a]*";
      })();
      return Text_Parsing_StringParser_CodePoints.regex(pattern);
  };
  var ignore = Text_Parsing_StringParser_Combinators.withError(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.Ignore.value)(Text_Parsing_StringParser_CodePoints.regex("[#@;`\\*\\?]+")))("ignored character");
  var headerCode = function (c) {
      var pattern = Data_String_CodeUnits.fromCharArray([ c, ":" ]);
      return Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Text_Parsing_StringParser_CodePoints.string(pattern))(whiteSpace);
  };
  var history = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.History.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("H"))(strToEol)))("H header");
  var instruction = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Instruction.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("I"))(inlineInfo(isInline))))("I header");
  };
  var macro = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Macro.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("m"))(inlineInfo(isInline))))("m header");
  };
  var notes = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Notes.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("N"))(inlineInfo(isInline))))("N header");
  };
  var origin = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Origin.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("O"))(strToEol)))("O header");
  var parts = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Parts.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("P"))(inlineInfo(isInline))))("P header");
  };
  var remark = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Remark.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("r"))(inlineInfo(isInline))))("r header");
  };
  var rhythm = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Rhythm.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("R"))(inlineInfo(isInline))))("R header");
  };
  var source = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Source.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("S"))(strToEol)))("S header");
  var symbolLine = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.SymbolLine.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("s"))(inlineInfo(isInline))))("s header");
  };
  var title = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Title.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("T"))(inlineInfo(isInline))))("T header");
  };
  var transcription = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Transcription.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("Z"))(strToEol)))("Z header");
  var userDefined = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.UserDefined.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("U"))(inlineInfo(isInline))))("U header");
  };
  var wordsAfter = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.WordsAfter.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("W"))(inlineInfo(isInline))))("W header");
  };
  var wordsAligned = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.WordsAligned.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("w"))(inlineInfo(isInline))))("w header");
  };
  var tuneBodyOnlyInfo = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ symbolLine(isInline), wordsAligned(isInline) ]))("tune body only info");
  };
  var group = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Group.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("G"))(strToEol)))("G header");
  var fileUrl = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.FileUrl.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("F"))(strToEol)))("F header");
  var fieldContinuation = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.FieldContinuation.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("+"))(strToEol)))("field continuation");
  var endOfLine = Text_Parsing_StringParser_CodePoints.regex("\x0d\x0a");
  var dorian = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.Dorian.value)(whiteSpace))(Text_Parsing_StringParser_CodePoints.regex("[D|d][O|o][R|r][A-Za-z]*"));
  var discography = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Discography.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("D"))(strToEol)))("D header");
  var decoration = Text_Parsing_StringParser_Combinators.withError(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Control_Alt.alt(Text_Parsing_StringParser.altParser)(shortDecoration)(longDecoration))(whiteSpace))("decoration");
  var decorations = Text_Parsing_StringParser_Combinators.many(decoration);
  var decoratedSpace = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.DecoratedSpace.create)(decorations))(Text_Parsing_StringParser_CodePoints["char"]("y"));
  var cutTime = Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(new Data_Maybe.Just(new Data_Tuple.Tuple(2, 2)))(Text_Parsing_StringParser_CodePoints.string("C|"));
  var crlf = Text_Parsing_StringParser_Combinators.withError(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)("\x0a")(endOfLine))("expected crlf");
  var eol = Control_Alt.alt(Text_Parsing_StringParser.altParser)(newline)(crlf);
  var counted = function (num) {
      return function (parser) {
          return Data_Unfoldable1.replicate1A(Text_Parsing_StringParser.applyParser)(Data_List_Types.unfoldable1NonEmptyList)(Data_List_Types.traversable1NonEmptyList)(num)(parser);
      };
  };
  var continuation = Text_Parsing_StringParser_Combinators.withError(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.Continuation.create)(Text_Parsing_StringParser_CodePoints["char"]("\\")))(Text_Parsing_StringParser_CodePoints.regex("[^\x0d\x0a]*")))(eol))("continuation");
  var composer = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Composer.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("C"))(strToEol)))("C header");
  var commonTime = Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(new Data_Maybe.Just(new Data_Tuple.Tuple(4, 4)))(Text_Parsing_StringParser_CodePoints["char"]("C"));
  var comment = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Comment.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(Text_Parsing_StringParser_CodePoints.regex("%"))(strToEol)))("comment");
  var chordSymbol = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.ChordSymbol.create)(literalQuotedString))("chord symbol");
  var buildVoice = function (code) {
      return function (id) {
          return function (properties) {
              return new Data_Abc.Voice({
                  id: id,
                  properties: properties
              });
          };
      };
  };
  var buildTupletSignature = function (ps) {
      return function (mq) {
          return function (mr) {
              var p = toTupletInt(ps);
              var qdefault = (function () {
                  if (p === 2) {
                      return 3;
                  };
                  if (p === 3) {
                      return 2;
                  };
                  if (p === 4) {
                      return 3;
                  };
                  if (p === 6) {
                      return 2;
                  };
                  if (p === 8) {
                      return 3;
                  };
                  return 2;
              })();
              var q = Data_Maybe.fromMaybe(qdefault)(Data_Functor.map(Data_Maybe.functorMaybe)(toTupletInt)(mq));
              var r = Data_Maybe.fromMaybe(p)(Data_Functor.map(Data_Maybe.functorMaybe)(toTupletInt)(mr));
              return {
                  p: p,
                  q: q,
                  r: r
              };
          };
      };
  };
  var tupletSignature = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildTupletSignature)(tupletLength))(tup))(tup))(whiteSpace);
  var buildTempoSignature3 = function (bpm) {
      var noteLengths = Data_List_NonEmpty.singleton(Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(1)(4));
      return {
          noteLengths: noteLengths,
          bpm: bpm,
          marking: Data_Maybe.Nothing.value
      };
  };
  var buildTempoSignature = function (marking) {
      return function (td) {
          return {
              noteLengths: td.value0,
              bpm: td.value1,
              marking: marking
          };
      };
  };
  var buildTempoSignature2 = function (marking) {
      return function (td) {
          return buildTempoSignature(new Data_Maybe.Just(marking))(td);
      };
  };
  var buildRest = function (r) {
      return {
          duration: r
      };
  };
  var buildRationalFromSlashList = function (xs) {
      var f = function (i) {
          return Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(1)(Data_Int.pow(2)(i));
      };
      return f(Data_List_NonEmpty.length(xs));
  };
  var manySlashes = Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildRationalFromSlashList)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_List_NonEmpty.cons)(Text_Parsing_StringParser_CodePoints["char"]("/")))(Text_Parsing_StringParser_Combinators.many1(Text_Parsing_StringParser_CodePoints["char"]("/"))));
  var buildPitch = function (a) {
      return function (pitchStr) {
          return new Data_Abc.Pitch({
              pitchClass: lookupPitch(pitchStr),
              accidental: a
          });
      };
  };
  var buildNote = function (macc) {
      return function (pitchStr) {
          return function (octave) {
              return function (ml) {
                  return function (mt) {
                      var tied = (function () {
                          if (mt instanceof Data_Maybe.Just) {
                              return true;
                          };
                          return false;
                      })();
                      var spn = scientificPitchNotation(pitchStr)(octave);
                      var pc = lookupPitch(Data_String_Common.toUpper(pitchStr));
                      var l = Data_Maybe.fromMaybe(Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(1)(1))(ml);
                      var acc = (function () {
                          if (macc instanceof Data_Maybe.Nothing) {
                              return Data_Abc.Implicit.value;
                          };
                          if (macc instanceof Data_Maybe.Just) {
                              return macc.value0;
                          };
                          throw new Error("Failed pattern match at Data.Abc.Parser (line 1217, column 7 - line 1219, column 20): " + [ macc.constructor.name ]);
                      })();
                      return {
                          pitchClass: pc,
                          accidental: acc,
                          octave: spn,
                          duration: l,
                          tied: tied
                      };
                  };
              };
          };
      };
  };
  var buildKeySignature = function (pStr) {
      return function (ma) {
          return function (mm) {
              return {
                  pitchClass: lookupPitch(pStr),
                  accidental: ma,
                  mode: Data_Maybe.fromMaybe(Data_Abc.Major.value)(mm)
              };
          };
      };
  };
  var buildKey = function (code) {
      return function (ks) {
          return function (pitches) {
              return new Data_Abc.Key({
                  keySignature: ks,
                  modifications: pitches
              });
          };
      };
  };
  var buildGraceableNote = function (maybeGrace) {
      return function (leftSlurs) {
          return function (decs) {
              return function (n) {
                  return function (rightSlurs) {
                      return {
                          maybeGrace: maybeGrace,
                          leftSlurs: leftSlurs,
                          decorations: decs,
                          abcNote: n,
                          rightSlurs: rightSlurs
                      };
                  };
              };
          };
      };
  };
  var buildGrace = function (isAcciaccatura) {
      return function (ns) {
          return {
              isAcciaccatura: isAcciaccatura,
              notes: ns
          };
      };
  };
  var buildChord = function (ns) {
      return function (ml) {
          var l = Data_Maybe.fromMaybe(Data_Rational.fromInt(1))(ml);
          return {
              notes: ns,
              duration: l
          };
      };
  };
  var buildBrokenOperator = function (s) {
      var $31 = Data_String_Utils.startsWith("<")(s);
      if ($31) {
          return new Data_Abc.LeftArrow(Data_String_CodePoints.length(s));
      };
      return new Data_Abc.RightArrow(Data_String_CodePoints.length(s));
  };
  var buildBarline = function (s) {
      return function (i) {
          var thickness = (function () {
              var $32 = Data_String_Utils.includes("|]")(s);
              if ($32) {
                  return Data_Abc.ThinThick.value;
              };
              var $33 = Data_String_Utils.includes("[|")(s);
              if ($33) {
                  return Data_Abc.ThickThin.value;
              };
              var $34 = Data_String_Utils.includes("||")(s);
              if ($34) {
                  return Data_Abc.ThinThin.value;
              };
              return Data_Abc.Thin.value;
          })();
          var f = function (c) {
              if (c === "[") {
                  return "|";
              };
              if (c === "]") {
                  return "|";
              };
              return c;
          };
          var normalised = Data_Functor.map(Data_Functor.functorArray)(f)(Data_String_CodeUnits.toCharArray(s));
          var repeatCount = Data_Array.length(Data_Array.filter(function (c) {
              return c === ":";
          })(normalised));
          var repeat = (function () {
              var $36 = repeatCount === 0;
              if ($36) {
                  return Data_Maybe.Nothing.value;
              };
              var $37 = repeatCount === 1;
              if ($37) {
                  var $38 = Data_String_Utils.includes(":|")(Data_String_CodeUnits.fromCharArray(normalised));
                  if ($38) {
                      return new Data_Maybe.Just(Data_Abc.End.value);
                  };
                  return new Data_Maybe.Just(Data_Abc.Begin.value);
              };
              return new Data_Maybe.Just(Data_Abc.BeginAndEnd.value);
          })();
          return {
              thickness: thickness,
              repeat: repeat,
              iteration: i
          };
      };
  };
  var buildBarTypeRecord = function (t) {
      return function (r) {
          return function (i) {
              return {
                  thickness: t,
                  repeat: r,
                  iteration: i
              };
          };
      };
  };
  var buildBar = function (bt) {
      return function (m) {
          return {
              startLine: bt,
              music: m
          };
      };
  };
  var buildAnnotation = function (s) {
      var firstChar = Data_String_CodeUnits.charAt(0)(s);
      var placement = (function () {
          if (firstChar instanceof Data_Maybe.Just && firstChar.value0 === "^") {
              return Data_Abc.AboveNextSymbol.value;
          };
          if (firstChar instanceof Data_Maybe.Just && firstChar.value0 === "_") {
              return Data_Abc.BelowNextSymbol.value;
          };
          if (firstChar instanceof Data_Maybe.Just && firstChar.value0 === "<") {
              return Data_Abc.LeftOfNextSymbol.value;
          };
          if (firstChar instanceof Data_Maybe.Just && firstChar.value0 === ">") {
              return Data_Abc.RightOfNextSymbol.value;
          };
          return Data_Abc.Discretional.value;
      })();
      return new Data_Abc.Annotation(placement, Data_String_CodePoints.drop(1)(s));
  };
  var buildAccidental = function (s) {
      if (s === "^^") {
          return Data_Abc.DoubleSharp.value;
      };
      if (s === "__") {
          return Data_Abc.DoubleFlat.value;
      };
      if (s === "^") {
          return Data_Abc.Sharp.value;
      };
      if (s === "_") {
          return Data_Abc.Flat.value;
      };
      return Data_Abc.Natural.value;
  };
  var buildAbcTune = function (hs) {
      return function (b) {
          return {
              headers: hs,
              body: b
          };
      };
  };
  var brokenRhythmOperator = Text_Parsing_StringParser_CodePoints.regex("(<+|>+)");
  var brokenRhythmTie = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildBrokenOperator)(brokenRhythmOperator))(whiteSpace);
  var book = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Book.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("B"))(strToEol)))("B Header");
  var barSeparator = Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ Text_Parsing_StringParser_CodePoints.string("[|"), Text_Parsing_StringParser_CodePoints.string("|]:"), Text_Parsing_StringParser_CodePoints.string("|]"), Text_Parsing_StringParser_CodePoints.string("]|:"), Text_Parsing_StringParser_CodePoints.string("]|"), Text_Parsing_StringParser_CodePoints.string(":[|"), Text_Parsing_StringParser_CodePoints.string("|:"), Text_Parsing_StringParser_CodePoints.string(":|:"), Text_Parsing_StringParser_CodePoints.string(":||:"), Text_Parsing_StringParser_CodePoints.string(":|]"), Text_Parsing_StringParser_CodePoints.string(":||"), Text_Parsing_StringParser_CodePoints.string(":|"), Text_Parsing_StringParser_CodePoints.string("::"), Text_Parsing_StringParser_CodePoints.string("||:"), Text_Parsing_StringParser_CodePoints.string("||"), Text_Parsing_StringParser_CodePoints.string("|") ]);
  var area = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Area.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("A"))(strToEol)))("A header");
  var anyInt = Text_Parsing_StringParser_CodePoints.regex("(0|[1-9][0-9]*)");
  var $$int = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Functor.map(Data_Functor.functorFn)(Data_Maybe.fromMaybe(1))(Data_Int.fromString))(anyInt))("expected a positive integer");
  var anyRat = Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(Text_Parsing_StringParser_Combinators.option(1)($$int)))(Text_Parsing_StringParser_CodePoints["char"]("/")))(Text_Parsing_StringParser_Combinators.option(2)($$int));
  var degenerateBarRepeat = Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildBarTypeRecord(Data_Abc.Thin.value)(Data_Maybe.Nothing.value))(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Maybe.Just.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(whiteSpace)(Text_Parsing_StringParser_CodePoints["char"]("[")))($$int)));
  var degenerateTempo = Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildTempoSignature3)($$int);
  var integralAsRational = Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Rational.fromInt)($$int);
  var noteDur = Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ Text_Parsing_StringParser["try"](manySlashes), Text_Parsing_StringParser["try"](anyRat), integralAsRational ]);
  var meterSignature = Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Maybe.Just.create)(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Tuple.Tuple.create)($$int))(Text_Parsing_StringParser_CodePoints["char"]("/")))($$int))(whiteSpace));
  var meterDefinition = Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ cutTime, commonTime, meterSignature, nometer ]);
  var meter = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Meter.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("M"))(meterDefinition)))("M header");
  var rational = Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))($$int))(Text_Parsing_StringParser_CodePoints["char"]("/")))($$int);
  var headerRational = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(rational)(whiteSpace);
  var noteDuration = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(rational)(whiteSpace);
  var unitNoteLength = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.UnitNoteLength.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("L"))(noteDuration)))("L header");
  var referenceNumber = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.ReferenceNumber.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("X"))(Text_Parsing_StringParser_Combinators.optionMaybe($$int))))("x header");
  var tuneInfo = Text_Parsing_StringParser_Combinators.withError(Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ area, book, composer, discography, fileUrl, group, history, origin, source, referenceNumber, transcription, unsupportedHeader ]))("tune info");
  var repeatSection = $$int;
  var normalBarline = Text_Parsing_StringParser_Combinators.withError(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildBarline)(barSeparator))(Text_Parsing_StringParser_Combinators.optionMaybe(repeatSection)))("bartype");
  var barline = Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ normalBarline, degenerateBarRepeat ]);
  var tempoDesignation = Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(TempoDesignation.create)(Text_Parsing_StringParser_Combinators.many1(headerRational)))(Text_Parsing_StringParser_CodePoints["char"]("=")))($$int);
  var prefixedTempoDesignation = Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildTempoSignature2)(spacedQuotedString))(tempoDesignation);
  var suffixedTempoDesignation = Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Function.flip(buildTempoSignature2))(tempoDesignation))(spacedQuotedString);
  var unlabelledTempoDesignation = Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildTempoSignature(Data_Maybe.Nothing.value))(tempoDesignation);
  var tempoSignature = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ Text_Parsing_StringParser["try"](suffixedTempoDesignation), Text_Parsing_StringParser["try"](unlabelledTempoDesignation), degenerateTempo, prefixedTempoDesignation ]))(whiteSpace);
  var tempo = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Tempo.create)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(headerCode("Q"))(tempoSignature)))("Q header");
  var annotationString = Text_Parsing_StringParser_Combinators.withError(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(Text_Parsing_StringParser_CodePoints.string("\""))(Text_Parsing_StringParser_CodePoints.regex("[\\^\\>\\<-@](\\\\\"|[^\"\x0a])*")))(Text_Parsing_StringParser_CodePoints.string("\"")))("annotation");
  var annotation = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildAnnotation)(annotationString))("annotation");
  var alphaNumString = Data_Functor.map(Text_Parsing_StringParser.functorParser)((function () {
      var $55 = Data_Array.fromFoldable(Data_List_Types.foldableList);
      return function ($56) {
          return Data_String_CodeUnits.fromCharArray($55(Data_List_NonEmpty.toList($56)));
      };
  })())(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(whiteSpace)(Text_Parsing_StringParser_Combinators.many1(Control_Alt.alt(Text_Parsing_StringParser.altParser)(Control_Alt.alt(Text_Parsing_StringParser.altParser)(Text_Parsing_StringParser_CodePoints.alphaNum)(Text_Parsing_StringParser_CodePoints["char"]("-")))(Text_Parsing_StringParser_CodePoints["char"]("+")))));
  var kvPair = Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Tuple.Tuple.create)(alphaNumString))(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(Text_Parsing_StringParser_CodePoints["char"]("="))(Control_Alt.alt(Text_Parsing_StringParser.altParser)(literalQuotedString)(alphaNumString)));
  var voiceProperties = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Map_Internal.fromFoldable(Data_Ord.ordString)(Data_List_Types.foldableList))(Text_Parsing_StringParser_Combinators.many(kvPair)))(whiteSpace);
  var voice = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildVoice)(headerCode("V")))(alphaNumString))(voiceProperties))("V header");
  };
  var aeolian = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.voidRight(Text_Parsing_StringParser.functorParser)(Data_Abc.Aeolian.value)(whiteSpace))(Text_Parsing_StringParser_CodePoints.regex("[A|a][E|e][O|o][A-Za-z]*"));
  var mode = Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ Text_Parsing_StringParser["try"](major), ionian, dorian, phrygian, lydian, mixolydian, aeolian, locrian, minor ]);
  var keySignature = Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildKeySignature)(keyName))(Text_Parsing_StringParser_Combinators.option(Data_Abc.Natural.value)(sharpOrFlat)))(whiteSpace))(Text_Parsing_StringParser_Combinators.optionMaybe(mode));
  var accidental = Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildAccidental)(Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ Text_Parsing_StringParser_CodePoints.string("^^"), Text_Parsing_StringParser_CodePoints.string("__"), Text_Parsing_StringParser_CodePoints.string("^"), Text_Parsing_StringParser_CodePoints.string("_"), Text_Parsing_StringParser_CodePoints.string("=") ]));
  var keyAccidental = Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildPitch)(accidental))(pitch);
  var keyAccidentals = Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(whiteSpace)(Text_Parsing_StringParser_Combinators.sepBy(keyAccidental)(space));
  var key = Text_Parsing_StringParser_Combinators.withError(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildKey)(headerCode("K")))(keySignature))(keyAccidentals))("K header");
  var anywhereInfo = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ instruction(isInline), key, unitNoteLength, meter, macro(isInline), notes(isInline), parts(isInline), tempo, rhythm(isInline), remark(isInline), title(isInline), userDefined(isInline), voice(isInline), wordsAfter(isInline), fieldContinuation, comment ]))("anywhere info");
  };
  var informationField = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ anywhereInfo(isInline), tuneInfo ]))("header");
  };
  var header = Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(informationField(false))(eol);
  var headers = Text_Parsing_StringParser_Combinators.withError(Text_Parsing_StringParser_Combinators.many(header))("headers");
  var tuneBodyInfo = function (isInline) {
      return Text_Parsing_StringParser_Combinators.withError(Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ tuneBodyOnlyInfo(isInline), anywhereInfo(isInline) ]))("tune body info");
  };
  var inline = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Inline.create)(Text_Parsing_StringParser_Combinators.between(Text_Parsing_StringParser_CodePoints["char"]("["))(Text_Parsing_StringParser_CodePoints["char"]("]"))(tuneBodyInfo(true))))("inline header");
  var tuneBodyHeader = Text_Parsing_StringParser_Combinators.withError(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.BodyInfo.create)(tuneBodyInfo(true)))(eol))("tune body header");
  var maybeAccidental = Text_Parsing_StringParser_Combinators.optionMaybe(accidental);
  var acciaccatura = Data_Functor.map(Text_Parsing_StringParser.functorParser)(function (v) {
      return true;
  })(Text_Parsing_StringParser_Combinators.optionMaybe(Text_Parsing_StringParser_CodePoints["char"]("/")));
  var abcRest = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildRest)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Maybe.fromMaybe(Data_Rational.fromInt(1)))(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(Text_Parsing_StringParser_CodePoints.regex("[XxZz]"))(Text_Parsing_StringParser_Combinators.optionMaybe(noteDur)))))("abcRest");
  var rest = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Rest.create)(abcRest))("rest");
  var abcNote = Text_Parsing_StringParser_Combinators.withError(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildNote)(maybeAccidental))(pitch))(moveOctave))(Text_Parsing_StringParser_Combinators.optionMaybe(noteDur)))(maybeTie))("ABC note");
  var grace = Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildGrace)(acciaccatura))(Text_Parsing_StringParser_Combinators.many1(abcNote));
  var graceBracket = Text_Parsing_StringParser_Combinators.withError(Text_Parsing_StringParser_Combinators.between(Text_Parsing_StringParser_CodePoints["char"]("{"))(Text_Parsing_StringParser_CodePoints["char"]("}"))(grace))("grace bracket");
  var graceableNote = Text_Parsing_StringParser_Combinators.withError(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildGraceableNote)(Text_Parsing_StringParser_Combinators.optionMaybe(graceBracket)))(leftSlurBrackets))(decorations))(abcNote))(rightSlurBrackets))("graceable note");
  var brokenRhythmPair = Text_Parsing_StringParser_Combinators.withError(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.BrokenRhythmPair.create)(graceableNote))(brokenRhythmTie))(graceableNote))("broken rhythm pair");
  var note = Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Note.create)(graceableNote);
  var restOrNote = Control_Alt.alt(Text_Parsing_StringParser.altParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Either.Left.create)(abcRest))(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Either.Right.create)(graceableNote))(whiteSpace));
  var tuplet = Control_Bind.bind(Text_Parsing_StringParser.bindParser)(Text_Parsing_StringParser_Combinators.optionMaybe(graceBracket))(function (v) {
      return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(Text_Parsing_StringParser_CodePoints["char"]("("))(tupletSignature))(function (v1) {
          return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(counted(v1.r)(restOrNote))(function (v2) {
              return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(new Data_Abc.Tuplet(v, v1, v2));
          });
      });
  });
  var abcChord = Text_Parsing_StringParser_Combinators.withError(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildChord)(Text_Parsing_StringParser_Combinators.between(Text_Parsing_StringParser_CodePoints["char"]("["))(Text_Parsing_StringParser_CodePoints["char"]("]"))(Text_Parsing_StringParser_Combinators.many1(abcNote))))(Text_Parsing_StringParser_Combinators.optionMaybe(noteDur)))("ABC chord");
  var chord = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Chord.create)(abcChord))("chord");
  var scoreItem = Text_Parsing_StringParser_Combinators.withError(Text_Parsing_StringParser_Combinators.choice(Data_Foldable.foldableArray)([ Text_Parsing_StringParser["try"](chord), Text_Parsing_StringParser["try"](inline), continuation, Text_Parsing_StringParser["try"](decoratedSpace), ignore, spacer, Text_Parsing_StringParser["try"](annotation), chordSymbol, Text_Parsing_StringParser["try"](tuplet), rest, Text_Parsing_StringParser["try"](brokenRhythmPair), note ]))("score item");
  var bar = Text_Parsing_StringParser_Combinators.withError(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildBar)(barline))(Text_Parsing_StringParser_Combinators.many(scoreItem)))("bar");
  var fullyBarredLine = Text_Parsing_StringParser_Combinators.withError(manyTill1(bar)(eol))("fully barred line");
  var introBar = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildBar(invisibleBarType))(Text_Parsing_StringParser_Combinators.many(scoreItem)))("intro bar");
  var introLine = Text_Parsing_StringParser_Combinators.withError(Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_List_Types.Cons.create)(introBar))(manyTill1(bar)(eol)))("intro line");
  var score = Text_Parsing_StringParser_Combinators.withError(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Abc.Score.create)(Control_Alt.alt(Text_Parsing_StringParser.altParser)(introLine)(fullyBarredLine)))("score");
  var body = Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_List_Types.Cons.create)(score))(Text_Parsing_StringParser_Combinators.manyTill(Control_Alt.alt(Text_Parsing_StringParser.altParser)(Text_Parsing_StringParser["try"](tuneBodyHeader))(score))(Text_Parsing_StringParser_CodePoints.eof));
  var abc = Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(buildAbcTune)(headers))(body);
  var parse = function (s) {
      var v = runParser1(abc)(s);
      if (v instanceof Data_Either.Right) {
          return new Data_Either.Right(v.value0);
      };
      if (v instanceof Data_Either.Left) {
          return new Data_Either.Left(v.value0);
      };
      throw new Error("Failed pattern match at Data.Abc.Parser (line 1517, column 5 - line 1522, column 19): " + [ v.constructor.name ]);
  };
  exports["parse"] = parse;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Data.Identity"] = $PS["Data.Identity"] || {};
  var exports = $PS["Data.Identity"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Newtype = $PS["Data.Newtype"];          
  var Identity = function (x) {
      return x;
  };
  var newtypeIdentity = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Identity);
  var functorIdentity = new Data_Functor.Functor(function (f) {
      return function (m) {
          return f(m);
      };
  });
  var applyIdentity = new Control_Apply.Apply(function () {
      return functorIdentity;
  }, function (v) {
      return function (v1) {
          return v(v1);
      };
  });
  var bindIdentity = new Control_Bind.Bind(function () {
      return applyIdentity;
  }, function (v) {
      return function (f) {
          return f(v);
      };
  });
  var applicativeIdentity = new Control_Applicative.Applicative(function () {
      return applyIdentity;
  }, Identity);
  var monadIdentity = new Control_Monad.Monad(function () {
      return applicativeIdentity;
  }, function () {
      return bindIdentity;
  });
  exports["newtypeIdentity"] = newtypeIdentity;
  exports["functorIdentity"] = functorIdentity;
  exports["monadIdentity"] = monadIdentity;
})(PS);
(function(exports) {
  "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };
})(PS["Effect"] = PS["Effect"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Effect"] = $PS["Effect"] || {};
  var exports = $PS["Effect"];
  var $foreign = $PS["Effect"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Functor = $PS["Data.Functor"];                    
  var monadEffect = new Control_Monad.Monad(function () {
      return applicativeEffect;
  }, function () {
      return bindEffect;
  });
  var bindEffect = new Control_Bind.Bind(function () {
      return applyEffect;
  }, $foreign.bindE);
  var applyEffect = new Control_Apply.Apply(function () {
      return functorEffect;
  }, Control_Monad.ap(monadEffect));
  var applicativeEffect = new Control_Applicative.Applicative(function () {
      return applyEffect;
  }, $foreign.pureE);
  var functorEffect = new Data_Functor.Functor(Control_Applicative.liftA1(applicativeEffect));
  exports["applicativeEffect"] = applicativeEffect;
})(PS);
(function(exports) {
  "use strict";

  exports.log = function (s) {
    return function () {
      console.log(s);
      return {};
    };
  };
})(PS["Effect.Console"] = PS["Effect.Console"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Effect.Console"] = $PS["Effect.Console"] || {};
  var exports = $PS["Effect.Console"];
  var $foreign = $PS["Effect.Console"];
  exports["log"] = $foreign.log;
})(PS);
(function($PS) {
  "use strict";
  $PS["Examples.Slurs.Texts"] = $PS["Examples.Slurs.Texts"] || {};
  var exports = $PS["Examples.Slurs.Texts"];
  var slurs2 = "X:1\x0d\x0a" + ("T: double bar line\x0d\x0a" + ("M: 4/4\x0d\x0a" + ("L: 1/8\x0d\x0a" + ("K: D\x0d\x0a" + "| C2 (F2G2) A2 | (G2 F2 (=EB) cd) | (C2 (3D2E2F2) G2 |\x0d\x0a"))));
  var slurs1 = "X:1\x0d\x0a" + ("T: slurs\x0d\x0a" + ("M: 3/4\x0d\x0a" + ("L: 1/16\x0d\x0a" + ("K: C\x0d\x0a" + "| (A2B2)c2d2 (e2f2g2a2 | (a2g2f2e2) (d2c2BA) (GF) |\x0d\x0a"))));
  var brokenRhythmSlurs = "X:1\x0d\x0a" + ("T: slurs\x0d\x0a" + ("M: 3/4\x0d\x0a" + ("L: 1/16\x0d\x0a" + ("K: C\x0d\x0a" + "| (A2>B2) (g4 f2>g2) |\x0d\x0a"))));
  exports["slurs1"] = slurs1;
  exports["slurs2"] = slurs2;
  exports["brokenRhythmSlurs"] = brokenRhythmSlurs;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["VexFlow.Abc.Beat"] = $PS["VexFlow.Abc.Beat"] || {};
  var exports = $PS["VexFlow.Abc.Beat"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ratio = $PS["Data.Ratio"];                
  var exactBeatNumber = function (phraseDur) {
      return function (beatDur) {
          return function (noteIndex) {
              var beats = Data_EuclideanRing.div(Data_Ratio.euclideanRingRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(phraseDur)(beatDur);
              var v = Data_Ratio.denominator(beats);
              if (v === 1) {
                  return Data_Maybe.Just.create({
                      beatNumber: Data_Ratio.numerator(beats),
                      noteIndex: noteIndex
                  });
              };
              return Data_Maybe.Nothing.value;
          };
      };
  };
  var beatDuration = function (ts) {
      if (ts.numerator === 3 && ts.denominator === 2) {
          return Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(1)(4);
      };
      if (ts.numerator === 6 && ts.denominator === 8) {
          return Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(3)(8);
      };
      if (ts.numerator === 9 && ts.denominator === 8) {
          return Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(3)(8);
      };
      if (ts.numerator === 12 && ts.denominator === 8) {
          return Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(3)(8);
      };
      return Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(1)(ts.denominator);
  };
  exports["beatDuration"] = beatDuration;
  exports["exactBeatNumber"] = exactBeatNumber;
})(PS);
(function(exports) {
  "use strict";

  var wrapper = function() {

    var VF = null;
    /*
  var renderer = null;
  var context = null;
  */  

    return {

      initialiseCanvas : function (config) {
        return function () {
          return wrapper.init(config);
        }
      },

      resizeCanvas : function (renderer) {
        return function (config) {
          return function () {
            return wrapper.reinitCanvas(renderer, config);
          }
        }
      },

      clearCanvas : function (renderer) {
        return function () {
          var context = renderer.getContext();
        context.clear();
        }
      },

      newStaveImpl : function (staveConfig) {
        return function (keySignature) {
          return function () {
            return wrapper.makeStave(staveConfig, keySignature);
          }
        }
      },

      displayBarBeginRepeat : function (stave) {
        return function () {
          stave.setBegBarType(VF.Barline.type.REPEAT_BEGIN);
        }
      },

      displayBarEndRepeat : function (stave) {
        return function () {
          stave.setEndBarType(VF.Barline.type.REPEAT_END);
        }
      },

      displayBarBothRepeat : function (stave) {
        return function () {
          stave.setBegBarType(VF.Barline.type.REPEAT_BEGIN);
          stave.setEndBarType(VF.Barline.type.REPEAT_END);
        }
      },

      displayVolta : function (stave) {
        return function (volta) {
          return function () {
            return wrapper.drawVolta(stave, volta);
          }
        }
      },

      renderStave : function (renderer) {
        return function (stave) {
          return function () {
            return wrapper.drawStave(renderer, stave);
          }
        }
      },

      getStaveWidth : function (stave) {
        return function () {
          return stave.getWidth();
        }
      },

      addTimeSignature : function (stave) {
        return function (timeSignature) {
          return function () {
            return wrapper.drawTimeSignature(stave, timeSignature);
          }
        }
      },

      addKeySignature : function (stave) {
        return function (keySignature) {
          return function () {
            return wrapper.drawKeySignature(stave, keySignature, false);
          }
        }
      },

      addTempoMarkingImpl : function (stave) {
        return function (tempo) {
          return function () {
            return wrapper.drawTempoMarking(stave, tempo);
          }
        }
      },

      renderBarContents : function (renderer) {
        return function (stave) {
          return function (beamSpecs) {
            return function (vexCurves) {
              return function (musicSpec) {
                return function () {
                  return wrapper.drawBarContents(renderer, stave, beamSpecs, vexCurves, musicSpec);
                }
              }
            }
          }
        }
      },

      init: function (config) {
        // console.log(config);

        VF = Vex.Flow;
        var renderer

        if (config.isSVG) {
          renderer = new VF.Renderer(config.parentElementId , VF.Renderer.Backends.SVG);
        } else {
          renderer = new VF.Renderer(config.parentElementId , VF.Renderer.Backends.CANVAS);
        }

        // Size our svg:
        renderer.resize(config.width, config.height);

        var context = renderer.getContext();
        context.scale(config.scale, config.scale);

        return renderer;
      },

      reinitCanvas: function (renderer, config) {
          // Size our svg:
          renderer.resize(config.width, config.height);

          var context = renderer.getContext();
          context.scale(config.scale, config.scale);
        },

      makeStave: function (staveConfig, keySignature) {

        var staveOptions = new Object();
        staveOptions.right_bar = staveConfig.hasRightBar;

        // Create a stave at the required position on the canvas.
        var stave = new VF.Stave(staveConfig.x, staveConfig.y, staveConfig.width, staveOptions);

        // create a doubled right bar line if required
        if (staveConfig.hasDoubleRightBar) {
           stave.setEndBarType(VF.Barline.type.DOUBLE);
        }

        // Add a clef and key signature if it's the first bar in the stave
        if (staveConfig.barNo == 0) {
          wrapper.drawKeySignature (stave, keySignature, true);
        }

        return stave;
      },

      drawStave: function (renderer, stave) {
        var context = renderer.getContext();
        stave.setContext(context).draw();
      },

      drawTimeSignature: function (stave, timeSignature) {
        var meter = timeSignature.numerator + "/" + timeSignature.denominator;
        stave.setTimeSignature(meter);
      },

      drawVolta: function (stave, volta) {
        // console.log("volta:")
        // console.log(volta);
        var voltaType;
        switch(volta.voltaType) {
          case 2:
            voltaType = VF.Volta.type.BEGIN;
            break;
          case 3:
            voltaType = VF.Volta.type.MID;
            break;
          case 4:
            voltaType = VF.Volta.type.END;
            break;
          case 5:
            voltaType = VF.Volta.type.BEGIN_END;
            break;
          default:
            voltaType = VF.Volta.type.NONE;
        }
        stave.setVoltaType(voltaType, volta.iteration, 30);
      },

      drawKeySignature: function (stave, keySignature, withClef) {
        if (withClef) {
          stave.addClef("treble");
        }
        stave.setKeySignature(keySignature);
      },

      drawTempoMarking: function (stave, tempo) {
        stave.setTempo(tempo, 0);
      },

      /* draw the contents of the bar, using auto-beaming for the notes */
      drawBarContents: function (renderer, stave, beamSpecs, vexCurves, musicSpec) {
        // console.log("drawBarContents")
        // console.log(musicSpec);
        var context = renderer.getContext();
        var notes = musicSpec.noteSpecs.map(wrapper.makeStaveNote);
        var tuplets = musicSpec.tuplets.map(wrapper.makeTupletLayout (notes));
        var ties = musicSpec.ties.map(wrapper.makeTie (notes));
        console.log("beamSpecs");
        console.log(beamSpecs);
        var beams = beamSpecs.map(wrapper.makeBeam (notes));
        var curves = vexCurves.map(wrapper.makeCurve (notes));

        Vex.Flow.Formatter.FormatAndDraw(context, stave, notes);
        ties.forEach(function(t) {t.setContext(context).draw()})
        beams.forEach(function(b) {b.setContext(context).draw()});
        tuplets.forEach(function(tuplet){
          tuplet.setContext(context).draw();
        });
        curves.forEach(function(c) {c.setContext(context).draw()});
      },


      // make a stave note (n.b. this can represent a single note or a chord)
      makeStaveNote: function (noteSpec) {
        var sn = new VF.StaveNote(noteSpec.vexNote);
        wrapper.addAccidentals (sn, noteSpec.accidentals);
        wrapper.addDots (sn, noteSpec.dots);
        wrapper.addOrnaments (sn, noteSpec.ornaments);
        wrapper.addArticulations (sn, noteSpec.articulations);

        if (noteSpec.graceKeys.length > 0) {
          var graceNotes = noteSpec.graceKeys.map(wrapper.makeGraceNote);
          wrapper.addGraceAccidentals (graceNotes, noteSpec.graceAccidentals);
          var graceNoteGroup =  new VF.GraceNoteGroup(graceNotes, true);
          sn.addModifier(0, graceNoteGroup.beamNotes());
        }
        return sn;
      },

      makeGraceNote: function (graceKey) {
        var note = { keys: [graceKey], duration: '8' };
        return new Vex.Flow.GraceNote( note);
      },

      // make a tuplet layout
      makeTupletLayout: function (notes) {
        return function (vexTuplet) {
          return new Vex.Flow.Tuplet(notes.slice(vexTuplet.startPos, vexTuplet.endPos), {
             num_notes: vexTuplet.p, notes_occupied: vexTuplet.q
           });
        };
      },

      // make a beam between the specified notes
      makeBeam: function (notes) {
        return function (beamSpec) {
          return new Vex.Flow.Beam(notes.slice(beamSpec[0], beamSpec[1]), true);
        };
      },


      // tie a note to its successor
      makeTie: function (notes) {
        return function (noteIndex) {
          return new VF.StaveTie({
            first_note: notes[noteIndex],
            last_note: notes[noteIndex + 1],
            first_indices: [0],
            last_indices: [0]
          });
        };
      },

      // make a slur represented by a curve
      makeCurve: function (notes) {
        return function (vexCurve) {
          // the slope of the curve is just a simple heuristic
          var controlPoints = [{ x: 0, y: 5 }, { x: 0, y: 5 }]
          if (vexCurve.to - vexCurve.from > 1 ) {
            controlPoints = [{ x: 0, y: 10 }, { x: 0, y: 10 }]
          }
          return new VF.Curve(
            notes[vexCurve.from],
            notes[vexCurve.to],
            { thickness: 2,
              cps: controlPoints
          });
        };
      },

      // add the accidental(s) to the staveNote
      addAccidentals: function (staveNote, accidentals) {
        accidentals.forEach (function (accidentalString, index) {
          if (accidentalString) {
            staveNote.addAccidental(index, new VF.Accidental(accidentalString));
          }
        });
      },

      // add any accidentals to the grace notes
      addGraceAccidentals: function (graceNotes, accidentals) {
        accidentals.forEach (function (accidentalString, index) {
          if (accidentalString) {
            graceNotes[index].addAccidental(index, new VF.Accidental(accidentalString));
          }
        });
      },

      // add the dottedness to the staveNote
      addDots: function (staveNote, dots) {
        dots.forEach (function (dotCount, index) {
          if (dotCount == 2) {
            staveNote.addDot(index).addDot(index);
          }
          else if (dotCount == 1) {
            staveNote.addDot(index);
          }
        });
      },

      // add the ornamant(s) to the staveNote
      addOrnaments: function (staveNote, ornaments) {
        ornaments.forEach (function (ornament, index) {
          staveNote.addModifier(0, new VF.Ornament(ornament));
        });
      },

      // add the articulation(s) to the staveNote
      addArticulations: function (staveNote, articulations) {
        articulations.forEach (function (articulation, index) {
          staveNote.addArticulation(0, new VF.Articulation(articulation));
        });
      }

    }

  }();

  exports.initialiseCanvas = wrapper.initialiseCanvas;
  exports.newStaveImpl = wrapper.newStaveImpl;
  exports.renderStave = wrapper.renderStave;    
  exports.displayBarBeginRepeat = wrapper.displayBarBeginRepeat;
  exports.displayBarEndRepeat = wrapper.displayBarEndRepeat;  
  exports.renderBarContents = wrapper.renderBarContents;
  exports.displayVolta = wrapper.displayVolta;
  exports.addTimeSignature = wrapper.addTimeSignature;
  exports.addKeySignature = wrapper.addKeySignature;
  exports.addTempoMarkingImpl = wrapper.addTempoMarkingImpl;
})(PS["VexFlow.Score"] = PS["VexFlow.Score"] || {});
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["VexFlow.Abc.ContextChange"] = $PS["VexFlow.Abc.ContextChange"] || {};
  var exports = $PS["VexFlow.Abc.ContextChange"];
  var MeterChange = (function () {
      function MeterChange(value0) {
          this.value0 = value0;
      };
      MeterChange.create = function (value0) {
          return new MeterChange(value0);
      };
      return MeterChange;
  })();
  var KeyChange = (function () {
      function KeyChange(value0) {
          this.value0 = value0;
      };
      KeyChange.create = function (value0) {
          return new KeyChange(value0);
      };
      return KeyChange;
  })();
  var UnitNoteChange = (function () {
      function UnitNoteChange(value0) {
          this.value0 = value0;
      };
      UnitNoteChange.create = function (value0) {
          return new UnitNoteChange(value0);
      };
      return UnitNoteChange;
  })();
  exports["MeterChange"] = MeterChange;
  exports["KeyChange"] = KeyChange;
  exports["UnitNoteChange"] = UnitNoteChange;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["VexFlow.Abc.Slur"] = $PS["VexFlow.Abc.Slur"] || {};
  var exports = $PS["VexFlow.Abc.Slur"];
  var Data_Array = $PS["Data.Array"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Tuple = $PS["Data.Tuple"];                
  var LeftBracket = (function () {
      function LeftBracket(value0) {
          this.value0 = value0;
      };
      LeftBracket.create = function (value0) {
          return new LeftBracket(value0);
      };
      return LeftBracket;
  })();
  var RightBracket = (function () {
      function RightBracket(value0) {
          this.value0 = value0;
      };
      RightBracket.create = function (value0) {
          return new RightBracket(value0);
      };
      return RightBracket;
  })();
  var SlurStack = (function () {
      function SlurStack(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      SlurStack.create = function (value0) {
          return function (value1) {
              return new SlurStack(value0, value1);
          };
      };
      return SlurStack;
  })();
  var pop = function (v) {
      if (v.value0 instanceof Data_List_Types.Nil) {
          return new Data_Tuple.Tuple(Data_Maybe.Nothing.value, new SlurStack(Data_List_Types.Nil.value, v.value1));
      };
      if (v.value0 instanceof Data_List_Types.Cons) {
          return new Data_Tuple.Tuple(new Data_Maybe.Just(v.value0.value0), new SlurStack(v.value0.value1, v.value1));
      };
      throw new Error("Failed pattern match at VexFlow.Abc.Slur (line 73, column 1 - line 73, column 56): " + [ v.constructor.name ]);
  };
  var push = function (slurStack) {
      return function ($$new) {
          if ($$new instanceof RightBracket) {
              var v = pop(slurStack);
              if (v.value0 instanceof Data_Maybe.Just && v.value0.value0 instanceof LeftBracket) {
                  return new SlurStack(v.value1.value0, Data_Array.cons({
                      from: v.value0.value0.value0,
                      to: $$new.value0
                  })(v.value1.value1));
              };
              if (v.value0 instanceof Data_Maybe.Just) {
                  return new SlurStack(new Data_List_Types.Cons($$new, new Data_List_Types.Cons(v.value0.value0, v.value1.value0)), v.value1.value1);
              };
              if (v.value0 instanceof Data_Maybe.Nothing) {
                  return new SlurStack(new Data_List_Types.Cons($$new, v.value1.value0), v.value1.value1);
              };
              throw new Error("Failed pattern match at VexFlow.Abc.Slur (line 59, column 9 - line 65, column 43): " + [ v.value0.constructor.name ]);
          };
          return new SlurStack(new Data_List_Types.Cons($$new, slurStack.value0), slurStack.value1);
      };
  }; 
  var empty = new SlurStack(Data_List_Types.Nil.value, [  ]);
  var vexCurves = function (brackets) {
      var v = Data_Foldable.foldl(Data_Foldable.foldableArray)(push)(empty)(brackets);
      return Data_Array.reverse(v.value1);
  };
  exports["LeftBracket"] = LeftBracket;
  exports["RightBracket"] = RightBracket;
  exports["vexCurves"] = vexCurves;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["VexFlow.Abc.TickableContext"] = $PS["VexFlow.Abc.TickableContext"] || {};
  var exports = $PS["VexFlow.Abc.TickableContext"];
  var Data_Abc = $PS["Data.Abc"];
  var Data_Abc_KeySignature = $PS["Data.Abc.KeySignature"];
  var Data_Either = $PS["Data.Either"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Int = $PS["Data.Int"];
  var Data_List = $PS["Data.List"];
  var Data_List_NonEmpty = $PS["Data.List.NonEmpty"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ratio = $PS["Data.Ratio"];
  var Data_Rational = $PS["Data.Rational"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Semiring = $PS["Data.Semiring"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];                
  var TickableContext = (function () {
      function TickableContext(value0, value1, value2) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
      };
      TickableContext.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return new TickableContext(value0, value1, value2);
              };
          };
      };
      return TickableContext;
  })();
  var tickableSemigroupCtx = new Data_Semigroup.Semigroup(function (v) {
      return function (v1) {
          return new TickableContext(v.value0 + v1.value0 | 0, v.value1 + v1.value1 | 0, Data_Semiring.add(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(v.value2)(v1.value2));
      };
  });
  var tickableMonoidCtx = new Data_Monoid.Monoid(function () {
      return tickableSemigroupCtx;
  }, new TickableContext(0, 0, Data_Rational.fromInt(0)));
  var tickableCountWidth = function (n) {
      if (n === 1) {
          return 1.5;
      };
      if (n === 2) {
          return 2.5;
      };
      return Data_Int.toNumber(n);
  };
  var pixelsPerItem = 35.0;
  var keySignatureWidth = function (keySignature) {
      var v = Data_List.length(Data_Abc_KeySignature.keySet(keySignature));
      if (v === 0) {
          return 0.0;
      };
      if (v === 1) {
          return 1.0;
      };
      if (v === 2) {
          return 1.0;
      };
      return 1.5;
  };
  var graceLength = function (maybeGraceNote) {
      return Data_Maybe.fromMaybe(0)(Data_Functor.map(Data_Maybe.functorMaybe)(function (g) {
          return Data_List_NonEmpty.length(g.notes);
      })(maybeGraceNote));
  };
  var getRorNsGraceLength = function (rOrNs) {
      var f = function (acc) {
          return function (rOrN) {
              if (rOrN instanceof Data_Either.Left) {
                  return 0 + acc | 0;
              };
              if (rOrN instanceof Data_Either.Right) {
                  return graceLength(rOrN.value0.maybeGrace) + acc | 0;
              };
              throw new Error("Failed pattern match at VexFlow.Abc.TickableContext (line 92, column 7 - line 95, column 53): " + [ rOrN.constructor.name ]);
          };
      };
      return Data_Foldable.foldl(Data_Foldable.foldableArray)(f)(0)(rOrNs);
  };
  var getRorNsDuration = function (rOrNs) {
      var f = function (acc) {
          return function (rOrN) {
              if (rOrN instanceof Data_Either.Left) {
                  return Data_Semiring.add(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(rOrN.value0.duration)(acc);
              };
              if (rOrN instanceof Data_Either.Right) {
                  return Data_Semiring.add(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(rOrN.value0.abcNote.duration)(acc);
              };
              throw new Error("Failed pattern match at VexFlow.Abc.TickableContext (line 82, column 7 - line 84, column 68): " + [ rOrN.constructor.name ]);
          };
      };
      return Data_Foldable.foldl(Data_Foldable.foldableArray)(f)(Data_Rational.fromInt(0))(rOrNs);
  };
  var getTickableContext = function (m) {
      if (m instanceof Data_Abc.Note) {
          return new TickableContext(1, graceLength(m.value0.maybeGrace), m.value0.abcNote.duration);
      };
      if (m instanceof Data_Abc.Rest) {
          return new TickableContext(1, 0, m.value0.duration);
      };
      if (m instanceof Data_Abc.Chord) {
          var abcNote = Data_List_NonEmpty.head(m.value0.notes);
          var duration = Data_Semiring.mul(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(m.value0.duration)(abcNote.duration);
          return new TickableContext(1, 0, duration);
      };
      if (m instanceof Data_Abc.BrokenRhythmPair) {
          return new TickableContext(2, graceLength(m.value0.maybeGrace) + graceLength(m.value2.maybeGrace) | 0, Data_Semiring.add(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(m.value0.abcNote.duration)(m.value2.abcNote.duration));
      };
      if (m instanceof Data_Abc.Tuplet) {
          var reduction = Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(m.value1.q)(m.value1.p);
          var graceNoteLength = getRorNsGraceLength(Data_List_NonEmpty.toUnfoldable(Data_Unfoldable.unfoldableArray)(m.value2));
          var duration = Data_Semiring.mul(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(reduction)(getRorNsDuration(Data_List_NonEmpty.toUnfoldable(Data_Unfoldable.unfoldableArray)(m.value2)));
          return new TickableContext(m.value1.r, graceNoteLength, duration);
      };
      return Data_Monoid.mempty(tickableMonoidCtx);
  };
  var estimateBarWidth = function (hasClef) {
      return function (hasTimeSig) {
          return function (maybeKeySig) {
              return function (abcBar) {
                  var v = Data_Foldable.foldMap(Data_List_Types.foldableList)(tickableMonoidCtx)(getTickableContext)(abcBar.music);
                  var timeSigCount = (function () {
                      if (hasTimeSig) {
                          return 1.0;
                      };
                      return 0.0;
                  })();
                  var keySigCount = Data_Maybe.maybe(0.0)(keySignatureWidth)(maybeKeySig);
                  var clefCount = (function () {
                      if (hasClef) {
                          return 1.0;
                      };
                      return 0.0;
                  })();
                  return Data_Int.round((clefCount + timeSigCount + keySigCount + tickableCountWidth(v.value0) + 0.5 * Data_Int.toNumber(v.value1)) * pixelsPerItem);
              };
          };
      };
  };
  exports["getTickableContext"] = getTickableContext;
  exports["estimateBarWidth"] = estimateBarWidth;
  exports["tickableSemigroupCtx"] = tickableSemigroupCtx;
  exports["tickableMonoidCtx"] = tickableMonoidCtx;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["VexFlow.Types"] = $PS["VexFlow.Types"] || {};
  var exports = $PS["VexFlow.Types"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Symbol = $PS["Data.Symbol"];
  var VexFlow_Abc_TickableContext = $PS["VexFlow.Abc.TickableContext"];                
  var Single = (function () {
      function Single() {

      };
      Single.value = new Single();
      return Single;
  })();
  var Double = (function () {
      function Double() {

      };
      Double.value = new Double();
      return Double;
  })();
  var NoLine = (function () {
      function NoLine() {

      };
      NoLine.value = new NoLine();
      return NoLine;
  })();
  var MusicSpec = function (x) {
      return x;
  };
  var staveSeparation = 100;
  var staveIndentation = 10; 
  var musicSpecSemigroup = new Data_Semigroup.Semigroup(function (v) {
      return function (v1) {
          return Data_Semigroup.append(Data_Semigroup.semigroupRecord()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
              return "beatMarkers";
          }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
              return "contextChanges";
          }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
              return "noteSpecs";
          }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
              return "slurBrackets";
          }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
              return "tickableContext";
          }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
              return "ties";
          }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
              return "tuplets";
          }))()(Data_Semigroup.semigroupRecordNil)(Data_Semigroup.semigroupArray))(Data_Semigroup.semigroupArray))(VexFlow_Abc_TickableContext.tickableSemigroupCtx))(Data_Semigroup.semigroupArray))(Data_Semigroup.semigroupArray))(Data_Semigroup.semigroupArray))(Data_Semigroup.semigroupArray)))(v)(v1);
      };
  });
  var musicSpecMonoid = new Data_Monoid.Monoid(function () {
      return musicSpecSemigroup;
  }, {
      noteSpecs: Data_Monoid.mempty(Data_Monoid.monoidArray),
      tuplets: Data_Monoid.mempty(Data_Monoid.monoidArray),
      ties: Data_Monoid.mempty(Data_Monoid.monoidArray),
      tickableContext: Data_Monoid.mempty(VexFlow_Abc_TickableContext.tickableMonoidCtx),
      contextChanges: Data_Monoid.mempty(Data_Monoid.monoidArray),
      slurBrackets: Data_Monoid.mempty(Data_Monoid.monoidArray),
      beatMarkers: Data_Monoid.mempty(Data_Monoid.monoidArray)
  });
  var eqLineThickness = new Data_Eq.Eq(function (x) {
      return function (y) {
          if (x instanceof Single && y instanceof Single) {
              return true;
          };
          if (x instanceof Double && y instanceof Double) {
              return true;
          };
          if (x instanceof NoLine && y instanceof NoLine) {
              return true;
          };
          return false;
      };
  });
  exports["staveIndentation"] = staveIndentation;
  exports["staveSeparation"] = staveSeparation;
  exports["MusicSpec"] = MusicSpec;
  exports["Single"] = Single;
  exports["Double"] = Double;
  exports["NoLine"] = NoLine;
  exports["musicSpecMonoid"] = musicSpecMonoid;
  exports["eqLineThickness"] = eqLineThickness;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["VexFlow.Abc.Utils"] = $PS["VexFlow.Abc.Utils"] || {};
  var exports = $PS["VexFlow.Abc.Utils"];
  var Control_Category = $PS["Control.Category"];
  var Data_Abc = $PS["Data.Abc"];
  var Data_Abc_Metadata = $PS["Data.Abc.Metadata"];
  var Data_Array = $PS["Data.Array"];
  var Data_Either = $PS["Data.Either"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Int = $PS["Data.Int"];
  var Data_List = $PS["Data.List"];
  var Data_List_NonEmpty = $PS["Data.List.NonEmpty"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ratio = $PS["Data.Ratio"];
  var Data_Rational = $PS["Data.Rational"];
  var Data_Ring = $PS["Data.Ring"];
  var Data_Semiring = $PS["Data.Semiring"];
  var Data_Show = $PS["Data.Show"];
  var Data_String_CodeUnits = $PS["Data.String.CodeUnits"];
  var Data_Tuple = $PS["Data.Tuple"];
  var VexFlow_Abc_Beat = $PS["VexFlow.Abc.Beat"];
  var VexFlow_Abc_ContextChange = $PS["VexFlow.Abc.ContextChange"];
  var VexFlow_Types = $PS["VexFlow.Types"];                
  var updateAbcContext = function (abcContext) {
      return function (change) {
          if (change instanceof VexFlow_Abc_ContextChange.MeterChange) {
              var timeSignature = {
                  numerator: change.value0.value0,
                  denominator: change.value0.value1
              };
              return {
                  timeSignature: timeSignature,
                  keySignature: abcContext.keySignature,
                  mTempo: abcContext.mTempo,
                  unitNoteLength: abcContext.unitNoteLength,
                  staveNo: abcContext.staveNo,
                  accumulatedStaveWidth: abcContext.accumulatedStaveWidth,
                  isMidVolta: abcContext.isMidVolta,
                  isNewTimeSignature: true,
                  maxWidth: abcContext.maxWidth,
                  pendingRepeatBegin: abcContext.pendingRepeatBegin,
                  beatDuration: VexFlow_Abc_Beat.beatDuration({
                      numerator: change.value0.value0,
                      denominator: change.value0.value1
                  })
              };
          };
          if (change instanceof VexFlow_Abc_ContextChange.KeyChange) {
              return {
                  timeSignature: abcContext.timeSignature,
                  keySignature: change.value0.keySignature,
                  mTempo: abcContext.mTempo,
                  unitNoteLength: abcContext.unitNoteLength,
                  staveNo: abcContext.staveNo,
                  accumulatedStaveWidth: abcContext.accumulatedStaveWidth,
                  isMidVolta: abcContext.isMidVolta,
                  isNewTimeSignature: false,
                  maxWidth: abcContext.maxWidth,
                  pendingRepeatBegin: abcContext.pendingRepeatBegin,
                  beatDuration: abcContext.beatDuration
              };
          };
          if (change instanceof VexFlow_Abc_ContextChange.UnitNoteChange) {
              return {
                  timeSignature: abcContext.timeSignature,
                  keySignature: abcContext.keySignature,
                  mTempo: abcContext.mTempo,
                  unitNoteLength: change.value0,
                  staveNo: abcContext.staveNo,
                  accumulatedStaveWidth: abcContext.accumulatedStaveWidth,
                  isMidVolta: abcContext.isMidVolta,
                  isNewTimeSignature: false,
                  maxWidth: abcContext.maxWidth,
                  pendingRepeatBegin: abcContext.pendingRepeatBegin,
                  beatDuration: abcContext.beatDuration
              };
          };
          throw new Error("Failed pattern match at VexFlow.Abc.Utils (line 191, column 3 - line 208, column 19): " + [ change.constructor.name ]);
      };
  };
  var noteTicks = function (unitNoteLength) {
      return function (d) {
          return Data_Int.round(Data_Rational.toNumber(Data_Semiring.mul(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(Data_Semiring.mul(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(unitNoteLength)(d))(Data_Rational.fromInt(128))));
      };
  };
  var vexDuration = function (unitNoteLength) {
      return function (d) {
          var v = noteTicks(unitNoteLength)(d);
          if (v === 128) {
              return new Data_Either.Right({
                  vexDurString: "w",
                  dots: 0
              });
          };
          if (v === 112) {
              return new Data_Either.Right({
                  vexDurString: "h",
                  dots: 2
              });
          };
          if (v === 96) {
              return new Data_Either.Right({
                  vexDurString: "h",
                  dots: 1
              });
          };
          if (v === 64) {
              return new Data_Either.Right({
                  vexDurString: "h",
                  dots: 0
              });
          };
          if (v === 56) {
              return new Data_Either.Right({
                  vexDurString: "q",
                  dots: 2
              });
          };
          if (v === 48) {
              return new Data_Either.Right({
                  vexDurString: "q",
                  dots: 1
              });
          };
          if (v === 32) {
              return new Data_Either.Right({
                  vexDurString: "q",
                  dots: 0
              });
          };
          if (v === 28) {
              return new Data_Either.Right({
                  vexDurString: "8",
                  dots: 2
              });
          };
          if (v === 24) {
              return new Data_Either.Right({
                  vexDurString: "8",
                  dots: 1
              });
          };
          if (v === 16) {
              return new Data_Either.Right({
                  vexDurString: "8",
                  dots: 0
              });
          };
          if (v === 14) {
              return new Data_Either.Right({
                  vexDurString: "16",
                  dots: 2
              });
          };
          if (v === 12) {
              return new Data_Either.Right({
                  vexDurString: "16",
                  dots: 1
              });
          };
          if (v === 8) {
              return new Data_Either.Right({
                  vexDurString: "16",
                  dots: 0
              });
          };
          if (v === 7) {
              return new Data_Either.Right({
                  vexDurString: "32",
                  dots: 2
              });
          };
          if (v === 6) {
              return new Data_Either.Right({
                  vexDurString: "32",
                  dots: 1
              });
          };
          if (v === 4) {
              return new Data_Either.Right({
                  vexDurString: "32",
                  dots: 0
              });
          };
          if (v === 3) {
              return new Data_Either.Right({
                  vexDurString: "64",
                  dots: 1
              });
          };
          if (v === 2) {
              return new Data_Either.Right({
                  vexDurString: "64",
                  dots: 0
              });
          };
          return new Data_Either.Left("too long or too dotted duration: " + (Data_Show.show(Data_Show.showInt)(Data_Ratio.numerator(d)) + ("/" + Data_Show.show(Data_Show.showInt)(Data_Ratio.denominator(d)))));
      };
  };
  var noteDotCount = function (ctx) {
      return function (abcNote) {
          var v = vexDuration(ctx.unitNoteLength)(abcNote.duration);
          if (v instanceof Data_Either.Right) {
              return v.value0.dots;
          };
          return 0;
      };
  };
  var normaliseBroken = function (broken) {
      return function (gn1) {
          return function (gn2) {
              var up = function (i) {
                  return Data_Semiring.add(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(Data_Rational.fromInt(1))(Data_Abc_Metadata.dotFactor(i));
              };
              var down = function (i) {
                  return Data_Ring.sub(Data_Ratio.ringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(Data_Rational.fromInt(1))(Data_Abc_Metadata.dotFactor(i));
              };
              if (broken instanceof Data_Abc.LeftArrow) {
                  var righta = {
                      duration: Data_Semiring.mul(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(gn2.abcNote.duration)(up(broken.value0)),
                      accidental: gn2.abcNote.accidental,
                      octave: gn2.abcNote.octave,
                      pitchClass: gn2.abcNote.pitchClass,
                      tied: gn2.abcNote.tied
                  };
                  var lefta = {
                      duration: Data_Semiring.mul(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(gn1.abcNote.duration)(down(broken.value0)),
                      accidental: gn1.abcNote.accidental,
                      octave: gn1.abcNote.octave,
                      pitchClass: gn1.abcNote.pitchClass,
                      tied: gn1.abcNote.tied
                  };
                  return new Data_Tuple.Tuple({
                      abcNote: lefta,
                      decorations: gn1.decorations,
                      leftSlurs: gn1.leftSlurs,
                      maybeGrace: gn1.maybeGrace,
                      rightSlurs: gn1.rightSlurs
                  }, {
                      abcNote: righta,
                      decorations: gn2.decorations,
                      leftSlurs: gn2.leftSlurs,
                      maybeGrace: gn2.maybeGrace,
                      rightSlurs: gn2.rightSlurs
                  });
              };
              if (broken instanceof Data_Abc.RightArrow) {
                  var righta = {
                      duration: Data_Semiring.mul(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(gn2.abcNote.duration)(down(broken.value0)),
                      accidental: gn2.abcNote.accidental,
                      octave: gn2.abcNote.octave,
                      pitchClass: gn2.abcNote.pitchClass,
                      tied: gn2.abcNote.tied
                  };
                  var lefta = {
                      duration: Data_Semiring.mul(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(gn1.abcNote.duration)(up(broken.value0)),
                      accidental: gn1.abcNote.accidental,
                      octave: gn1.abcNote.octave,
                      pitchClass: gn1.abcNote.pitchClass,
                      tied: gn1.abcNote.tied
                  };
                  return new Data_Tuple.Tuple({
                      abcNote: lefta,
                      decorations: gn1.decorations,
                      leftSlurs: gn1.leftSlurs,
                      maybeGrace: gn1.maybeGrace,
                      rightSlurs: gn1.rightSlurs
                  }, {
                      abcNote: righta,
                      decorations: gn2.decorations,
                      leftSlurs: gn2.leftSlurs,
                      maybeGrace: gn2.maybeGrace,
                      rightSlurs: gn2.rightSlurs
                  });
              };
              throw new Error("Failed pattern match at VexFlow.Abc.Utils (line 135, column 5 - line 154, column 68): " + [ broken.constructor.name ]);
          };
      };
  };
  var nextStaveNo = function (v) {
      if (v instanceof Data_Maybe.Nothing) {
          return new Data_Maybe.Just(0);
      };
      if (v instanceof Data_Maybe.Just) {
          return new Data_Maybe.Just(v.value0 + 1 | 0);
      };
      throw new Error("Failed pattern match at VexFlow.Abc.Utils (line 219, column 1 - line 219, column 38): " + [ v.constructor.name ]);
  };
  var isEmptyMusicSpec = function (v) {
      return Data_Array["null"](v.noteSpecs);
  };
  var compoundVexDuration = function (vexDur) {
      var dStr = Data_String_CodeUnits.fromCharArray(Data_Array.replicate(vexDur.dots)("d"));
      return vexDur.vexDurString + dStr;
  };
  var chordalNoteLength = function (abcChord) {
      return Data_Semiring.mul(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))((Data_List_NonEmpty.head(abcChord.notes)).duration)(abcChord.duration);
  };
  var cMajor = (function () {
      var ks = {
          pitchClass: Data_Abc.C.value,
          accidental: Data_Abc.Natural.value,
          mode: Data_Abc.Major.value
      };
      return {
          keySignature: ks,
          modifications: Data_List_Types.Nil.value
      };
  })();
  var buildTempo = function (bpm) {
      return function (d) {
          var v = vexDuration(Data_Rational.fromInt(1))(d);
          if (v instanceof Data_Either.Right) {
              return new Data_Either.Right({
                  duration: v.value0.vexDurString,
                  dots: v.value0.dots,
                  bpm: bpm
              });
          };
          if (v instanceof Data_Either.Left) {
              return new Data_Either.Left(v.value0);
          };
          throw new Error("Failed pattern match at VexFlow.Abc.Utils (line 103, column 3 - line 107, column 15): " + [ v.constructor.name ]);
      };
  };
  var tempoMarking = function (unitNoteLength) {
      return function (tempoSig) {
          var tempoNoteLength = Data_Foldable.foldl(Data_List_Types.foldableNonEmptyList)(Data_Semiring.add(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)))(Data_Rational.fromInt(0))(tempoSig.noteLengths);
          return Data_Either.hush(buildTempo(tempoSig.bpm)(tempoNoteLength));
      };
  };
  var initialAbcContext = function (tune) {
      return function (config) {
          var meterSignature = Data_Maybe.fromMaybe(new Data_Tuple.Tuple(4, 4))(Data_Abc_Metadata.getMeter(tune));
          var unitNoteLength = Data_Maybe.fromMaybe(Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(1)(8))(Data_Abc_Metadata.getUnitNoteLength(tune));
          var modifiedKeySignature = Data_Maybe.fromMaybe(cMajor)(Data_Functor.map(Data_Maybe.functorMaybe)(Control_Category.identity(Control_Category.categoryFn))(Data_Abc_Metadata.getKeySig(tune)));
          var mTempo = Data_Maybe.maybe(Data_Maybe.Nothing.value)(tempoMarking(unitNoteLength))(Data_Abc_Metadata.getTempoSig(tune));
          var $36 = Data_List["null"](modifiedKeySignature.modifications);
          if ($36) {
              return new Data_Either.Right({
                  timeSignature: {
                      numerator: meterSignature.value0,
                      denominator: meterSignature.value1
                  },
                  keySignature: modifiedKeySignature.keySignature,
                  mTempo: mTempo,
                  unitNoteLength: unitNoteLength,
                  staveNo: Data_Maybe.Nothing.value,
                  accumulatedStaveWidth: VexFlow_Types.staveIndentation,
                  isMidVolta: false,
                  isNewTimeSignature: true,
                  maxWidth: Data_Int.round(Data_Int.toNumber(config.width - VexFlow_Types.staveIndentation | 0) / config.scale),
                  pendingRepeatBegin: false,
                  beatDuration: VexFlow_Abc_Beat.beatDuration({
                      numerator: meterSignature.value0,
                      denominator: meterSignature.value1
                  })
              });
          };
          return new Data_Either.Left("modifications to standard key signatures are not supported");
      };
  };
  var applyContextChanges = function (abcContext) {
      return function (eSpec) {
          if (eSpec instanceof Data_Either.Right) {
              return Data_Foldable.foldl(Data_Foldable.foldableArray)(updateAbcContext)(abcContext)(eSpec.value0.contextChanges);
          };
          return abcContext;
      };
  };
  exports["applyContextChanges"] = applyContextChanges;
  exports["vexDuration"] = vexDuration;
  exports["compoundVexDuration"] = compoundVexDuration;
  exports["chordalNoteLength"] = chordalNoteLength;
  exports["normaliseBroken"] = normaliseBroken;
  exports["noteDotCount"] = noteDotCount;
  exports["noteTicks"] = noteTicks;
  exports["initialAbcContext"] = initialAbcContext;
  exports["updateAbcContext"] = updateAbcContext;
  exports["nextStaveNo"] = nextStaveNo;
  exports["isEmptyMusicSpec"] = isEmptyMusicSpec;
})(PS);
(function($PS) {
  "use strict";
  $PS["VexFlow.Abc.Translate"] = $PS["VexFlow.Abc.Translate"] || {};
  var exports = $PS["VexFlow.Abc.Translate"];
  var Data_Abc = $PS["Data.Abc"];
  var Data_Abc_Canonical = $PS["Data.Abc.Canonical"];
  var Data_Abc_KeySignature = $PS["Data.Abc.KeySignature"];
  var Data_Array = $PS["Data.Array"];
  var Data_Either = $PS["Data.Either"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_List_NonEmpty = $PS["Data.List.NonEmpty"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ratio = $PS["Data.Ratio"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Semiring = $PS["Data.Semiring"];
  var Data_Show = $PS["Data.Show"];
  var Data_String_Common = $PS["Data.String.Common"];
  var Data_Traversable = $PS["Data.Traversable"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];
  var VexFlow_Abc_Beat = $PS["VexFlow.Abc.Beat"];
  var VexFlow_Abc_ContextChange = $PS["VexFlow.Abc.ContextChange"];
  var VexFlow_Abc_Slur = $PS["VexFlow.Abc.Slur"];
  var VexFlow_Abc_TickableContext = $PS["VexFlow.Abc.TickableContext"];
  var VexFlow_Abc_Utils = $PS["VexFlow.Abc.Utils"];
  var VexFlow_Types = $PS["VexFlow.Types"];                

  // | translate an ABC note decoration into a VexFlow note ornament
  var ornaments = function (decorations) {
      var f = function (acc) {
          return function (decoration) {
              if (decoration === "T") {
                  return Data_Array.cons("tr")(acc);
              };
              if (decoration === "trill") {
                  return Data_Array.cons("tr")(acc);
              };
              if (decoration === "turn") {
                  return Data_Array.cons("turn")(acc);
              };
              if (decoration === "P") {
                  return Data_Array.cons("upmordent")(acc);
              };
              if (decoration === "uppermordent") {
                  return Data_Array.cons("upmordent")(acc);
              };
              if (decoration === "M") {
                  return Data_Array.cons("mordent")(acc);
              };
              if (decoration === "lowermordent") {
                  return Data_Array.cons("mordent")(acc);
              };
              return acc;
          };
      };
      return Data_Foldable.foldl(Data_List_Types.foldableList)(f)([  ])(decorations);
  };

  // | a key signature as a VexFlow String
  // | with 'strange' modes normalised to Major
  var keySignature = function (ks) {
      var newks = (function () {
          if (ks.mode instanceof Data_Abc.Major) {
              return ks;
          };
          if (ks.mode instanceof Data_Abc.Minor) {
              return ks;
          };
          return Data_Abc_KeySignature.normaliseModalKey(ks);
      })();
      var modeStr = (function () {
          if (newks.mode instanceof Data_Abc.Minor) {
              return "m";
          };
          return "";
      })();
      return Data_Show.show(Data_Abc.showPitchClass)(newks.pitchClass) + (Data_Abc_Canonical.keySignatureAccidental(newks.accidental) + modeStr);
  };

  // | cater for an inline header (within a stave)
  // |   we need to cater for changes in key signature, meter or unit note length
  // | which all alter the translation context.  All other headers may be ignored
  var headerChange = function (ctx) {
      return function (h) {
          if (h instanceof Data_Abc.Key) {
              return [ new VexFlow_Abc_ContextChange.KeyChange(h.value0) ];
          };
          if (h instanceof Data_Abc.UnitNoteLength) {
              return [ new VexFlow_Abc_ContextChange.UnitNoteChange(h.value0) ];
          };
          if (h instanceof Data_Abc.Meter) {
              if (h.value0 instanceof Data_Maybe.Just) {
                  return [ new VexFlow_Abc_ContextChange.MeterChange(h.value0.value0) ];
              };
              return [  ];
          };
          return [  ];
      };
  };
  var buildSlurBrackets = function (noteIndex) {
      return function (startCount) {
          return function (endCount) {
              return Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Unfoldable.replicate(Data_Unfoldable.unfoldableArray)(startCount)(new VexFlow_Abc_Slur.LeftBracket(noteIndex)))(Data_Unfoldable.replicate(Data_Unfoldable.unfoldableArray)(endCount)(new VexFlow_Abc_Slur.RightBracket(noteIndex)));
          };
      };
  };
  var buildMusicSpecFromNs = function (tCtx) {
      return function (noteIndex) {
          return function (mBeatMarker) {
              return function (gn1) {
                  return function (gn2) {
                      return function (ens) {
                          var slurBrackets = Data_Semigroup.append(Data_Semigroup.semigroupArray)(buildSlurBrackets(noteIndex)(gn1.leftSlurs)(gn1.rightSlurs))(buildSlurBrackets(noteIndex + 1 | 0)(gn2.leftSlurs)(gn2.rightSlurs));
                          return Data_Functor.map(Data_Either.functorEither)(function (ns) {
                              return {
                                  noteSpecs: ns,
                                  tuplets: [  ],
                                  ties: [  ],
                                  tickableContext: tCtx,
                                  contextChanges: [  ],
                                  slurBrackets: slurBrackets,
                                  beatMarkers: Data_Unfoldable.fromMaybe(Data_Unfoldable.unfoldableArray)(mBeatMarker)
                              };
                          })(ens);
                      };
                  };
              };
          };
      };
  };
  var buildMusicSpecFromN = function (tCtx) {
      return function (noteIndex) {
          return function (mBeatMarker) {
              return function (isTied) {
                  return function (slurStartCount) {
                      return function (slurEndCount) {
                          return function (ens) {
                              return Data_Functor.map(Data_Either.functorEither)(function (ns) {
                                  return {
                                      noteSpecs: [ ns ],
                                      tuplets: [  ],
                                      ties: (function () {
                                          if (isTied) {
                                              return [ noteIndex ];
                                          };
                                          return [  ];
                                      })(),
                                      tickableContext: tCtx,
                                      contextChanges: [  ],
                                      slurBrackets: buildSlurBrackets(noteIndex)(slurStartCount)(slurEndCount),
                                      beatMarkers: Data_Unfoldable.fromMaybe(Data_Unfoldable.unfoldableArray)(mBeatMarker)
                                  };
                              })(ens);
                          };
                      };
                  };
              };
          };
      };
  };
  var buildMusicSpecFromContextChange = function (contextChanges) {
      var v = Data_Monoid.mempty(VexFlow_Types.musicSpecMonoid);
      return {
          noteSpecs: v.noteSpecs,
          tuplets: v.tuplets,
          ties: v.ties,
          tickableContext: v.tickableContext,
          contextChanges: contextChanges,
          slurBrackets: v.slurBrackets,
          beatMarkers: v.beatMarkers
      };
  };

  // | translate an ABC note decoration into a VexFlow note articulation
  var articulations = function (artics) {
      var f = function (acc) {
          return function (decoration) {
              if (decoration === ".") {
                  return Data_Array.cons("a.")(acc);
              };
              if (decoration === "upbow") {
                  return Data_Array.cons("a|")(acc);
              };
              if (decoration === "u") {
                  return Data_Array.cons("a|")(acc);
              };
              if (decoration === "downbow") {
                  return Data_Array.cons("am")(acc);
              };
              if (decoration === "v") {
                  return Data_Array.cons("am")(acc);
              };
              if (decoration === "L") {
                  return Data_Array.cons("a>")(acc);
              };
              if (decoration === "accent") {
                  return Data_Array.cons("a>")(acc);
              };
              if (decoration === "emphasis") {
                  return Data_Array.cons("a>")(acc);
              };
              if (decoration === "H") {
                  return Data_Array.cons("a@a")(acc);
              };
              if (decoration === "fermata") {
                  return Data_Array.cons("a@a")(acc);
              };
              if (decoration === "tenuto") {
                  return Data_Array.cons("a-")(acc);
              };
              return acc;
          };
      };
      return Data_Foldable.foldl(Data_List_Types.foldableList)(f)([  ])(artics);
  };
  var accidental = function (v) {
      if (v instanceof Data_Abc.Sharp) {
          return "#";
      };
      if (v instanceof Data_Abc.Flat) {
          return "b";
      };
      if (v instanceof Data_Abc.DoubleSharp) {
          return "##";
      };
      if (v instanceof Data_Abc.DoubleFlat) {
          return "bb";
      };
      if (v instanceof Data_Abc.Natural) {
          return "n";
      };
      if (v instanceof Data_Abc.Implicit) {
          return "";
      };
      throw new Error("Failed pattern match at VexFlow.Abc.Translate (line 43, column 1 - line 43, column 35): " + [ v.constructor.name ]);
  };

  // | return the VexFlow string representation of a note's accidental
  var noteAccidental = function (abcNote) {
      return accidental(abcNote.accidental);
  };

  // | generate a VexFlow indication of pitch
  var pitch = function (pc) {
      return function (acc) {
          return function (oct) {
              return Data_String_Common.toLower(Data_Show.show(Data_Abc.showPitchClass)(pc)) + (accidental(acc) + ("/" + Data_Show.show(Data_Show.showInt)(oct)));
          };
      };
  };

  // | return the VexFlow pitch of a note
  var notePitch = function (abcNote) {
      return pitch(abcNote.pitchClass)(abcNote.accidental)(abcNote.octave - 1 | 0);
  };

  // | translate an ABC chord to a VexFlow note
  // | failing if the durations cannot be translated
  // | n.b. in VexFlow, all notes in a chord must have the same duration
  // | this is a mismatch with ABC.  We just take the first note as representative
  var chord = function (context) {
      return function (abcChord) {
          var keys = Data_Functor.map(Data_Functor.functorArray)(notePitch)(Data_List_NonEmpty.toUnfoldable(Data_Unfoldable.unfoldableArray)(abcChord.notes));
          var dotCounts = Data_Functor.map(Data_Functor.functorArray)(VexFlow_Abc_Utils.noteDotCount(context))(Data_List_NonEmpty.toUnfoldable(Data_Unfoldable.unfoldableArray)(abcChord.notes));
          var chordLen = VexFlow_Abc_Utils.chordalNoteLength(abcChord);
          var eVexDur = VexFlow_Abc_Utils.vexDuration(context.unitNoteLength)(chordLen);
          var accidentals = Data_Functor.map(Data_Functor.functorArray)(noteAccidental)(Data_List_NonEmpty.toUnfoldable(Data_Unfoldable.unfoldableArray)(abcChord.notes));
          if (eVexDur instanceof Data_Either.Right) {
              var vexNote = {
                  clef: "treble",
                  keys: keys,
                  duration: VexFlow_Abc_Utils.compoundVexDuration(eVexDur.value0),
                  auto_stem: true
              };
              return new Data_Either.Right({
                  vexNote: vexNote,
                  accidentals: accidentals,
                  dots: dotCounts,
                  graceKeys: [  ],
                  graceAccidentals: [  ],
                  ornaments: [  ],
                  articulations: [  ],
                  noteTicks: VexFlow_Abc_Utils.noteTicks(context.unitNoteLength)(chordLen)
              });
          };
          if (eVexDur instanceof Data_Either.Left) {
              return new Data_Either.Left(eVexDur.value0);
          };
          throw new Error("Failed pattern match at VexFlow.Abc.Translate (line 225, column 5 - line 244, column 23): " + [ eVexDur.constructor.name ]);
      };
  };

  // | Translate an ABC graceable note to a VexFlow note
  // | failing if the duration cannot be translated
  // | noteIndex is the index of the note within any bigger structure such as
  // | a tuplet or broken rhythm pair and is 0 for a note on its own
  var graceableNote = function (context) {
      return function (noteIndex) {
          return function (gn) {
              var key = notePitch(gn.abcNote);
              var graceNotes = Data_Maybe.maybe([  ])(function (grace) {
                  return Data_List_NonEmpty.toUnfoldable(Data_Unfoldable.unfoldableArray)(grace.notes);
              })(gn.maybeGrace);
              var graceKeys = Data_Functor.map(Data_Functor.functorArray)(notePitch)(graceNotes);
              var graceAccidentals = Data_Functor.map(Data_Functor.functorArray)(noteAccidental)(graceNotes);
            
              // edur = noteDur context gn.abcNote
  var eVexDur = VexFlow_Abc_Utils.vexDuration(context.unitNoteLength)(gn.abcNote.duration);
              if (eVexDur instanceof Data_Either.Right) {
                  var vexNote = {
                      clef: "treble",
                      keys: [ key ],
                      duration: VexFlow_Abc_Utils.compoundVexDuration(eVexDur.value0),
                      auto_stem: true
                  };
                  return new Data_Either.Right({
                      vexNote: vexNote,
                      accidentals: [ accidental(gn.abcNote.accidental) ],
                      dots: [ eVexDur.value0.dots ],
                      graceKeys: graceKeys,
                      graceAccidentals: graceAccidentals,
                      ornaments: ornaments(gn.decorations),
                      articulations: articulations(gn.decorations),
                      noteTicks: VexFlow_Abc_Utils.noteTicks(context.unitNoteLength)(gn.abcNote.duration)
                  });
              };
              if (eVexDur instanceof Data_Either.Left) {
                  return new Data_Either.Left(eVexDur.value0);
              };
              throw new Error("Failed pattern match at VexFlow.Abc.Translate (line 148, column 5 - line 167, column 23): " + [ eVexDur.constructor.name ]);
          };
      };
  };

  // | translate an ABC broken note pair to a VexFlow note pair
  // | failing if either duration cannot be translated
  // | not finished - n1 can alter the context for n2
  var brokenRhythm = function (context) {
      return function (gn1) {
          return function (broken) {
              return function (gn2) {
                  var v = VexFlow_Abc_Utils.normaliseBroken(broken)(gn1)(gn2);
                  var enote2 = graceableNote(context)(1)(v.value1);
                  var enote1 = graceableNote(context)(0)(v.value0);
                  var v1 = new Data_Tuple.Tuple(enote1, enote2);
                  if (v1.value0 instanceof Data_Either.Right && v1.value1 instanceof Data_Either.Right) {
                      return new Data_Either.Right([ v1.value0.value0, v1.value1.value0 ]);
                  };
                  if (v1.value0 instanceof Data_Either.Left) {
                      return new Data_Either.Left(v1.value0.value0);
                  };
                  if (v1.value1 instanceof Data_Either.Left) {
                      return new Data_Either.Left(v1.value1.value0);
                  };
                  throw new Error("Failed pattern match at VexFlow.Abc.Translate (line 256, column 5 - line 262, column 16): " + [ v1.constructor.name ]);
              };
          };
      };
  };

  // | translate an ABC rest to a VexFlow note
  // | which we'll position on the B stave line
  // | failing if the duration cannot be translated
  var rest = function (context) {
      return function (abcRest) {
        
          // edur = duration context.unitNoteLength abcRest.duration
  var key = pitch(Data_Abc.B.value)(Data_Abc.Implicit.value)(4);
          var eVexDur = VexFlow_Abc_Utils.vexDuration(context.unitNoteLength)(abcRest.duration);
          if (eVexDur instanceof Data_Either.Right) {
              var vexNote = {
                  clef: "treble",
                  keys: [ key ],
                  duration: VexFlow_Abc_Utils.compoundVexDuration(eVexDur.value0) + "r",
                  auto_stem: true
              };
              return new Data_Either.Right({
                  vexNote: vexNote,
                  accidentals: [  ],
                  dots: [ eVexDur.value0.dots ],
                  graceKeys: [  ],
                  graceAccidentals: [  ],
                  ornaments: [  ],
                  articulations: [  ],
                  noteTicks: VexFlow_Abc_Utils.noteTicks(context.unitNoteLength)(abcRest.duration)
              });
          };
          if (eVexDur instanceof Data_Either.Left) {
              return new Data_Either.Left(eVexDur.value0);
          };
          throw new Error("Failed pattern match at VexFlow.Abc.Translate (line 180, column 5 - line 199, column 23): " + [ eVexDur.constructor.name ]);
      };
  };
  var restOrNote = function (context) {
      return function (noteIndex) {
          return function (rOrn) {
              if (rOrn instanceof Data_Either.Left) {
                  return rest(context)(rOrn.value0);
              };
              if (rOrn instanceof Data_Either.Right) {
                  return graceableNote(context)(noteIndex)(rOrn.value0);
              };
              throw new Error("Failed pattern match at VexFlow.Abc.Translate (line 294, column 3 - line 298, column 41): " + [ rOrn.constructor.name ]);
          };
      };
  };

  // | translate an ABC tuplet to a VexFlow tuplet spec
  // | failing if any note duration cannot be translated
  var tuplet = function (context) {
      return function (startOffset) {
          return function (signature) {
              return function (rns) {
                  var vexTuplet = {
                      p: signature.p,
                      q: signature.q,
                      startPos: startOffset,
                      endPos: startOffset + Data_Array.length(rns) | 0
                  };
                  var isTied = (function () {
                      var v = Data_Array.last(rns);
                      if (v instanceof Data_Maybe.Just && v.value0 instanceof Data_Either.Right) {
                          return v.value0.value0.abcNote.tied;
                      };
                      return false;
                  })();
                  var enoteSpecs = Data_Traversable.sequence(Data_Traversable.traversableArray)(Data_Either.applicativeEither)(Data_Array.mapWithIndex(restOrNote(context))(rns));
                  if (enoteSpecs instanceof Data_Either.Right) {
                      return new Data_Either.Right({
                          vexTuplet: vexTuplet,
                          noteSpecs: enoteSpecs.value0,
                          tied: isTied
                      });
                  };
                  if (enoteSpecs instanceof Data_Either.Left) {
                      return new Data_Either.Left(enoteSpecs.value0);
                  };
                  throw new Error("Failed pattern match at VexFlow.Abc.Translate (line 282, column 5 - line 290, column 15): " + [ enoteSpecs.constructor.name ]);
              };
          };
      };
  };

  // | translate any ABC music item that produces score to a VexFlow music spec
  // | producing an empty array if it doesn't do so
  // | NoteCount is the count of 'tickable' items (notes or otherwise)
  // | that precede this music item in the bar
  var music = function (context) {
      return function (tickablePosition) {
          return function (noteIndex) {
              return function (phraseDuration) {
                  return function (m) {
                    
                      // find the number and size of 'tickable' items in this music item
  var tickableContext = VexFlow_Abc_TickableContext.getTickableContext(m);
                    
                      // find the fraction  of the bar that has already been processed
  var barFraction = Data_Semiring.mul(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(phraseDuration)(context.unitNoteLength);
                      var mBeatMarker = VexFlow_Abc_Beat.exactBeatNumber(barFraction)(context.beatDuration)(noteIndex);
                      if (m instanceof Data_Abc.Note) {
                          return buildMusicSpecFromN(tickableContext)(noteIndex)(mBeatMarker)(m.value0.abcNote.tied)(m.value0.leftSlurs)(m.value0.rightSlurs)(graceableNote(context)(0)(m.value0));
                      };
                      if (m instanceof Data_Abc.Rest) {
                          return buildMusicSpecFromN(tickableContext)(noteIndex)(mBeatMarker)(false)(0)(0)(rest(context)(m.value0));
                      };
                      if (m instanceof Data_Abc.Chord) {
                          return buildMusicSpecFromN(tickableContext)(noteIndex)(mBeatMarker)(false)(0)(0)(chord(context)(m.value0));
                      };
                      if (m instanceof Data_Abc.BrokenRhythmPair) {
                          return buildMusicSpecFromNs(tickableContext)(noteIndex)(mBeatMarker)(m.value0)(m.value2)(brokenRhythm(context)(m.value0)(m.value1)(m.value2));
                      };
                      if (m instanceof Data_Abc.Tuplet) {
                          var eRes = tuplet(context)(tickablePosition)(m.value1)(Data_List_NonEmpty.toUnfoldable(Data_Unfoldable.unfoldableArray)(m.value2));
                          return Data_Functor.map(Data_Either.functorEither)(function (tupletSpec) {
                              return {
                                  noteSpecs: tupletSpec.noteSpecs,
                                  tuplets: [ tupletSpec.vexTuplet ],
                                  ties: (function () {
                                      if (tupletSpec.tied) {
                                          return [ (noteIndex + Data_Array.length(tupletSpec.noteSpecs) | 0) - 1 | 0 ];
                                      };
                                      return [  ];
                                  })(),
                                  tickableContext: tickableContext,
                                  contextChanges: Data_Monoid.mempty(Data_Monoid.monoidArray),
                                  slurBrackets: Data_Monoid.mempty(Data_Monoid.monoidArray),
                                  beatMarkers: Data_Unfoldable.fromMaybe(Data_Unfoldable.unfoldableArray)(mBeatMarker)
                              };
                          })(eRes);
                      };
                      if (m instanceof Data_Abc.Inline) {
                          return Data_Either.Right.create(buildMusicSpecFromContextChange(headerChange(context)(m.value0)));
                      };
                      return Data_Either.Right.create(Data_Monoid.mempty(VexFlow_Types.musicSpecMonoid));
                  };
              };
          };
      };
  };
  exports["keySignature"] = keySignature;
  exports["headerChange"] = headerChange;
  exports["music"] = music;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["VexFlow.Abc.Volta"] = $PS["VexFlow.Abc.Volta"] || {};
  var exports = $PS["VexFlow.Abc.Volta"];
  var Data_Abc = $PS["Data.Abc"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Show = $PS["Data.Show"];                
  var isEndVolta = function (barType) {
      return Data_Eq.eq(Data_Maybe.eqMaybe(Data_Abc.eqRepeat))(barType.repeat)(new Data_Maybe.Just(Data_Abc.End.value)) || (Data_Eq.eq(Data_Maybe.eqMaybe(Data_Abc.eqRepeat))(barType.repeat)(new Data_Maybe.Just(Data_Abc.BeginAndEnd.value)) || (Data_Eq.eq(Data_Maybe.eqMaybe(Data_Abc.eqRepeat))(barType.repeat)(new Data_Maybe.Just(Data_Abc.Begin.value)) || Data_Eq.notEq(Data_Abc.eqThickness)(barType.thickness)(Data_Abc.Thin.value) && Data_Eq.notEq(Data_Abc.eqThickness)(barType.thickness)(Data_Abc.Invisible.value)));
  };
  var isMidVolta = function (barType) {
      return function (current) {
          var $1 = Data_Maybe.isJust(barType.iteration);
          if ($1) {
              return true;
          };
          var $2 = isEndVolta(barType);
          if ($2) {
              return false;
          };
          return current;
      };
  };
  var startVolta = function (barType) {
      return function (isCurrentlyMidVolta) {
          if (barType.iteration instanceof Data_Maybe.Nothing) {
              if (isCurrentlyMidVolta) {
                  var $5 = isEndVolta(barType);
                  if ($5) {
                      return Data_Maybe.Nothing.value;
                  };
                  return new Data_Maybe.Just({
                      voltaType: 3,
                      iteration: ""
                  });
              };
              return Data_Maybe.Nothing.value;
          };
          if (barType.iteration instanceof Data_Maybe.Just) {
              return new Data_Maybe.Just({
                  voltaType: 2,
                  iteration: Data_Show.show(Data_Show.showInt)(barType.iteration.value0)
              });
          };
          throw new Error("Failed pattern match at VexFlow.Abc.Volta (line 43, column 3 - line 57, column 13): " + [ barType.iteration.constructor.name ]);
      };
  };
  var completeVolta = function (mvolta) {
      if (mvolta instanceof Data_Maybe.Nothing) {
          return Data_Maybe.Nothing.value;
      };
      if (mvolta instanceof Data_Maybe.Just) {
          var newVoltaType = (function () {
              if (mvolta.value0.voltaType === 2) {
                  return 5;
              };
              if (mvolta.value0.voltaType === 3) {
                  return 4;
              };
              if (mvolta.value0.voltaType === 5) {
                  return 4;
              };
              return mvolta.value0.voltaType;
          })();
          return Data_Maybe.Just.create({
              voltaType: newVoltaType,
              iteration: mvolta.value0.iteration
          });
      };
      throw new Error("Failed pattern match at VexFlow.Abc.Volta (line 64, column 3 - line 81, column 48): " + [ mvolta.constructor.name ]);
  };
  exports["startVolta"] = startVolta;
  exports["completeVolta"] = completeVolta;
  exports["isMidVolta"] = isMidVolta;
  exports["isEndVolta"] = isEndVolta;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["VexFlow.Abc.BarEnd"] = $PS["VexFlow.Abc.BarEnd"] || {};
  var exports = $PS["VexFlow.Abc.BarEnd"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad_State = $PS["Control.Monad.State"];
  var Control_Monad_State_Class = $PS["Control.Monad.State.Class"];
  var Control_Monad_State_Trans = $PS["Control.Monad.State.Trans"];
  var Data_Abc = $PS["Data.Abc"];
  var Data_Array = $PS["Data.Array"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Identity = $PS["Data.Identity"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Monoid = $PS["Data.Monoid"];
  var VexFlow_Abc_Utils = $PS["VexFlow.Abc.Utils"];
  var VexFlow_Abc_Volta = $PS["VexFlow.Abc.Volta"];
  var VexFlow_Types = $PS["VexFlow.Types"];                
  var staveWidth = function (bs) {
      return Data_Maybe.maybe(0)(function (b) {
          return b.xOffset + b.width | 0;
      })(Data_Array.last(bs));
  };
  var staveEndsWithRepeatBegin = function (bs) {
      var isBeginVolta = function (b) {
          return Data_Eq.eq(Data_Maybe.eqMaybe(Data_Abc.eqRepeat))(b.startLine.repeat)(new Data_Maybe.Just(Data_Abc.Begin.value)) || Data_Eq.eq(Data_Maybe.eqMaybe(Data_Abc.eqRepeat))(b.startLine.repeat)(new Data_Maybe.Just(Data_Abc.BeginAndEnd.value));
      };
      return Data_Maybe.maybe(false)(isBeginVolta)(Data_Array.last(bs));
  };
  var simpleBarType = {
      thickness: Data_Abc.Thin.value,
      repeat: Data_Maybe.Nothing.value,
      iteration: Data_Maybe.Nothing.value
  };
  var redundantBar = function (barSpec) {
      return VexFlow_Abc_Utils.isEmptyMusicSpec(barSpec.musicSpec) && barSpec.barNumber !== 0;
  };
  var fillStaveLine = function (maxWidth) {
      return function (bs) {
          var v = Data_Array.last(bs);
          if (v instanceof Data_Maybe.Just) {
              var currentWidth = v.value0.xOffset + v.value0.width | 0;
              var $6 = currentWidth <= maxWidth;
              if ($6) {
                  var completionBar = {
                      barNumber: v.value0.barNumber + 1 | 0,
                      width: maxWidth - currentWidth | 0,
                      xOffset: currentWidth,
                      startLine: simpleBarType,
                      endLineThickness: VexFlow_Types.NoLine.value,
                      endLineRepeat: false,
                      volta: Data_Maybe.Nothing.value,
                      beamSpecs: [  ],
                      curves: [  ],
                      musicSpec: Data_Monoid.mempty(VexFlow_Types.musicSpecMonoid),
                      timeSignature: v.value0.timeSignature
                  };
                  return Data_Array.snoc(bs)(completionBar);
              };
              return bs;
          };
          if (v instanceof Data_Maybe.Nothing) {
              return bs;
          };
          throw new Error("Failed pattern match at VexFlow.Abc.BarEnd (line 84, column 3 - line 107, column 9): " + [ v.constructor.name ]);
      };
  };
  var barlineThickness = function (barType) {
      if (barType.thickness instanceof Data_Abc.Thin) {
          return VexFlow_Types.Single.value;
      };
      if (barType.thickness instanceof Data_Abc.Invisible) {
          return VexFlow_Types.NoLine.value;
      };
      return VexFlow_Types.Double.value;
  };
  var shiftBarEnd = function (acc) {
      return function (barSpec) {
          return Control_Bind.bind(Control_Monad_State_Trans.bindStateT(Data_Identity.monadIdentity))(Control_Monad_State_Class.get(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity)))(function (v) {
              var newVolta = (function () {
                  var $10 = VexFlow_Abc_Volta.isEndVolta(v);
                  if ($10) {
                      return VexFlow_Abc_Volta.completeVolta(barSpec.volta);
                  };
                  return barSpec.volta;
              })();
              var lastLineThickness = barlineThickness(v);
              var isLastBarEndRepeat = Data_Eq.eq(Data_Maybe.eqMaybe(Data_Abc.eqRepeat))(v.repeat)(new Data_Maybe.Just(Data_Abc.End.value)) || Data_Eq.eq(Data_Maybe.eqMaybe(Data_Abc.eqRepeat))(v.repeat)(new Data_Maybe.Just(Data_Abc.BeginAndEnd.value));
              var newBarSpec = {
                  endLineRepeat: isLastBarEndRepeat,
                  endLineThickness: lastLineThickness,
                  volta: newVolta,
                  barNumber: barSpec.barNumber,
                  beamSpecs: barSpec.beamSpecs,
                  curves: barSpec.curves,
                  musicSpec: barSpec.musicSpec,
                  startLine: barSpec.startLine,
                  timeSignature: barSpec.timeSignature,
                  width: barSpec.width,
                  xOffset: barSpec.xOffset
              };
              return Control_Bind.bind(Control_Monad_State_Trans.bindStateT(Data_Identity.monadIdentity))(Control_Monad_State_Class.put(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))(barSpec.startLine))(function (v1) {
                  var $11 = redundantBar(barSpec);
                  if ($11) {
                      return Control_Applicative.pure(Control_Monad_State_Trans.applicativeStateT(Data_Identity.monadIdentity))(acc);
                  };
                  return Control_Applicative.pure(Control_Monad_State_Trans.applicativeStateT(Data_Identity.monadIdentity))(Data_Array.cons(newBarSpec)(acc));
              });
          });
      };
  };
  var shiftBarEnds = Data_Foldable.foldM(Data_Foldable.foldableArray)(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))(shiftBarEnd)(Data_Monoid.mempty(Data_Monoid.monoidArray));
  var repositionBarEndRepeats = function (bs) {
      return Control_Monad_State.evalState(shiftBarEnds(Data_Array.reverse(bs)))(simpleBarType);
  };
  exports["repositionBarEndRepeats"] = repositionBarEndRepeats;
  exports["fillStaveLine"] = fillStaveLine;
  exports["staveEndsWithRepeatBegin"] = staveEndsWithRepeatBegin;
  exports["staveWidth"] = staveWidth;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["VexFlow.Abc.Beam"] = $PS["VexFlow.Abc.Beam"] || {};
  var exports = $PS["VexFlow.Abc.Beam"];
  var Data_Array = $PS["Data.Array"];
  var Data_Array_NonEmpty = $PS["Data.Array.NonEmpty"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_HeytingAlgebra = $PS["Data.HeytingAlgebra"];
  var Data_Map_Internal = $PS["Data.Map.Internal"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_String_Utils = $PS["Data.String.Utils"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];                
  var toRanges = function (mis) {
      var toRange = function (range) {
          return {
              start: Data_Maybe.fromJust()(Data_Array_NonEmpty.head(range)),
              end: Data_Maybe.fromJust()(Data_Array_NonEmpty.last(range)) + 1 | 0
          };
      };
      return Data_Functor.map(Data_Functor.functorArray)(toRange)(mis);
  };
  var subsumes = function (as) {
      return function ($$new) {
          var envelops = function (little) {
              return function (big) {
                  return big.start <= little.start && big.end >= little.end;
              };
          };
          return Data_Foldable.any(Data_Foldable.foldableArray)(Data_HeytingAlgebra.heytingAlgebraBoolean)(envelops($$new))(as);
      };
  };
  var quarterNoteTicks = 32;
  var merge = function (standardBeams) {
      return function (tupletBeams) {
          var mergeFunc = function (sBeams) {
              return function (tupletBeam) {
                  var $4 = subsumes(sBeams)(tupletBeam);
                  if ($4) {
                      return sBeams;
                  };
                  return Data_Array.snoc(sBeams)(tupletBeam);
              };
          };
          return Data_Foldable.foldl(Data_Foldable.foldableArray)(mergeFunc)(standardBeams)(tupletBeams);
      };
  };
  var isBeamableNote = function (noteSpec) {
      return noteSpec.noteTicks < quarterNoteTicks && !Data_String_Utils.endsWith("r")(noteSpec.vexNote.duration);
  };
  var groupBeamables = function (mis) {
      return Data_Array.groupBy(function (a) {
          return function (b) {
              return Data_Maybe.isJust(a) && Data_Maybe.isJust(b);
          };
      })(mis);
  };
  var filterRanges = function (mis) {
      return Data_Array.filter(function (a) {
          return Data_Array_NonEmpty.length(a) > 1;
      })(mis);
  };
  var commonTime = {
      numerator: 4,
      denominator: 4
  };
  var coalesce = function (v) {
      return function (v1) {
          if (v instanceof Data_Maybe.Just && v1 instanceof Data_Maybe.Just) {
              return [ {
                  start: v.value0.start,
                  end: v1.value0.end
              } ];
          };
          if (v instanceof Data_Maybe.Just) {
              return [ v.value0 ];
          };
          if (v1 instanceof Data_Maybe.Just) {
              return [ v1.value0 ];
          };
          return [  ];
      };
  };
  var optimiseCommonTimeBeaming = function (bm) {
      return Data_Semigroup.append(Data_Semigroup.semigroupArray)(coalesce(Data_Map_Internal.lookup(Data_Ord.ordInt)(1)(bm))(Data_Map_Internal.lookup(Data_Ord.ordInt)(2)(bm)))(coalesce(Data_Map_Internal.lookup(Data_Ord.ordInt)(3)(bm))(Data_Map_Internal.lookup(Data_Ord.ordInt)(4)(bm)));
  };
  var buildTupletBeamables = function (vt) {
      return function (noteSpecs) {
          var f = function (i) {
              return function (n) {
                  var $11 = isBeamableNote(n);
                  if ($11) {
                      return new Data_Maybe.Just(i + vt.startPos | 0);
                  };
                  return Data_Maybe.Nothing.value;
              };
          };
          return Data_Array.mapWithIndex(f)(Data_Array.slice(vt.startPos)(vt.endPos)(noteSpecs));
      };
  };
  var generateTupletBeamRanges = function (vt) {
      return function (noteSpecs) {
          return toRanges(filterRanges(groupBeamables(buildTupletBeamables(vt)(noteSpecs))));
      };
  };
  var calculateTupletBeams = function (noteSpecs) {
      return function (vts) {
          var f = function (bs) {
              return function (vt) {
                  return Data_Semigroup.append(Data_Semigroup.semigroupArray)(bs)(generateTupletBeamRanges(vt)(noteSpecs));
              };
          };
          return Data_Foldable.foldl(Data_Foldable.foldableArray)(f)([  ])(vts);
      };
  };
  var allBeamableNotes = function (noteSpecs) {
      var f = function (acc) {
          return function (ns) {
              return acc && isBeamableNote(ns);
          };
      };
      return Data_Foldable.foldl(Data_Foldable.foldableArray)(f)(true)(noteSpecs);
  };
  var beamFunc = function (noteSpecs) {
      return function (acc) {
          return function (beatMarker) {
              var $12 = (beatMarker.beatNumber - acc.beatMarker.beatNumber | 0) === 1 && ((beatMarker.noteIndex - acc.beatMarker.noteIndex | 0) > 1 && allBeamableNotes(Data_Array.slice(acc.beatMarker.noteIndex)(beatMarker.noteIndex)(noteSpecs)));
              if ($12) {
                  var newBeam = {
                      start: acc.beatMarker.noteIndex,
                      end: beatMarker.noteIndex
                  };
                  return {
                      beatMarker: beatMarker,
                      beams: Data_Map_Internal.insert(Data_Ord.ordInt)(beatMarker.beatNumber)(newBeam)(acc.beams)
                  };
              };
              return {
                  beatMarker: beatMarker,
                  beams: acc.beams
              };
          };
      };
  };
  var calculateStandardBeams = function (timeSignature) {
      return function (noteSpecs) {
          return function (beatMarkers) {
              var initialBM = {
                  beatNumber: 0,
                  noteIndex: 0
              };
              var result = Data_Foldable.foldl(Data_Foldable.foldableArray)(beamFunc(noteSpecs))({
                  beatMarker: initialBM,
                  beams: Data_Map_Internal.empty
              })(beatMarkers);
              var $13 = Data_Eq.eq(Data_Eq.eqRec()(Data_Eq.eqRowCons(Data_Eq.eqRowCons(Data_Eq.eqRowNil)()(new Data_Symbol.IsSymbol(function () {
                  return "numerator";
              }))(Data_Eq.eqInt))()(new Data_Symbol.IsSymbol(function () {
                  return "denominator";
              }))(Data_Eq.eqInt)))(commonTime)(timeSignature);
              if ($13) {
                  return optimiseCommonTimeBeaming(result.beams);
              };
              return Data_Functor.map(Data_Functor.functorArray)(Data_Tuple.snd)(Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(result.beams));
          };
      };
  };
  var calculateLeadinBeam = function (ns) {
      var len = Data_Array.length(ns);
      var $14 = 1 < len && allBeamableNotes(ns);
      if ($14) {
          return [ [ 0, len ] ];
      };
      return [  ];
  };
  var calculateBeams = function (timeSignature) {
      return function (noteSpecs) {
          return function (beatMarkers) {
              return function (tuplets) {
                  var $15 = Data_Array.length(beatMarkers) > 1;
                  if ($15) {
                      return Data_Functor.map(Data_Functor.functorArray)(function (r) {
                          return [ r.start, r.end ];
                      })(merge(calculateStandardBeams(timeSignature)(noteSpecs)(beatMarkers))(calculateTupletBeams(noteSpecs)(tuplets)));
                  };
                  return calculateLeadinBeam(noteSpecs);
              };
          };
      };
  };
  exports["calculateBeams"] = calculateBeams;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["VexFlow.Abc.TranslateStateful"] = $PS["VexFlow.Abc.TranslateStateful"] || {};
  var exports = $PS["VexFlow.Abc.TranslateStateful"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad_Error_Class = $PS["Control.Monad.Error.Class"];
  var Control_Monad_Except_Trans = $PS["Control.Monad.Except.Trans"];
  var Control_Monad_State_Class = $PS["Control.Monad.State.Class"];
  var Control_Monad_State_Trans = $PS["Control.Monad.State.Trans"];
  var Data_Abc = $PS["Data.Abc"];
  var Data_Abc_Metadata = $PS["Data.Abc.Metadata"];
  var Data_Array = $PS["Data.Array"];
  var Data_Either = $PS["Data.Either"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Identity = $PS["Data.Identity"];
  var Data_List = $PS["Data.List"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Newtype = $PS["Data.Newtype"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ratio = $PS["Data.Ratio"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Semiring = $PS["Data.Semiring"];
  var Data_Show = $PS["Data.Show"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Data_Traversable = $PS["Data.Traversable"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];
  var VexFlow_Abc_BarEnd = $PS["VexFlow.Abc.BarEnd"];
  var VexFlow_Abc_Beam = $PS["VexFlow.Abc.Beam"];
  var VexFlow_Abc_Beat = $PS["VexFlow.Abc.Beat"];
  var VexFlow_Abc_Slur = $PS["VexFlow.Abc.Slur"];
  var VexFlow_Abc_TickableContext = $PS["VexFlow.Abc.TickableContext"];
  var VexFlow_Abc_Translate = $PS["VexFlow.Abc.Translate"];
  var VexFlow_Abc_Utils = $PS["VexFlow.Abc.Utils"];
  var VexFlow_Abc_Volta = $PS["VexFlow.Abc.Volta"];
  var VexFlow_Types = $PS["VexFlow.Types"];                
  var zipBars = function (bs) {
      var intArray = Data_Array.range(0)(Data_List.length(bs));
      var barArray = Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(bs);
      return Data_Array.zip(intArray)(barArray);
  };
  var music = function (tickablePosition) {
      return function (noteIndex) {
          return function (phraseDuration) {
              return function (m) {
                  return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Monad_State_Class.get(Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))))(function (v) {
                      var spec = VexFlow_Abc_Translate.music(v)(tickablePosition)(noteIndex)(phraseDuration)(m);
                      var newContext = VexFlow_Abc_Utils.applyContextChanges(v)(spec);
                      return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Monad_State_Class.put(Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity)))(newContext))(function (v1) {
                          return Data_Either.either(Control_Monad_Error_Class.throwError(Control_Monad_Except_Trans.monadThrowExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))))(Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))))(spec);
                      });
                  });
              };
          };
      };
  };
  var modifiedStartLine = function (isPendingRepeatbegin) {
      return function (barType) {
          if (isPendingRepeatbegin) {
              return {
                  thickness: barType.thickness,
                  repeat: new Data_Maybe.Just(Data_Abc.Begin.value),
                  iteration: barType.iteration
              };
          };
          return barType;
      };
  };
  var foldMusicsFunction = function (eacc) {
      return function (m) {
          var noteIndex = Data_Array.length(eacc.noteSpecs);
          return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(music(eacc.tickableContext.value0)(noteIndex)(eacc.tickableContext.value2)(m))(function (v) {
              return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Data_Semigroup.append(Data_Semigroup.semigroupRecord()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
                  return "beatMarkers";
              }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
                  return "contextChanges";
              }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
                  return "noteSpecs";
              }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
                  return "slurBrackets";
              }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
                  return "tickableContext";
              }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
                  return "ties";
              }))()(Data_Semigroup.semigroupRecordCons(new Data_Symbol.IsSymbol(function () {
                  return "tuplets";
              }))()(Data_Semigroup.semigroupRecordNil)(Data_Semigroup.semigroupArray))(Data_Semigroup.semigroupArray))(VexFlow_Abc_TickableContext.tickableSemigroupCtx))(Data_Semigroup.semigroupArray))(Data_Semigroup.semigroupArray))(Data_Semigroup.semigroupArray))(Data_Semigroup.semigroupArray)))(eacc)(v));
          });
      };
  };
  var foldOverMusics = Data_Foldable.foldM(Data_Foldable.foldableArray)(Control_Monad_Except_Trans.monadExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(foldMusicsFunction)(Data_Monoid.mempty(VexFlow_Types.musicSpecMonoid));
  var addFinalBeatMarker = function (abcContext) {
      return function (v) {
          var barDuration = Data_Semiring.mul(Data_Ratio.semiringRatio(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt))(v.tickableContext.value2)(abcContext.unitNoteLength);
          var mBeatMarker = VexFlow_Abc_Beat.exactBeatNumber(barDuration)(abcContext.beatDuration)(v.tickableContext.value0);
          return VexFlow_Types.MusicSpec({
              noteSpecs: v.noteSpecs,
              tuplets: v.tuplets,
              ties: v.ties,
              tickableContext: v.tickableContext,
              contextChanges: v.contextChanges,
              slurBrackets: v.slurBrackets,
              beatMarkers: Data_Semigroup.append(Data_Semigroup.semigroupArray)(v.beatMarkers)(Data_Unfoldable.fromMaybe(Data_Unfoldable.unfoldableArray)(mBeatMarker))
          });
      };
  };
  var bar = function (staveNumber) {
      return function (barNumber) {
          return function (abcBar) {
              return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(foldOverMusics(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(abcBar.music)))(function (v) {
                  return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Monad_State_Class.get(Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))))(function (v1) {
                      var musicSpec = addFinalBeatMarker(v1)(v);
                      var volta = (function () {
                          var $38 = barNumber === 0 && VexFlow_Abc_Utils.isEmptyMusicSpec(musicSpec);
                          if ($38) {
                              return Data_Maybe.Nothing.value;
                          };
                          return VexFlow_Abc_Volta.startVolta(abcBar.startLine)(v1.isMidVolta);
                      })();
                      var newIsMidVolta = VexFlow_Abc_Volta.isMidVolta(abcBar.startLine)(v1.isMidVolta);
                      var displayedKeySig = (function () {
                          var $39 = barNumber === 0;
                          if ($39) {
                              return new Data_Maybe.Just(v1.keySignature);
                          };
                          return Data_Maybe.Nothing.value;
                      })();
                      var width = VexFlow_Abc_TickableContext.estimateBarWidth(barNumber === 0)(v1.isNewTimeSignature)(displayedKeySig)(abcBar);
                      var barSpec = {
                          barNumber: barNumber,
                          width: width,
                          xOffset: v1.accumulatedStaveWidth,
                          startLine: modifiedStartLine(v1.pendingRepeatBegin)(abcBar.startLine),
                          endLineThickness: VexFlow_Types.Single.value,
                          endLineRepeat: false,
                          volta: volta,
                          timeSignature: v1.timeSignature,
                          beamSpecs: VexFlow_Abc_Beam.calculateBeams(v1.timeSignature)(musicSpec.noteSpecs)(musicSpec.beatMarkers)(musicSpec.tuplets),
                          curves: VexFlow_Abc_Slur.vexCurves(musicSpec.slurBrackets),
                          musicSpec: musicSpec
                      };
                      var newWidth = v1.accumulatedStaveWidth + barSpec.width | 0;
                      var newAbcContext = {
                          accumulatedStaveWidth: newWidth,
                          isMidVolta: newIsMidVolta,
                          isNewTimeSignature: false,
                          pendingRepeatBegin: false,
                          beatDuration: v1.beatDuration,
                          keySignature: v1.keySignature,
                          mTempo: v1.mTempo,
                          maxWidth: v1.maxWidth,
                          staveNo: v1.staveNo,
                          timeSignature: v1.timeSignature,
                          unitNoteLength: v1.unitNoteLength
                      };
                      return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Monad_State_Class.put(Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity)))(newAbcContext))(function (v2) {
                          return Control_Monad_Except_Trans.withExceptT(Control_Monad_State_Trans.functorStateT(Data_Identity.functorIdentity))(function (err) {
                              return err + (": bar " + Data_Show.show(Data_Show.showInt)(barNumber));
                          })(Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(barSpec));
                      });
                  });
              });
          };
      };
  };
  var bars = function (staveNumber) {
      return function (bs) {
          var tupleArray = zipBars(bs);
          return Data_Traversable.traverse(Data_Traversable.traversableArray)(Control_Monad_Except_Trans.applicativeExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(function (v) {
              return bar(staveNumber)(v.value0)(v.value1);
          })(tupleArray);
      };
  };
  var bodyPart = function (bp) {
      if (bp instanceof Data_Abc.Score) {
          var $44 = Data_Abc_Metadata.isEmptyStave(bp.value0);
          if ($44) {
              return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Data_Maybe.Nothing.value);
          };
          return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Monad_State_Class.get(Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))))(function (v) {
              var mStaveNo = VexFlow_Abc_Utils.nextStaveNo(v.staveNo);
              var staveNo = Data_Maybe.fromMaybe(0)(mStaveNo);
              return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Monad_State_Class.put(Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity)))((function () {
                  var $46 = {};
                  for (var $47 in v) {
                      if ({}.hasOwnProperty.call(v, $47)) {
                          $46[$47] = v[$47];
                      };
                  };
                  $46.staveNo = mStaveNo;
                  $46.accumulatedStaveWidth = VexFlow_Types.staveIndentation;
                  return $46;
              })()))(function (v1) {
                  return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(bars(staveNo)(bp.value0))(function (v2) {
                      return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Monad_State_Class.get(Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))))(function (v3) {
                          var pendingRepeatBegin = VexFlow_Abc_BarEnd.staveEndsWithRepeatBegin(v2);
                          var normalisedStaveBars = VexFlow_Abc_BarEnd.repositionBarEndRepeats(v2);
                          var filledStaveLine = VexFlow_Abc_BarEnd.fillStaveLine(v.maxWidth)(normalisedStaveBars);
                          var accumulatedStaveWidth = VexFlow_Abc_BarEnd.staveWidth(normalisedStaveBars);
                          return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Monad_State_Class.put(Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity)))((function () {
                              var $51 = {};
                              for (var $52 in v3) {
                                  if ({}.hasOwnProperty.call(v3, $52)) {
                                      $51[$52] = v3[$52];
                                  };
                              };
                              $51.pendingRepeatBegin = pendingRepeatBegin;
                              return $51;
                          })()))(function (v4) {
                              return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(new Data_Maybe.Just({
                                  staveNo: staveNo,
                                  staveWidth: accumulatedStaveWidth,
                                  keySignature: v.keySignature,
                                  isNewTimeSignature: v.isNewTimeSignature,
                                  mTempo: v.mTempo,
                                  barSpecs: filledStaveLine
                              }));
                          });
                      });
                  });
              });
          });
      };
      if (bp instanceof Data_Abc.BodyInfo) {
          return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Monad_State_Class.get(Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))))(function (v) {
              var contextChanges = VexFlow_Abc_Translate.headerChange(v)(bp.value0);
              var newAbcContext = Data_Foldable.foldl(Data_Foldable.foldableArray)(VexFlow_Abc_Utils.updateAbcContext)(v)(contextChanges);
              return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Monad_State_Class.put(Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity)))(newAbcContext))(function (v1) {
                  return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Data_Maybe.Nothing.value);
              });
          });
      };
      throw new Error("Failed pattern match at VexFlow.Abc.TranslateStateful (line 78, column 3 - line 124, column 21): " + [ bp.constructor.name ]);
  };
  var tuneBody = function (bodyParts) {
      return Data_Traversable.traverse(Data_Traversable.traversableArray)(Control_Monad_Except_Trans.applicativeExceptT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(bodyPart)(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(bodyParts));
  };
  var runTuneBody = function (abcContext) {
      return function (bps) {
          return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(Control_Monad_State_Trans.evalStateT(Data_Identity.functorIdentity)(Control_Monad_Except_Trans.runExceptT(tuneBody(bps)))(abcContext));
      };
  };
  exports["runTuneBody"] = runTuneBody;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["VexFlow.Score"] = $PS["VexFlow.Score"] || {};
  var exports = $PS["VexFlow.Score"];
  var $foreign = $PS["VexFlow.Score"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Data_Abc = $PS["Data.Abc"];
  var Data_Either = $PS["Data.Either"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Unit = $PS["Data.Unit"];
  var Effect = $PS["Effect"];
  var Effect_Console = $PS["Effect.Console"];
  var VexFlow_Abc_ContextChange = $PS["VexFlow.Abc.ContextChange"];
  var VexFlow_Abc_Translate = $PS["VexFlow.Abc.Translate"];
  var VexFlow_Abc_TranslateStateful = $PS["VexFlow.Abc.TranslateStateful"];
  var VexFlow_Abc_Utils = $PS["VexFlow.Abc.Utils"];
  var VexFlow_Types = $PS["VexFlow.Types"];                
  var staveConfig = function (staveNo) {
      return function (barSpec) {
          return {
              x: barSpec.xOffset,
              y: VexFlow_Types.staveSeparation * staveNo | 0,
              width: barSpec.width,
              barNo: barSpec.barNumber,
              hasRightBar: Data_Eq.notEq(VexFlow_Types.eqLineThickness)(barSpec.endLineThickness)(VexFlow_Types.NoLine.value),
              hasDoubleRightBar: Data_Eq.eq(VexFlow_Types.eqLineThickness)(barSpec.endLineThickness)(VexFlow_Types.Double.value)
          };
      };
  };
  var processVolta = function (staveBar) {
      return function (mVolta) {
          if (mVolta instanceof Data_Maybe.Just) {
              return $foreign.displayVolta(staveBar)(mVolta.value0);
          };
          return Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit);
      };
  };
  var processBarEndRepeat = function (staveBar) {
      return function (isRepeat) {
          if (isRepeat) {
              return $foreign.displayBarEndRepeat(staveBar);
          };
          return Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit);
      };
  };
  var processBarBeginRepeat = function (staveBar) {
      return function (mRepeat) {
          if (mRepeat instanceof Data_Maybe.Just && mRepeat.value0 instanceof Data_Abc.Begin) {
              return $foreign.displayBarBeginRepeat(staveBar);
          };
          if (mRepeat instanceof Data_Maybe.Just && mRepeat.value0 instanceof Data_Abc.End) {
              return Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit);
          };
          if (mRepeat instanceof Data_Maybe.Just && mRepeat.value0 instanceof Data_Abc.BeginAndEnd) {
              return $foreign.displayBarBeginRepeat(staveBar);
          };
          return Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit);
      };
  };
  var newStave = function (staveCnfg) {
      return function (ks) {
          return $foreign.newStaveImpl(staveCnfg)(VexFlow_Abc_Translate.keySignature(ks));
      };
  };
  var displayContextChange = function (staveBar) {
      return function (contextChange) {
          if (contextChange instanceof VexFlow_Abc_ContextChange.MeterChange) {
              return $foreign.addTimeSignature(staveBar)({
                  numerator: contextChange.value0.value0,
                  denominator: contextChange.value0.value1
              });
          };
          if (contextChange instanceof VexFlow_Abc_ContextChange.KeyChange) {
              return $foreign.addKeySignature(staveBar)(VexFlow_Abc_Translate.keySignature(contextChange.value0.keySignature));
          };
          if (contextChange instanceof VexFlow_Abc_ContextChange.UnitNoteChange) {
              return Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit);
          };
          throw new Error("Failed pattern match at VexFlow.Score (line 167, column 3 - line 175, column 16): " + [ contextChange.constructor.name ]);
      };
  };
  var createScoreAtStave = function (staveNo) {
      return function (config) {
          return function (abcTune) {
              var v = VexFlow_Abc_Utils.initialAbcContext(abcTune)(config);
              if (v instanceof Data_Either.Left) {
                  return new Data_Either.Left(v.value0);
              };
              if (v instanceof Data_Either.Right) {
                  return VexFlow_Abc_TranslateStateful.runTuneBody({
                      timeSignature: v.value0.timeSignature,
                      keySignature: v.value0.keySignature,
                      mTempo: v.value0.mTempo,
                      unitNoteLength: v.value0.unitNoteLength,
                      staveNo: new Data_Maybe.Just(staveNo),
                      accumulatedStaveWidth: v.value0.accumulatedStaveWidth,
                      isMidVolta: v.value0.isMidVolta,
                      isNewTimeSignature: v.value0.isNewTimeSignature,
                      maxWidth: v.value0.maxWidth,
                      pendingRepeatBegin: v.value0.pendingRepeatBegin,
                      beatDuration: v.value0.beatDuration
                  })(abcTune.body);
              };
              throw new Error("Failed pattern match at VexFlow.Score (line 74, column 3 - line 78, column 71): " + [ v.constructor.name ]);
          };
      };
  };
  var addTempoMarking = function (stave) {
      return function (mTempo) {
          return Data_Maybe.maybe(Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit))($foreign.addTempoMarkingImpl(stave))(mTempo);
      };
  };
  var displayBarSpec = function (renderer) {
      return function (staveSpec) {
          return function (barSpec) {
              return function __do() {
                  var v = newStave(staveConfig(staveSpec.staveNo)(barSpec))(staveSpec.keySignature)();
                  Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(displayContextChange(v))(barSpec.musicSpec.contextChanges)();
                  (function () {
                      var $30 = barSpec.barNumber === 0 && staveSpec.isNewTimeSignature;
                      if ($30) {
                          return $foreign.addTimeSignature(v)(barSpec.timeSignature)();
                      };
                      return Data_Unit.unit;
                  })();
                  (function () {
                      var $31 = barSpec.barNumber === 0 && staveSpec.staveNo === 0;
                      if ($31) {
                          return addTempoMarking(v)(staveSpec.mTempo)();
                      };
                      return Data_Unit.unit;
                  })();
                  var v1 = processBarBeginRepeat(v)(barSpec.startLine.repeat)();
                  var v2 = processBarEndRepeat(v)(barSpec.endLineRepeat)();
                  var v3 = processVolta(v)(barSpec.volta)();
                  $foreign.renderBarContents(renderer)(v)(barSpec.beamSpecs)(barSpec.curves)(barSpec.musicSpec)();
                  return $foreign.renderStave(renderer)(v)();
              };
          };
      };
  };
  var displayStaveSpec = function (renderer) {
      return function (mStaveSpec) {
          if (mStaveSpec instanceof Data_Maybe.Just) {
              return Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(displayBarSpec(renderer)(mStaveSpec.value0))(mStaveSpec.value0.barSpecs);
          };
          return Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit);
      };
  };
  var renderScore = function (config) {
      return function (renderer) {
          return function (eStaveSpecs) {
              if (eStaveSpecs instanceof Data_Either.Right) {
                  return function __do() {
                      var v = Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(displayStaveSpec(renderer))(eStaveSpecs.value0)();
                      return true;
                  };
              };
              if (eStaveSpecs instanceof Data_Either.Left) {
                  return function __do() {
                      var v = Effect_Console.log("error in producing score: " + eStaveSpecs.value0)();
                      return false;
                  };
              };
              throw new Error("Failed pattern match at VexFlow.Score (line 83, column 3 - line 89, column 17): " + [ eStaveSpecs.constructor.name ]);
          };
      };
  };
  var renderTuneAtStave = function (staveNo) {
      return function (config) {
          return function (renderer) {
              return function (abcTune) {
                  return renderScore(config)(renderer)(createScoreAtStave(staveNo)(config)(abcTune));
              };
          };
      };
  };
  exports["renderTuneAtStave"] = renderTuneAtStave;
  exports["initialiseCanvas"] = $foreign.initialiseCanvas;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.3
  "use strict";
  $PS["Examples.Slurs.Main"] = $PS["Examples.Slurs.Main"] || {};
  var exports = $PS["Examples.Slurs.Main"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Data_Abc_Parser = $PS["Data.Abc.Parser"];
  var Data_Either = $PS["Data.Either"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Int = $PS["Data.Int"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ratio = $PS["Data.Ratio"];
  var Data_Unit = $PS["Data.Unit"];
  var Effect = $PS["Effect"];
  var Examples_Slurs_Texts = $PS["Examples.Slurs.Texts"];
  var VexFlow_Abc_Beat = $PS["VexFlow.Abc.Beat"];
  var VexFlow_Score = $PS["VexFlow.Score"];
  var VexFlow_Types = $PS["VexFlow.Types"];                
  var scale = 0.8;
  var canvasWidth = 1200;
  var config = {
      parentElementId: "canvas",
      width: canvasWidth,
      height: 1600,
      scale: scale,
      isSVG: true
  };
  var displayAtStave = function (renderer) {
      return function (text) {
          return function (staveNo) {
              var eAbcTune = Data_Abc_Parser.parse(text);
              if (eAbcTune instanceof Data_Either.Right) {
                  return VexFlow_Score.renderTuneAtStave(staveNo)(config)(renderer)(eAbcTune.value0);
              };
              return Control_Applicative.pure(Effect.applicativeEffect)(false);
          };
      };
  };
  var main = function __do() {
      var v = VexFlow_Score.initialiseCanvas(config)();
      var v1 = displayAtStave(v)(Examples_Slurs_Texts.slurs1)(0)();
      var v2 = displayAtStave(v)(Examples_Slurs_Texts.slurs2)(1)();
      var v3 = displayAtStave(v)(Examples_Slurs_Texts.brokenRhythmSlurs)(2)();
      return Data_Unit.unit;
  };
  var abcContext = function (v) {
      return function (keySignature) {
          return function (staveNo) {
              return {
                  timeSignature: {
                      numerator: v.value0,
                      denominator: v.value1
                  },
                  keySignature: keySignature,
                  mTempo: Data_Maybe.Nothing.value,
                  unitNoteLength: Data_Ratio.reduce(Data_Ord.ordInt)(Data_EuclideanRing.euclideanRingInt)(1)(16),
                  staveNo: new Data_Maybe.Just(staveNo),
                  accumulatedStaveWidth: VexFlow_Types.staveIndentation,
                  isMidVolta: false,
                  isNewTimeSignature: false,
                  maxWidth: Data_Int.round(Data_Int.toNumber(canvasWidth) / scale),
                  pendingRepeatBegin: false,
                  beatDuration: VexFlow_Abc_Beat.beatDuration({
                      numerator: v.value0,
                      denominator: v.value1
                  })
              };
          };
      };
  };
  exports["canvasWidth"] = canvasWidth;
  exports["scale"] = scale;
  exports["config"] = config;
  exports["abcContext"] = abcContext;
  exports["displayAtStave"] = displayAtStave;
  exports["main"] = main;
})(PS);
PS["Examples.Slurs.Main"].main();